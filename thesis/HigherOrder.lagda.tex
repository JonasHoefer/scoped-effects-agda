\begin{code}[hide]
{-# OPTIONS --overlapping-instances #-}

module HigherOrder where

open import Size using (↑_; Size; ∞)
open import Function using (_∘_; id; case_of_; const; _$_)
open import Level using (Level; 0ℓ; Lift; lift; Setω)

open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Empty using (⊥)
open import Data.Product using (Σ-syntax; _×_; _,_) renaming (proj₁ to π₁; proj₂ to π₂)
open import Data.Maybe using (Maybe; fromMaybe; nothing; just)
open import Data.Nat using (ℕ; suc; zero)
open import Data.List using (List; _∷_; []; foldr; _++_)
open import Data.Sum using (_⊎_; inj₁; inj₂; [_,_])
open import Data.String using (String)
open import Data.Unit using (⊤; tt)

open import Relation.Unary using (_⊆_)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong; sym; trans)

variable
  A B : Set
  F : Set → Set₁
  i : Size
  C : ∀ {ℓ} → Set ℓ → Set ℓ
\end{code}

To address problems of the first order approach, noted in section
\ref{first-order:results}, \citeauthor{DBLP:conf/haskell/WuSH14} introduce a
second approach using higher order abstract
syntax~\cite{DBLP:conf/haskell/WuSH14} to directly represent scoping
constructs. 
By changing the syntax, this approach moves away from the exact definition of
algebraic effects, but the general concept of defining syntax and inducing
semantics using a handler is still present.
This approach is usually used in Haskell to implement scoped effects.
\citeauthor{bunkenburg2019modeling} already tried to implement some scoped
effects using this approach, but failed due to limitations of
Coq~\cite{bunkenburg2019modeling}.
Due to other limitations, needed for the consistency of Agda, this approach
ultimately failed again.

In section \ref{higher-order:syntax} introduce the concept of higher order
syntax as described by \textcite{DBLP:conf/haskell/WuSH14}.
We partially follows Bunkenburg's approach, because the limitation of Coq
described by him does not exist in Agda.
In section \ref{higher-order:container} we discuss different
representation for higher order syntax in Agda.
We present a central problem with all of these representations, which generally
prohibits us from implementing deep effects, without making excessive changes.
In section \ref{higher-order:fixes} we discuss some potential changes to the
representation and their consequences.
Because deep effects are an uncommon requirement, in section
\ref{higher-order:limited-impl} we still presents a limited implementation,
to highlight some details specific to Agda.


\section{Higher Order Syntax}
\label{higher-order:syntax}

In the first order approach effects only store their continuations.
If the effect has a local scope, the continuations is expected to contain a
closing scope delimiter.
In the higher order approach by \textcite{DBLP:conf/haskell/WuSH14} scoped
effects store possible continuations as well as the part of the program in their
scope.
In the following we explain the basic construction of higher order syntax in
Haskell by \textcite{DBLP:conf/haskell/WuSH14}, before we present results
regarding an Agda implementation.

In the first order approach the functors, which describe the syntax, are applied
to types of the form \texttt{Free F A} i.e. programs consisting of syntax
described by \texttt{Free F}, which produce values of type \texttt{A}.
In the higher order approach these functors are generalized to higher order
functors, that is in Haskell data types of kind \texttt{(* -> *) -> (* -> *)}.
These functors are applied to \texttt{Free F} and \texttt{A} separately.

Because the program type is separated in syntax and result type it is possible
to store programs, which use the same signature but produce values of different
types.
Consider the following definition of the higher order exception syntax as given
by \textcite{DBLP:conf/haskell/WuSH14}.

\begin{minted}{haskell}
    data HExc e m a = Throw e | forall x. Catch (m x) (e -> m x) (x -> m a)
\end{minted}
The \texttt{Catch} operation stores the computation in the scope of the catch
block \texttt{m x}, the handler producing an alternate result in case of an
error \texttt{e -> m x} as well as the rest of the program \texttt{x -> m a}, in
the following called continuation.
The three programs agree on an arbitrary but per \texttt{catch} fixed type
\texttt{x} as well as a common signature, defined by \texttt{m}.

Calling \AgdaFunction{>>=} on a higher order term just extends the continuation
i.e. just substitutes the variables in subterms of type \texttt{m a}.
Figure \ref{higher-order:syntax:bind} demonstrates the action of
\AgdaFunction{>>=} an \AgdaFunction{catch}.
The program in scope and the $e$ indexed subprogram (the exception handler) both
produce values of the captured type $X$, therefore \AgdaFunction{>>=} does not
affect them.
Only the third computation is of type \AgdaArgument{A} and therefore effected by
\AgdaFunction{>>=}.
Therefore these operations are not algebraic, but also capture the notation of
scopes.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}[level distance=1.0cm,sibling distance=1.7cm]
      \node[treenode] at (0,0) {\textbf{catch}$_X$}
          child[sibling distance=1.3cm] {
              node[treenode] {\textbf{p}}
          }
          child[sibling distance=1.3cm] {
              node[treenode] {\textbf{h}$\; e$} edge from parent node[right,draw=none] {$e$}
          }
          child[sibling distance=1.3cm] {
              node[treenode] {\textbf{cont}$\; x$} edge from parent node[right,draw=none,xshift=0.1cm] {$x$}
          }
      ;

      \node at (3.0,-0.5) {$\gg\!\!=\;k\quad \equiv$};

      \node[treenode] at (6.3,0) {\textbf{catch}$_X$}
          child[sibling distance=1.7cm] {
              node[treenode] {\textbf{p}}
          }
          child[sibling distance=1.7cm] {
            node[treenode] {\textbf{h}$\; e$} edge from parent node[right,draw=none] {$e$}
          }
          child[sibling distance=1.7cm] {
              node[treenode] {\textbf{cont}$x\;\bind{}\; k$} edge from parent node[right,draw=none,xshift=0.1cm] {$x$}
          }
      ;
    \end{tikzpicture}
  \end{center}
  \caption{calling \bind{} on an operation with a local scope}
  \label{higher-order:syntax:bind}
\end{figure}


\subsection{Representing Strictly Positive Higher Order Functors}
\label{higher-order:container}

In Haskell the generalization to higher order syntax is straight forward.
In Agda we again have to find an appropriate representation for functors to
guaranty strict positivity, which leads to the idea of an indexed container as
described by \textcite{DBLP:journals/jfp/AltenkirchGHMM15}
\footnote{Note that this is not the first publication related to indexed
  containers. Papers of the same name, by the same author(s) exist, as well as
  data types, known as ``Interaction Structures'' with essentially the same
  shape.}. 
Indexed containers from the paper as well in the Agda standard library are
defined as follows\footnote{The names of the fields are changed and level
  polymorphism is omitted to highlight differences between the definitions.}.

\begin{code}
record IndexedContainer (I O : Set₁) : Set₁ where
  field
    Shape : O → Set
    Pos : ∀ {o} → Shape o → Set
    Ctx : ∀ {o} → (s : Shape o) → Pos s → I

  ⟦_⟧ : (I → Set) → (O → Set)
  ⟦_⟧ F A = Σ[ s ∈ Shape A ] ((p : Pos s) → F (Ctx s p))
\end{code}
Allowing indicies of arbitrary levels and instantiating \AgdaArgument{I} and
\AgdaArgument{O} with \AgdaDatatype{Set} gives rise to a container extension
of the correct shape.

\textcite{bunkenburg2019modeling} also tried using indexed container.
The above definition is similar to his first definition of a container
representation for a higher order functor.
His definition is given below.
\begin{code}
record HContainer : Set₂ where
  field
    Shape : Set₁
    Pos : Shape → Set
    Ctx : (s : Shape) → Pos s → Set → Set

  ⟦_⟧ : (Set → Set₁) → (Set → Set₁)
  ⟦_⟧ F A = Σ[ s ∈ Shape ] ((p : Pos s) → F (Ctx s p A))
\end{code}
In the second definition the \AgdaField{Shape} and \AgdaField{Pos} types cannot
depend on the given index i.e. the argument for the returned functor.
Otherwise, both definitions are quite similar.
All stored elements are lifted by the given functor \AgdaArgument{F}.
\AgdaArgument{F}'s argument is generated using \AgdaField{Ctx}.
\AgdaField{Ctx} has access to the chosen shape, accessed position and the 
argument type \AgdaArgument{A}.
Conceptually, \AgdaField{Ctx} is used to choose between the stored
\AgdaArgument{X} and the argument type \AgdaArgument{A} i.e. programs inside or
outside the operations scope.

Bunkenburg noted that it is not possible to define \AgdaFunction{>>=}
generically for the definition above~\cite{bunkenburg2019modeling}.
Similar to the Haskell implementation by \textcite{DBLP:conf/haskell/WuSH14} we
could define a type class to implement a \AgdaFunction{emap} for all valid
higher-order functors, which would allows the definition \AgdaFunction{>>=}.
Both representations share another problem, the produced type constructor is not
necessarily strictly positive.
This is a necessary requirement to define recursive, effectful data structures.

There are multiple ways to fix this problem.
Following the pattern from chapter \ref{chapter:first-order} we could replace
the returned functor with normal \AgdaDatatype{Container}.
This option is the most expressive, but also quite complex.
Furthermore, for most effects this level of control over syntax is not needed.
In most cases the argument \AgdaArgument{A} is only used directly i.e. the
Haskell functor contains \texttt{a} only as \texttt{m a}.

Working under this assumption, it is possible to replace the returned functor
with a value of type \AgdaDatatype{Maybe}\AgdaSpace{}\AgdaDatatype{Set} and
replace \AgdaInductiveConstructor{nothing} with \AgdaArgument{A} in the
container extension.
This also guaranties strict positivity for \AgdaArgument{A}.
Furthermore, it allows a generic definition of \AgdaFunction{>>=}, because it is
possible to pattern match on the result of \AgdaFunction{Ctx} and therefore
differentiate between container extension which do or do not contain
\AgdaArgument{A}\footnote{An example implementation can be found in the
  repository.}.
 
\textcite{bunkenburg2019modeling} fixed this problem by switching to version of
a bi-container.
A bi-container has two position types for each shape.
Its extension is a bifunctor, which is strictly positive in both arguments.
Bunkenburg extended the usual bi-functor to an indexed bi-functor by adding a
context, similar to the above definition, to one of the positions.
The definition of an indexed bi-container and its extension is given below.

\begin{code}
record Effect : Set₂ where
  constructor _◁_+_/_
  field
    Shape : Set₁
    Pos : Shape → Set
    PosX : Shape → Set
    Ctx : ∀ s → PosX s → Set
open Effect

⟦_⟧ : Effect → (Set → Set₁) → Set → Set₁
⟦ S ◁ P + PX / C ⟧ F A = Σ[ s ∈ S ] (((p : P s) → F A) × ((p : PX s) → F (C s p)))
\end{code}
An indexed bi-container has two sets of positions for each shape.
Its extension consists of a shape and two position functions, one for each set
of positions.
In the above definition, the second set of positions is augmented with a context
function, identical to the second indexed container definition.
In Agda this definition is recognized as strictly positive in \AgdaArgument{A}.
The analogous definition in Bunkeburg's Coq
implementation is not~\cite{bunkenburg2019modeling}.
 
Ultimately the choice of representation for the functor does not matter, because
all approaches based on storing a type directly encounter the problem described
in section \ref{higher-order:eff-data-ext-types}.
Going forward we will use Bunkeburg's indexed bi-container for examples, because
it allows us to continue where he left of and it is the easiest to work with.
As a side note, some operations with more complex syntax, like \texttt{pass :: m
(a, w -> w) -> m a} and \texttt{listen :: m a -> m (a, w)} for the
\texttt{Writer} monad cannot be implemented with this representation.
 
Using our choice of functor representation we can define the \AgdaDatatype{Prog}
monad for higher order syntax as described by
\textcite{DBLP:conf/haskell/WuSH14}.
It is similar to the free monad in the first order case, except that the functor
has access to the type parameter an the type constructor, not just the
combined type.

\begin{code}
⟦_⟧′ : Effect → (Set₁ → Set₁) → Set₁ → Set₁
⟦ S ◁ P + PX / C ⟧′ F A = Σ[ s ∈ S ]
  (((p : P s) → F A) × ((p : PX s) → F (Lift _ $ C s p)))

data Progᵂ (C : Effect) (A : Set₁) : Set₁ where
  pure    : A → Progᵂ C A
  impure  : ⟦ C ⟧′ (Progᵂ C) A → Progᵂ C A
\end{code}
% TODO: explain alternative container extension
Notice that due to the potentially captured type in the \AgdaField{Shape} is an
element of \AgdaDatatype{Set₁}.
Therefore, \AgdaDatatype{Progᵂ} is also an element of \AgdaDatatype{Set₁}.
Because \AgdaDatatype{Progᵂ} is an element of \AgdaDatatype{Set₁} we can also
increase the universe level for \AgdaArgument{A} to $1$, which is needed to
define effectful data structures.
Unfortunately, because the universe level of the captured type is smaller than
\AgdaDatatype{Progᵂ}'s it is not possible to work with effectful data as in
Haskell.
Section \ref{higher-order:eff-data-ext-types} contains a detailed explanation of
the problem.

\begin{code}[hide]
private
  variable
    E E′ : Effect
    effs effs′ effs″ : List Effect
\end{code}

\subsection{Effectful Data and Existential Types}
\label{higher-order:eff-data-ext-types}

A central problem with this approach is that it cannot model deep effects
without involving variable levels.
Consider the the following definition of an effectful list.
Although it is valid, in contrast to the Coq version, it cannot be used as
expected with \AgdaDatatype{Progᵂ}

\begin{code}
data Listᴹ (E : Effect) (A : Set₁) : Set₁ where
  nil   : Listᴹ E A
  cons  : Progᵂ E A → Progᵂ E (Listᴹ E A) → Listᴹ E A
\end{code}
\AgdaDatatype{Listᴹ}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A} is
an element of \AgdaDatatype{Set₁}, because it stores elements of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{X},
which is an element of \AgdaDatatype{Set₁}.
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{X} is
an element of \AgdaDatatype{Set₁}, because it holds values of the container
extension i.e. elements of the \AgdaField{Shape} type, which is an element
\AgdaDatatype{Set₁}, because it has to store the result type of the
subcomputation \AgdaArgument{X}.
Therefore,
\AgdaDatatype{Listᴹ}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A} is
to large to be stored as result type of a subcomputation i.e. it is not possible
to call a scoped operation (such as \AgdaFunction{share}) on an effectful data
structure.

More generally speaking, let us fix the universe level of the result type $X$ of
the subcomputation $\ell_X = l$.
The type is stored in the \AgdaField{Shape}, therefore the universe level of the
\AgdaField{Shape} type is given by $\ell_S = l + 1$.
Because the \AgdaDatatype{Prog} stores an element of the \AgdaField{Shape} its
level is given by $\ell_P = \ell_S$.
Effectful data structures live in the same universe as \AgdaDatatype{Prog}, but
are simultaneously required to be stored in the subcomputation.
We obtain the contradictory requirements $\ell_E = \ell_P = \ell_S = l + 1$ and
$\ell_E  \leqslant l$.

Holding on to the idea of storing types in the \AgdaField{Shape}, the only way to
fix this problem is to let all levels vary as needed.
Calling a scoped operation on an effectful data structure containing
computations with level $\ell$ produces a computation on level $\ell + 1$.
This leads to different levels across the program, which are difficult to unify.
Furthermore, when mapping a scoped operation over a recursive data structure
(e.g. \AgdaFunction{share}) the increase in the universe level depends on the
depth of the structure.
Both of these phenomena are hard to deal with and in a complex program
potentially unsolvable.


\subsection{Indexing and Integrating Data}
\label{higher-order:fixes}

To solve the problem from section \ref{higher-order:eff-data-ext-types} we
explored two approaches.
Both of them seemed promising, but turned out to be rather complex.

\paragraph{Indexing}
One could try solving the problem of increasing universe levels by indexing the
program over a typing context.
The level of the index is independent from the level of the structure, therefore
the chain of reasoning from section \ref{higher-order:eff-data-ext-types} does
not apply.
The typing context needs to have the same structure as the program.
This is possible by reusing the arbitrary branching mechanism, known from the
free monad.

A central problem with this approach is that every call of \AgdaFunction{>>=}
changes the structure of the program and therefore the context.
These changes now have to be reflected on the type level, because the typing
context has to reflect the programs shape.
If \AgdaFunction{>>=} substitutes leaves differently based on their stored
values, the changes to the context are not simple substitutions, but depend on
the stored value.
As with increasing universe levels, this complications are increasingly hard to
deal with and are hard to hide from the user of the library.

\paragraph{Integrating Data and Computations}
All of the above modellings of the problem ignore a central fact.
The problem arises, because we cannot store arbitrary values from
\AgdaDatatype{Set₁} in \AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}, but
we do not want to store \textit{arbitrary} values.
The only too large types we want to store are data structures from
\AgdaDatatype{Set} with interleaved
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layers.
Conceptually, the effectful values stored in the leafs simply extend the
computation tree.

By representing data structures using a small type and creating the actual
structure, described by the effectful data structure, using a new
\AgdaDatatype{Prog} constructor, it could be possible to avoid the size issues.
We tried implementing this idea, but failed when trying to represent generic
structures.
Furthermore, working with data described this way is intuitive.


\section{Limited Implementation}
\label{higher-order:limited-impl}

Translating \textcite{DBLP:conf/haskell/WuSH14} approach without major changes
to Agda makes working  with deep effects difficult.
However, it can still be used to implement scoped effects without deep effects.
For completeness the following section will show key points of a simplified
implementation using this approach.
To write concise code we will work with Bunkenburg's indexed bi-containers,
because they model effects with a simple continuation accurately.
In a more complex implementation, where more control over the type of the
continuation is needed, a container with a \AgdaField{Ctx} for \AgdaArgument{A}
might be needed\footnote{To guarantied strict positivity one of the solutions
  mentioned in section \ref{higher-order:container} is needed.}.

First we port over the infrastructure for modular effects.
The coporduct carries over seamlessly.
We combine the position functions pairwise and handle the \AgdaFunction{Ctx}
functions using the coproduct mediator.

\begin{code}
_⊕_ : Effect → Effect → Effect
(S₁ ◁ P₁ + PX₁ / C₁) ⊕ (S₂ ◁ P₂ + PX₂ / C₂) =
  (S₁ ⊎ S₂) ◁ [ P₁ , P₂ ] + [ PX₁ , PX₂ ] / [ C₁ , C₂ ]
\end{code}
To easily work in the higher order setting we adapt the \AgdaDatatype{Prog}
data type similarly to \AgdaDatatype{Free} monad from chapter
\ref{chapter:first-order} i.e. we parameterize over a list of effects and add a
\AgdaDatatype{Size} parameter.
To avoid excessive use of universe levels and to avoid the \texttt{--cumulativity}
flag we work with a version of \AgdaDatatype{Prog} which takes a type parameter
from \AgdaDatatype{Set}\footnote{To be monad this parameter has to be an element
  of \AgdaDatatype{Set₁}. Such a structure is sometimes known as a \textit{relative
  monad}, because we can still define a \AgdaFunction{>>=} for which the usual
  laws hold. Adapting this structure to a normal monad is possible, but involves
  more level annotations and it is easier in a universe polymorphic setting.}.
We try to avoid the flag in this exemplary implementation, because it weakens
type inference, forcing us to write more implicit values explicitly.

\begin{code}[hide]
Void : Effect
Void = Lift _ ⊥ ◁ (λ()) + (λ()) / λ()

sum : List Effect → Effect
sum = foldr _⊕_ Void

infix 4 _∈_
data _∈_ {ℓ : Level} {A : Set ℓ} (x : A) : List A → Set ℓ where
  instance
    here   : ∀ {xs} → x ∈ x ∷ xs
    there  : ∀ {y xs} → ⦃ _∈_ {ℓ} x xs ⦄ → x ∈ y ∷ xs
\end{code}
\begin{code}
data Prog (effs : List Effect) (A : Set) : {Size} → Set₁ where
  pure    : A → Prog effs A {i}
  impure  : ⟦ sum effs ⟧ (λ X → Prog effs X {i}) A → Prog effs A {↑ i}
\end{code}
To implement \AgdaFunction{>>=} we define the \AgdaFunction{emap} function.
The function has the same signature as the one by
\textcite{DBLP:conf/haskell/WuSH14}.
In contrast to the implementation by \textcite{DBLP:conf/haskell/WuSH14} the
function can be defined generically for all effects, because the Bi-Container
representation is more restrictive than the their representation in Haskell.
Switching to a Bi-Container with a \AgdaField{Ctx} for the first position
function, which returns a \AgdaDatatype{Container}, preserves this general
definition. % :/

\begin{code}
emap : (F A → F B) → ⟦ E ⟧ F A → ⟦ E ⟧ F B
emap f p = π₁ p , f ∘ π₁ (π₂ p) , π₂ (π₂ p)
{-# INLINE emap #-}

_>>=_ : Prog effs A → (A → Prog effs B) → Prog effs B
pure x    >>= k = k x
impure x  >>= k = impure (emap {F = λ X → Prog _ X} (_>>= k) x)
\end{code}
\begin{code}[hide]
_>>_ : Prog effs A → Prog effs B → Prog effs B
ma >> mb = ma >>= λ _ → mb

_<*>_ : Prog effs (A → B) → Prog effs A → Prog effs B
mf <*> ma = mf >>= λ f → ma >>= λ a → pure (f a)

run : Prog [] A → A
run (pure x) = x
\end{code}
The definition for \AgdaFunction{>>=} is identical to the one in Haskell.
Using the \AgdaKeyword{INLINE} pragma, as explained in section \ref{container},
we can define \AgdaFunction{emap} separately without obscuring the termination.

The infrastructure from chapter carries over with
minimal changes.
We reuse the \AgdaDatatype{\_∈\_} proposition from chapter
\ref{chapter:first-order}.
The \AgdaFunction{inj} and \AgdaFunction{op} functions have to be modified
slightly for the new program type.

\begin{code}
inj : E ∈ effs → ⟦ E ⟧ F A → ⟦ sum effs ⟧ F A
inj here           (s , κ) = inj₁ s , κ
inj {F = F} (there ⦃ p ⦄)  prog with inj {F = F} p prog
... | s , κ = inj₂ s , κ

op : ⦃ E ∈ effs ⦄ → ⟦ E ⟧ (λ X → Prog effs X) A → Prog effs A
op ⦃ p ⦄ = impure ∘ inj {F = λ X → Prog _ X} p
\end{code}
Usually, when an effect is handled the value type is lifted in a context,
represented by a functor (e.g. \AgdaDatatype{List} for \AgdaDatatype{Nondet}).

Following the approach by \citeauthor{DBLP:conf/haskell/WuSH14} we will define a
type class \AgdaDatatype{Syntax}, which, given a handler, allows evaluating a
computation in a context to a new computation producing values in the context.
To define such a type class we first have to define a context.
The normal definition of a functor does not suffice, because it lifts all type
to the same \AgdaDatatype{Setₙ}.
This is problematic, because scoped operations can only capture elements of
\AgdaDatatype{Set}, while computations are elements of \AgdaDatatype{Set₁}.
Therefore values and computations in context have different universe levels, but
during the evaluating we have to convert between the two. 
Even with \texttt{--cumulativity} this behavior is not handled automatically by
Agda\footnote{\url{https://agda.readthedocs.io/en/v2.6.1.1/language/cumulativity.html\#limitations}}.

To simulate the above behavior we define the \AgdaDatatype{Context} type class.
A context is essentially a functor which respects the universes structure.
Given a type from \AgdaDatatype{Setₙ} it lifts it to another type in the same
\AgdaDatatype{Setₙ}.
Furthermore, given a function between two data types in different universes it
lifts the function to a function between the lifted types i.e. between
universes.
An instances should satisfy the functors laws, even though they are not enforced
here.
Notice that \AgdaDatatype{Context} works with arbitrary \AgdaDatatype{Level}s
$\ell$ and therefore is an element of \AgdaDatatype{Setω}.

\begin{code}
record Context (F : ∀ {ℓ} → Set ℓ → Set ℓ) : Setω where
  field _<$>_ : ∀ {a b} {A : Set a} {B : Set b} → (A → B) → F A → F B
  _<$_ : ∀ {a b} {A : Set a} {B : Set b} → A → F B → F A
  a <$ mb = const a <$> mb
open Context ⦃...⦄
\end{code}
With the context in place we define the \AgdaDatatype{Syntax} type class by
\citeauthor{DBLP:conf/haskell/WuSH14}.
By generalizing to higher order abstract syntax it is possible to represent
computations in scope and continuations explicitly.
The order in which they are evaluated and therefore how an evaluation context
should be moved through the computation is a semantic question.
The type class explains how an arbitrary handler can be thread through an
effects syntax.
The first argument is the initial context.
Using \AgdaFunction{<\$} it is possible to move an arbitrary value or
computation into the context.
The second argument is a handler as defined by
\citeauthor{DBLP:conf/haskell/WuSH14}.
The handler takes a computation in a context and evaluates it.
The result computation has a different effect stack, usually it is the tail of
the given stack.
By partially evaluating the computation the context was moved through the
computation.
As a result the values are now lifted into the resulting context.
Using the initial context and the handler, the type class explains how an
arbitrary operation from its signature is evaluated.

Notice that the given operations contain computations of an arbitrary size.
Furthermore, the given handler works on computations of the same size.
This will be important in section \ref{higher-order:limited-impl} when we define
handlers, which pass them self to \AgdaFunction{handle}.

\begin{code}
record Syntax (E : Effect) : Setω where
  field handle : ⦃ Context C ⦄ → C ⊤ →
          (∀ {X} → C (Prog effs′ X {i}) → Prog effs″ (C X)) →
          ⟦ E ⟧ (λ X → Prog effs′ X {i}) A → ⟦ E ⟧ (λ X → Prog effs″ X) (C A)
open Syntax ⦃...⦄
\end{code}
To finish the basic infrastructure we define two \AgdaDatatype{Syntax}
instances.
The instance for the empty signature \AgdaDatatype{Void} is trivial, because the
type of container extensions is empty.
Combined signatures are handled by inspecting the value, calling the
\AgdaFunction{handle} for one of the given signatures and injecting the result
in the combined signature.

\begin{code}
instance
  Void-Syntax : Syntax Void
  Syntax.handle Void-Syntax _ _ ()

  ⊕-syntax : ⦃ Syntax E ⦄ → ⦃ Syntax E′ ⦄ → Syntax (E ⊕ E′)
  Syntax.handle ⊕-syntax ctx hdl (inj₁ s , κ , σ) with handle ctx hdl (s , κ , σ)
  ... | s′ , κ′ , σ′ = (inj₁ s′) , κ′ , σ′
  Syntax.handle ⊕-syntax ctx hdl (inj₂ s , κ , σ) with handle ctx hdl (s , κ , σ)
  ... | s′ , κ′ , σ′ = (inj₂ s′) , κ′ , σ′
\end{code}


\subsection{Exceptions}
\label{higher-order:exceptions}

An an example for an effect in the higher order setting we define exceptions.
Exceptions support two operations, the usual algebraic operation

\paragraph{Syntax}
The two operations are the equivalent of the Haskell definition from section
\ref{higher-order:syntax}.
\AgdaFunction{throw} as well as the scoped operation \AgdaFunction{catch}.
\AgdaDatatype{throw} takes the thrown exception as an additional parameter an
has no continuations, because it terminates the computation.
\AgdaDatatype{catch}'s \AgdaField{Shape} stores the result type of the
computations in scope.

\begin{code}
data Excˢ (E : Set) : Set₁ where
  throwˢ  : (e : E) → Excˢ E
  catchˢ  : (X : Set) → Excˢ E
\end{code}
We use Bunkenburg's indexed Bi-Container.
The extension of the container is equipped with two positions functions, one for
computations resulting in
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}
and one for computations in scope i.e. such resulting in computations of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{Y}
where \AgdaArgument{Y} is defined by the context.
Let us first consider the computations in scope.

\begin{code}
data ExcCatchᴾ (E X : Set) : Set where
  mainᵖ    : ExcCatchᴾ E X
  handleᵖ  : (e : E) → ExcCatchᴾ E X

Excᵖˣ : ∀ E → Excˢ E → Set
Excᵖˣ E (throwˢ e)  = ⊥
Excᵖˣ E (catchˢ X)  = ExcCatchᴾ E X

Excᶜ : ∀ E s → Excᵖˣ E s → Set
Excᶜ E (catchˢ X) mainᵖ        = X
Excᶜ E (catchˢ X) (handleᵖ e)  = X
\end{code}
\AgdaFunction{throw} has no computations in scope and therefore no positions.
\AgdaFunction{catch}'s positions are given by \AgdaDatatype{ExcCatchᴾ}.
The operation has two kinds of continuations in scope.
The first single continuation is given by \AgdaInductiveConstructor{mainᵖ}, the
program in scope whose exceptions should be caught.
\AgdaInductiveConstructor{handleᵖ} provides a continuation for each error i.e.
corresponds to the exception handler.
Both computations result in a value of type \AgdaArgument{X}, which is expressed
using \AgdaFunction{Excᶜ}

Next we define the positions for the effects continuation i.e the computation
producing values of type \AgdaArgument{A}.

\begin{code}
Excᵖ : ∀ E → Excˢ E → Set
Excᵖ E (throwˢ e)  = ⊥
Excᵖ E (catchˢ X)  = X
\end{code}
Again, \AgdaFunction{throw} has no continuations, because it produces no
results.
\AgdaFunction{catch} provides a continuation which processes the result of the
computations in scope i.e. it provides a continuation for each value of
\AgdaArgument{X}.

Using the above definitions we define the \AgdaDatatype{Exc} effect.
Furthermore, we introduce pattern synonyms to easily pattern match on values of
the container extension in the handler.
\begin{code}
Exc : Set → Effect
Exc E = Excˢ E ◁ Excᵖ E + Excᵖˣ E / Excᶜ E

pattern Throw e      = impure (inj₁ (throwˢ e)  , _ ,  _)
pattern Catch κ σ    = impure (inj₁ (catchˢ _)  , κ ,  σ)
pattern Other s κ σ  = impure (inj₂ s           , κ ,  σ)
\end{code}
Lastly we define smart constructors for the operations.
\AgdaFunction{throw} has no continuations.
\AgdaFunction{catch} captures the program as well as the exception handler in
scope, therefore they are returned by \AgdaArgument{σ}.
The effects continuation \AgdaArgument{κ} is initially given by pure.
It is later extended using \AgdaFunction{>>=} this is analogous to the generic
operations in the first order approach.

\begin{code}[hide]
infix 0 _catch_
\end{code}
\begin{code}
throw : ⦃ Exc B ∈ effs ⦄ → (e : B) → Prog effs A
throw e = op (throwˢ e , (λ()) , λ())

_catch_ : ⦃ Exc B ∈ effs ⦄ → Prog effs A → (B → Prog effs A) → Prog effs A
p catch h = op $ catchˢ _ , pure , λ{ mainᵖ → p ; (handleᵖ e) → h e }
\end{code}

\paragraph{Handler}
Before we implement the handler we have to provide a \AgdaDatatype{Context}
instance for \AgdaArgument{E}\AgdaSpace{}\AgdaDatatype{⊎\_} to use
\AgdaFunction{handle} to traverse \AgdaInductiveConstructor{Other} operations.
The instance is nearly identical to the functor instance, except that the newly
constructed values maybe are element of another \AgdaDatatype{Set}.

\begin{AgdaAlign}
\begin{code}
instance
  _⊎-Context : ∀ {E : Set} → Context (E ⊎_)
  Context._<$>_ _⊎-Context f (inj₁ e) = inj₁ e
  Context._<$>_ _⊎-Context f (inj₂ x) = inj₂ (f x)
\end{code}
As explained above, the \AgdaDatatype{Syntax} instance is needed to thread the
handler  through the syntax of other effects i.e. the instance for
\AgdaDatatype{Exc} is not needed for the \AgdaDatatype{Exc} handler.
We still define a \AgdaDatatype{Syntax} instance for \AgdaDatatype{Exc} now to
explain the usual structure.

\begin{code}
  Exc-Syntax : ∀ {E} → Syntax (Exc E)
  Syntax.handle Exc-Syntax          _    _    (throwˢ e  , _  , _  ) = throwˢ e , (λ()) , λ()
  Syntax.handle Exc-Syntax {C = C}  ctx  hdl  (catchˢ X  , κ  , σ  ) = catchˢ (C X) ,
    (λ x         → hdl (κ              <$>  x    )) , λ where
    mainᵖ        → hdl (σ mainᵖ        <$   ctx  )
    (handleᵖ e)  → hdl (σ (handleᵖ e)  <$   ctx  )
\end{code}
\end{AgdaAlign}
The case for \AgdaInductiveConstructor{throwˢ} is trivial, because the operation
has no continuations, one which to evaluate the handler.
The case for \AgdaInductiveConstructor{catchˢ} is more complex.

The idea behind the \AgdaDatatype{Syntax} type class is to thread the handler
through the computation i.e. evaluate it on every subtree.
The given handler \AgdaArgument{hdl} is slightly different from the final
handler in that it only accepts computations inside its context.
This is needed to thread the handlers current state through the computation.
The continuation for the effects final continuation (the one producing a value
of the actual result type \AgdaArgument{A}) takes an argument of type
\AgdaArgument{C X}.
By mapping \AgdaArgument{κ} over the given \AgdaArgument{x} the continuation is
injected in the context of the argument \AgdaArgument{x}.
This make sense, because the given value is either the result of the sucessfull
captured computation or the handler.
The rest of the computation should continue where these compuations left of.
For example, in case of \AgdaDatatype{Nondet}, \AgdaArgument{κ} would continue
on each result of the program in scope, because \AgdaFunction{<\$>} applies the
given function simply to each element of the list.

Next we will look at the computations in scope i.e. the computations stored by
\AgdaArgument{σ}.
As in chapter \ref{chapter:first-order} and explained in
\ref{preliminaries:scoped-effects}, the handler should be evaluated on the
computation in scope in isolation i.e. not reuse the previous state.
In the first order case this was accomplished by calling the handler again when
finding an opening scope delimiter.
To call the handler the computations, given by the functions \AgdaArgument{κ}
and \AgdaArgument{σ}, have to be inject into a context.
In case of \AgdaArgument{κ} we were given a context, now we have to use the
given context.
The given value \AgdaArgument{cxt} holds a value of type \AgdaDatatype{⊤} i.e.
no information just handler state.
\AgdaArgument{cxt} should be the initial handler context or state for the
handler.
Using \AgdaFunction{<\$} we can inject any computation into it.
Injecting a computation into \AgdaArgument{ctx} and calling \AgdaArgument{hdl}
should be the same as calling the actual handler for the effect on the
computation.

The cases for the three computations are identical to the ones presented by
\citeauthor{DBLP:conf/haskell/WuSH14}.
After evaluating the handler on the sub-trees, values are lifted into the
context, therefore the captured intermediate result type changes.
In Agda we have to manage the type explicitly.
In contrast to the Haskell implementation by
\citeauthor{DBLP:conf/haskell/WuSH14} we have to explicitly change the captured
type.
Using the curly brackets we access the hidden type constructor \AgdaArgument{C}
for the context and simply evaluate it on the given type.

Lastly we define the handler for \AgdaDatatype{Exc}.
Notice that the handler takes a computation of an arbitrary size
\AgdaArgument{i}.
This is needed to prove termination, because the handler itself is threaded
through the \AgdaInductiveConstructor{Other} operations using
\AgdaFunction{handle}.
To use handle we require a \AgdaDatatype{Syntax} instance for the rest of the
effect stack.
The cases for \AgdaInductiveConstructor{pure} and
\AgdaInductiveConstructor{Throw} are trivial.

\begin{code}
runExc : ⦃ Syntax (sum effs) ⦄ → Prog (Exc B ∷ effs) A {i} → Prog effs (B ⊎ A)
runExc (pure x)     = pure (inj₂ x)
runExc (Throw e)    = pure (inj₁ e)
\end{code}
To handle \AgdaInductiveConstructor{Catch} we first evaluate the operation in
scope by calling \AgdaFunction{runExc} on the computation in the
\AgdaInductiveConstructor{mainᵖ} position.
Using \AgdaFunction{>>=} we can inspect the result and either call the rest of
the computation \AgdaArgument{κ} with the result or the exception handler using
\AgdaInductiveConstructor{handleᵖ}.
In the latter case we again inspect the result and in case of a value also
continue with \AgdaArgument{κ}.
\begin{code}
runExc (Catch κ σ)  = runExc (σ mainᵖ) >>= λ where
  (inj₁ e) → runExc (σ (handleᵖ e)) >>= λ where
    (inj₁ e) → pure (inj₁ e)
    (inj₂ x) → runExc (κ x)
  (inj₂ x) → runExc (κ x)
\end{code}
Lastly we handle \AgdaInductiveConstructor{Other} operations.
As in chapter \ref{chapter:first-order} we reconstruct the operation using
\AgdaInductiveConstructor{impure}.
Moving the handler along now requires us to use \AgdaFunction{handle}.
We call \AgdaFunction{handle} on the given value of the container extension,
constructed using \AgdaArgument{s}, \AgdaArgument{κ} and \AgdaArgument{σ}.
Notice that \AgdaInductiveConstructor{Other} hides the
\AgdaInductiveConstructor{inj₂}, therefore the newly constructed container
extension has a different type.
It is an element of the signature without the exception syntax.
\AgdaFunction{handle} requires two additional arguments, the initial context as
well has the handler.
The initial context is given by
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}\AgdaInductiveConstructor{tt} i.e. a
successful result of type \AgdaDatatype{⊤}.
The handler has to evaluate \AgdaDatatype{Exc} syntax for a computation in the
context.
We handle the two cases using \AgdaFunction{[\_,\_]}.
If the argument is already an error we simply produce a
\AgdaInductiveConstructor{pure} calculation which produces the error.
Otherwise it is a computation, which we can evaluate using \AgdaFunction{runExc}.
Notice that the initial context always leads to the second case.
\begin{code}
runExc (Other s κ σ) = impure (handle (inj₂ tt) [ (λ x → pure (inj₁ x)) , runExc ] (s , κ , σ))
\end{code}
Even tough we pass \AgdaFunction{runExc} to \AgdaFunction{handle}, Agda accepts this
definition as terminating.
Agda can prove termination, because the argument is of an arbitrary size
\AgdaArgument{i}, therefore the values produced by \AgdaArgument{κ} and
\AgdaArgument{σ} have a smaller size.
Note that in the definition of \AgdaFunction{handle} the size of the handler
argument is the same as the size of the last argument i.e. the operation, which
is handled.
Therefore, the argument passed to the coproduct mediator, which calls
\AgdaFunction{runExc}, is smaller than the currently handled value.

\paragraph{Example}
Using the \AgdaDatatype{Exc} effect we can define simple programs, which
\AgdaFunction{throw} and \AgdaFunction{catch} exceptions.
The first function simply raises an exception.
\begin{code}
testExc : ⦃ Exc String ∈ effs ⦄ → Prog effs ℕ
testExc = pure 1 >> throw "Foo"
\end{code}
As expected, evaluating it yields the error message.
\begin{center}
\begin{code}[inline,hide]
runTestExc :
\end{code}
\begin{code}[inline]
 run (runExc testExc) ≡ inj₁ "Foo"
\end{code}
\begin{code}[inline,hide]
runTestExc = refl
\end{code}
\end{center}
The second function calls the first one, but catches the exception, returning an
alternative result.
\begin{code}
catchTestExc : ⦃ Exc String ∈ effs ⦄ → Prog effs ℕ
catchTestExc = testExc catch λ _ → pure 42
\end{code}
Evaluating the second function yields the value returned by the exception
handler.
\begin{center}
\begin{code}[inline,hide]
runCatchTestExc :
\end{code}
\begin{code}[inline]
 run (runExc catchTestExc) ≡ inj₂ 42
\end{code}
\begin{code}[inline,hide]
runCatchTestExc = refl
\end{code}
\end{center}


\subsection{Lifting First Order Syntax}
\label{higher-order:lifting}

\textcite{DBLP:conf/haskell/WuSH14} present a construction for lifting first
order syntax to the higher order setting.
A similar construction is possible with container representations.
In this section we present the corresponding construction and use it to
lift nondeterminism syntax into the higher order setting. 

Given the two fields of a normal container we construct an indexed bi-container.
The shapes and positions for \AgdaArgument{A} correspond exactly to the first
two arguments for the indexed bi-container.
The second postion type and the context are precisely the generalization from
the first-order to the higher-order setting.
Therefore, we simply use \AgdaDatatype{⊥} to ignore them.

We did not use the cumulativitiy flag to simplifiy this examplary implementation.
This simplified the earlier implementation, but forces us now to do some manual
lifting.
The \AgdaDatatype{Lift} data type is element of an arbitrary universe and stores
a value of an arbitrary type from a smaller universe.
Using \AgdaDatatype{Lift} we can pass the given shape type to the constructor.
To apply the position function we unwrap the lifted shape.

\begin{code}
_▷_ : (Shape : Set) → (Pos : Shape → Set) → Effect
S ▷ P = Lift _ S ◁ (λ (lift s) → P s) + (λ _ → ⊥) / λ _ ()
\end{code}
As shown by \textcite{DBLP:conf/haskell/WuSH14}, we can define a general
\AgdaDatatype{Syntax} instance for lifted first order syntax.
The second type of positions is empty, therefore we can omitt the definition of
\AgdaArgument{σ}.
Notice that this definition applies to all effects constructed using
\AgdaFunction{▷}.
Therefore, we avoid defining parts of the infrastructure for effects without
scoping operations.

\begin{code}
instance
  ▷-Syntax : ∀ {S P} → Syntax (S ▷ P)
  Syntax.handle ▷-Syntax ctx hdl (s , κ , σ) = s , (λ p → hdl (κ p <$ ctx)) , λ()
\end{code}

\paragraph{Example: Nondet}
Using the above function and \AgdaKeyword{instance} we can lift the
nondeterminism syntax from chapter \ref{chapter:first-order} to the higher-order
setting.

\begin{code}[hide]
data Nondetˢ : Set where ⁇ˢ failˢ : Nondetˢ
\end{code}
\begin{code}
Nondet : Effect
Nondet = Nondetˢ ▷ λ where failˢ → ⊥ ; ⁇ˢ → Bool

pattern Fail      = impure (inj₁ (lift failˢ)  , _ , _)
pattern Choice κ  = impure (inj₁ (lift ⁇ˢ)     , κ , _)
\end{code}
We still have to define a \AgdaDatatype{Context} instance and a custom handler
for \AgdaDatatype{Nondet}, because we have to define the interaction with other
higher order syntax.
Again, the \AgdaDatatype{Context} instance corresponds to the normal functor
instance.

\begin{code}
instance
  List-Context : Context List
  Context._<$>_ List-Context f []        = []
  Context._<$>_ List-Context f (x ∷ xs)  = f x ∷ (f <$> xs)
\end{code}
The first three cases of the handler are identical to the implementation in
section \ref{nondeterminism}.
The interesting new case is the one for \AgdaInductiveConstructor{Other} syntax.
We must use use \AgdaFunction{handle} to traverse the arbitrary operation.
Analougous to exceptions we evaluate \AgdaFunction{handle} on the reconstructed,
given operation.
The initial context have to be signleton lists, because empty lists would
stop the compatation, while lists with two or more elements would duplicate
parts of the program.

\AgdaFunction{hdl} has to map from a \AgdaDatatype{List} of compuations with
\AgdaDatatype{Nondet} syntax to a compuation without \AgdaDatatype{Nondet}
syntax and a \AgdaDatatype{List} as value type.
Consider the \AgdaDatatype{Syntax} instance for \AgdaDatatype{Exc}, given in
section \ref{higher-order:exceptions}.
The two compuations in scope use the inital context i.e. the given list is a
singleton.
The continuation uses \AgdaFunction{<\$>} to apply the rest of the program to
the given results of the compuatation in scope and evaluates them using
\AgdaFunction{hdl}.
Conceptually, the argument of \AgdaFunction{hdl} corresponds to the
computations, which prodce results for each result of some earlier compuatation.
We therefore use the obvious (and usually given) implementation of the
\AgdaFunction{hdl} function i.e. we sequence the computations from left to right
and concat the results.

\begin{code}
runNondet : ⦃ Syntax (sum effs) ⦄ → Prog (Nondet ∷ effs) A {i} → Prog effs (List A)
runNondet (pure x)       = pure (x ∷ [])
runNondet Fail           = pure []
runNondet (Choice κ)     = ⦇ runNondet (κ true) ++ runNondet (κ false) ⦈
runNondet (Other s κ σ)  = impure (handle (tt ∷ []) hdl (s , κ , σ))
  where  hdl : ⦃ Syntax (sum effs) ⦄ →
           List (Prog (Nondet ∷ effs) B {i}) → Prog effs (List B)
         hdl []          = pure []
         hdl (mx ∷ mxs)  = ⦇ runNondet mx ++ hdl mxs ⦈
\end{code}
Notice that the argument of the handler as well as the \AgdaFunction{hdl}
function are of size \AgdaArgument{i} to guaranty termination, following the
pattern explained in section \ref{higher-order:exceptions}.

\begin{code}
_⁇_ : ⦃ Nondet ∈ effs ⦄ → Prog effs A → Prog effs A → Prog effs A
p ⁇ q = op (lift ⁇ˢ , (if_then p else q) , λ())
\end{code}

\paragraph{Ordering of Operations}
It is important to note that the above handler induces unexpected semantics when
combined with certain other effects.
Interpreting \AgdaDatatype{Nondet} syntax yields the results in depth first
ordering.

If a part of a nondeterministic computation is captured in a scope the order of
operations changes.
The program in scope is evaluated, yielding its results in depth first ordering.
Afterwards, using \AgdaFunction{hdl} the continuation is evaluated on each
intermediate result and the final results are concatenated.
The results are in the expected depth first order, but the operations not.
The order of operations is introduced by \AgdaFunction{>>=}.
A scoping operation is evaluated by first evaluating the part of the computation
in scope and afterwards the continuations outside the scope.
Therefore the unevaluated operations are now in the same order.
The potential unexpected semantics of this implementation is that introducing a
semantically irrelevant scoping operation (e.g. \texttt{local id}) influences
the ordering of operations of other globally evaluated effects.
This behavior is known, because it also occurs in some Haskell implementations
of scoped
effects\footnote{https://github.com/polysemy-research/polysemy/issues/246}.

Encountering the above behavior is quite uncommon, because the program has to
evaluate a scoping operation globally over a nondeterministic program, while
simultaneously using global operations whose ordering can be observed.
Most effects only provide one of the two.
% Furthermore, evaluating effects globally over \AgdaDatatype{Nondet} inherently
% depends on the ordering of branches, which is precisely what nondeterminism
% abstracts away.
The most common examples are global state to collect results, global writer to
log and global partiality to stop all branches, which do not encounter the above
behavior.
When catching global exceptions over a nondeterministic program the above
behavior seems more reasonable.
More complex semantics (e.g. leaving and reentering the scoped computation) are
conceivable, but not captured by the standard representation of higher order
syntax.


\subsection{Modular Higher Order Effects}

In the last to sections we presented effects in isolation.
Similar to the combined semantics described in
\ref{first-order:combined-effects} we can induced different semantics by
reordering the handlers.
Consider the following program, which chooses between a
\AgdaInductiveConstructor{pure} value and an exception.

\begin{code}
throwNondet : ⦃ Nondet ∈ effs ⦄ → ⦃ Exc ⊤ ∈ effs ⦄ → Prog effs ℕ
throwNondet = pure 42 ⁇ throw tt
\end{code}
Evaluating \AgdaDatatype{Exc} first runs it locally in each branch of the
nondeterministic computation i.e. each branch either returns a result or an
exception. 
\begin{center}
\begin{code}[inline,hide]
localExc : 
\end{code}
\begin{code}[inline]
 run (runNondet (runExc throwNondet)) ≡ inj₂ 42 ∷ inj₁ tt ∷ []
\end{code}
\begin{code}[inline,hide]
localExc = refl
\end{code}
\end{center}
Evaluating \AgdaDatatype{Exc} last evaluates it globally.
Therefore, throwing an exception stops the current, by the \AgdaDatatype{Nondet}
handler induced, ordered evaluation of nondeterministic branches and just
returns the exception.
\begin{center}
\begin{code}[inline,hide]
globalExc : 
\end{code}
\begin{code}[inline]
 run (runExc (runNondet throwNondet)) ≡ inj₁ tt
\end{code}
\begin{code}[inline,hide]
globalExc = refl
\end{code}
\end{center}


\section{Results}

In this chapter, we tired to implement scoped effects using the higher order
syntax approach by \textcite{DBLP:conf/haskell/WuSH14}.
We continued Bunkeburg's~\cite{bunkenburg2019modeling} investigation of this
approach and uncovered a deep seated problem while implementing it in Agda,
which arises due to more restrictive requirements for programs compared to
Haskell.
The problem occurs because of size issues.
When using higher order syntax, computations potentially have to store types and
therefore are larger than the data they hold. 
This prevents scoping operations from capturing other computations, without
switching to a larger type of computations.
In case of deep sharing this leads to a dependence between universe levels and
the depth of data structures.
We discussed two general approaches to avoid increasing universe levels when
working with effectful data, however both of them do not allow a concise
implementation.
Because deep effects are an uncommon requirement, we still presented key points
of the limited implementation.