\begin{code}[hide]
{-# OPTIONS --overlapping-instances #-}

module HigherOrder where

open import Size using (↑_; Size; ∞)
open import Function using (_∘_; id; case_of_; const; _$_)
open import Level using (Level; 0ℓ; Lift; lift; Setω)

open import Data.Empty using (⊥)
open import Data.Product using (Σ-syntax; _×_; _,_) renaming (proj₁ to π₁; proj₂ to π₂)
open import Data.Maybe using (Maybe; fromMaybe; nothing; just)
open import Data.Nat using (ℕ; suc; zero)
open import Data.List using (List; _∷_; []; foldr)
open import Data.Sum using (_⊎_; inj₁; inj₂; [_,_])
open import Data.String using (String)
open import Data.Unit using (⊤; tt)

open import Relation.Unary using (_⊆_)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong; sym; trans)

variable
  A B : Set
  F : Set → Set₁
  i : Size
  C : ∀ {ℓ} → Set ℓ → Set ℓ
\end{code}

To address problems of the first order approach, like mismatched scope
delimiters and explicit control over the continuation,
\citeauthor{DBLP:conf/haskell/WuSH14} introduced a second approach utilizing
higher order abstract syntax~\cite{DBLP:conf/haskell/WuSH14}.
\citeauthor{bunkenburg2019modeling} already tried to implement some scoped
effects using this approach, but failed due to limitations of
Coq~\cite{bunkenburg2019modeling}.

Chapter \ref{chapter:first-order} demonstrated how the first order approach
could be transferred to Agda utilizing container representations for functors
and sized types.
This chapter focuses on the implementation of effects using higher order syntax.
It partially follows Bunkenburg's approach, because the limitation of Coq
described by him does not exist in Agda.
Therefore this chapter focuses on expanding his approach further.
Due to other limitations, needed for the consistency of Agda, this approach
ultimately failed again.
Section \ref{higher-order:limited-impl} presents a limited implementation in
Agda to discusses some implementation details and highlight the occurring
problems.


\section{Higher Order Syntax}
\label{higher-order:syntax}

In the first order approach effects only store possible continuations.
In the higher order approach by Wu et al. scoped effects store possible
continuations as well as the part of the program in their scope.

In the first order approach the functors, which describe the syntax, are applied
to types of the form \texttt{Free F A} i.e. programs consisting of syntax
described by \texttt{Free F}, which produce values of type \texttt{A}.
In the higher order approach these functors are generalized to higher order
functors, that is in Haskell data types of kind \texttt{(* -> *) -> (* -> *)}.
These functors are applied to \texttt{Free F} and \texttt{A} separately.

Because the program type is separated in syntax and result type it is possible
to store programs, which use the same signature but produce values of different
types.
Consider the following definition of the higher order exception syntax as given
by Wu et al.

\begin{minted}{haskell}
    data HExc e m a = Throw e | forall x. Catch (m x) (e -> m x) (x -> m a)
\end{minted}
The \texttt{Catch} operation stores the computation in the scope of the catch
block \texttt{m x}, the handler producing an alternate result in case of an
error \texttt{e -> m x} as well as the continuation \texttt{x -> m a}.
The three programs agree on an arbitrary, but per \texttt{catch} fixed type
\texttt{x} as well as a common signature, defined by \texttt{m}.

Calling \AgdaFunction{>>=} on a higher order term just extends the continuation
i.e. just substitutes the variables in the trees of type \texttt{m a}.
See figure \ref{higher-order:syntax:bind} for an example.
Therefore these operations aren't algebraic but also capture the notation of
scopes.

\begin{figure}
  \begin{tikzpicture}
    \node[] {$\bind$};
  \end{tikzpicture}
  \caption{calling \bind{} on operations with and without scopes (TODO)}
  \label{higher-order:syntax:bind}
\end{figure}


\section{Representing Strictly Positive Higher Order Functors}
\label{higher-order:container}

In Haskell the generalization to higher order syntax is straight forward.
In Agda we again have to find an appropriate representation for functor to
guaranty strict positivity, which leads to the idea of an indexed container as
described by \textcite{DBLP:journals/jfp/AltenkirchGHMM15}
\footnote{Note that this is not the first publication related to indexed
  containers. Papers of the same name, by the same author(s) exist, as well as
  data types, known as ``Interaction Structures'' with essentially the same
  shape.}. 
Indexed containers from the paper as well in the Agda standard library are
defined as follows\footnote{The names of the fields are changed and level
  polymorphism is omitted to highlight differences between the different
  definitions.}.

\begin{code}
record IndexedContainer (I O : Set₁) : Set₁ where
  field
    Shape : O → Set
    Pos : ∀ {o} → Shape o → Set
    Ctx : ∀ {o} → (s : Shape o) → Pos s → I

  ⟦_⟧ : (I → Set) → (O → Set)
  ⟦_⟧ F A = Σ[ s ∈ Shape A ] ((p : Pos s) → F (Ctx s p))
\end{code}
Allowing indicies of arbitrary levels and instantiating \AgdaArgument{I} and
\AgdaArgument{O} with \AgdaDatatype{Set} gives rise to a container extension
of the correct shape.

% \begin{AgdaAlign}
Bunkenburg also tried using indexed container.
The above definition is similar to his first definition of a container
representation for a higher order functor.
His definition is given below.
\begin{code}
record HContainer : Set₂ where
  field
    Shape : Set₁
    Pos : Shape → Set
    Ctx : (s : Shape) → Pos s → Set → Set

  ⟦_⟧ : (Set → Set₁) → (Set → Set₁)
  ⟦_⟧ F A = Σ[ s ∈ Shape ] ((p : Pos s) → F (Ctx s p A))
\end{code}
In the second definition the \AgdaField{Shape} and \AgdaField{Pos} types cannot
depend on the given index i.e. the argument for the returned functor.
Otherwise, both definitions are quite similar.
All stored elements are lifted by the given functor \AgdaArgument{F}.
\AgdaArgument{F}'s argument is generated using \AgdaField{Ctx}.
\AgdaField{Ctx} has access to the chosen shape, accessed position and the 
argument type \AgdaArgument{A}.
Conceptually, \AgdaField{Ctx} is used to choose between the stored
\AgdaArgument{X} and the argument type \AgdaArgument{A} i.e. programs inside or
outside the operations scope.

Bunkenburg noted that it is not possible to define \AgdaFunction{>>=} bind
generically for the definition above~\cite{bunkenburg2019modeling}.
Similar to the Haskell implementation by \textcite{DBLP:conf/haskell/WuSH14} we
could define a type class to implement a \AgdaFunction{emap} for all valid
higher-order functors, which would allows the definition \AgdaFunction{>>=}.
Both representations share another problem, the produced type constructor is not
necessarily strictly positive.
This is a necessary requirement to define recursive, effectful data structures.

There are multiple ways to fix this problem.
Following the pattern from chapter \ref{chapter:first-order} we could replace
the returned functor with normal \AgdaDatatype{Container}.
This option is the most expressive, but also quite complex.
Furthermore, for most effects this level of control over syntax is not needed.
In most effects the argument \AgdaArgument{A} is only used directly i.e. the
Haskell functor contains \texttt{a} only as \texttt{m a}.

Working under this assumption, it is possible to replace the returned functor
with a value of type \AgdaDatatype{Maybe}\AgdaSpace{}\AgdaDatatype{Set} and
replace \AgdaInductiveConstructor{nothing} with \AgdaArgument{A} in the
container extension.
This also guaranties strict positivity for \AgdaArgument{A}.
Furthermore, it allows a generic definition of \AgdaFunction{>>=}, because it is
possible to pattern match on the result of \AgdaFunction{Ctx} and therefore
differentiate between container extension which do or do not contain
\AgdaArgument{A}\footnote{An example implementation can be found in the
  repository.}.
 
Bunkenburg fixed this problem by switching to version of a Bi-Container.
A Bi-Container has two position types for each shape.
Its extension is a Bifunctor, which is strictly positive in both arguments.
The definition of a Bi-Container and its extension is given below.

\begin{code}
record Effect : Set₂ where
  constructor _◁_+_/_
  field
    Shape : Set₁
    Pos : Shape → Set
    PosX : Shape → Set
    Ctx : ∀ s → PosX s → Set
open Effect

⟦_⟧ : Effect → (Set → Set₁) → Set → Set₁
⟦ S ◁ P + PX / C ⟧ F A = Σ[ s ∈ S ] (((p : P s) → F A) × ((p : PX s) → F (C s p)))
\end{code}
A Bi-Container has two sets of positions for each shape.
Its extension consists of a shape and two position functions, one for each set
of positions.
In the above definition, the second set of positions is augmented with a context
function, identical to the second indexed container definition.
In Agda this definition is recognized as strictly positive in \AgdaArgument{A}.
The analogous definition in Bunkeburg's Coq
implementation is not~\cite{bunkenburg2019modeling}.
 
Ultimately the choice of representation for the functor doesn't matter, because
all approaches based on storing a type directly encounter the problem described
in section \ref{higher-order:eff-data-ext-types}.
Going forward we will use Bunkeburg's indexed Bi-Container for examples, because
it allows us to continue where he left of and it is the easiest to work with.
 
Using our choice of functor representation we can define the \AgdaDatatype{Prog}
monad for higher order syntax as described by
\textcite{DBLP:conf/haskell/WuSH14}.
It is similar to the free monad in the first order case, except that the functor
has access to the type parameter an the type constructor, not just the
combined type.

\begin{code}
⟦_⟧′ : Effect → (Set₁ → Set₁) → Set₁ → Set₁
⟦ S ◁ P + PX / C ⟧′ F A = Σ[ s ∈ S ] (((p : P s) → F A) × ((p : PX s) → F (Lift _ $ C s p)))

data Progᵂ (C : Effect) (A : Set₁) : Set₁ where
  pure    : A → Progᵂ C A
  impure  : ⟦ C ⟧′ (Progᵂ C) A → Progᵂ C A
\end{code}
Notice that due to the potentially captured type in the \AgdaField{Shape} is an
element of \AgdaDatatype{Set₁}.
Therefore, \AgdaDatatype{Progᵂ} is also an element of \AgdaDatatype{Set₁}.
Because \AgdaDatatype{Progᵂ} is an element of \AgdaDatatype{Set₁} we can also
increase the universe level for \AgdaArgument{A} to $1$, which is needed to
define effectful data structures.
Unfortunately, because the universe level of the captured type is smaller than
\AgdaDatatype{Progᵂ}'s it is not possible to work with effectful data as in
Haskell.
Section \ref{higher-order:eff-data-ext-types} contains a detailed explanation of
the problem.

\begin{code}[hide]
private
  variable
    E : Effect
    effs effs′ effs″ : List Effect
\end{code}

\section{Effectful Data and Existential Types}
\label{higher-order:eff-data-ext-types}

A central problem with this approach is that it cannot model deep effects
without involving variable levels.
Consider the the following definition of an effectful list.
Although it is valid, in contrast to the Coq version, it cannot be used as
expected with \AgdaDatatype{Progᵂ}

\begin{code}
data Listᴹ (E : Effect) (A : Set₁) : Set₁ where
  nil   : Listᴹ E A
  cons  : Progᵂ E A → Progᵂ E (Listᴹ E A) → Listᴹ E A
\end{code}
\AgdaDatatype{Listᴹ}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A} is
an element of \AgdaDatatype{Set₁}, because it stores elements of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{X},
which is an element of \AgdaDatatype{Set₁}.
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{X} is
an element of \AgdaDatatype{Set₁}, because it holds values of the container
extension i.e. elements of the \AgdaField{Shape} type, which is an element
\AgdaDatatype{Set₁}, because it has to store the result type of the
subcomputation \AgdaArgument{X}.
Therefore,
\AgdaDatatype{Listᴹ}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A} is
to large to be stored as result type of a subcomputation i.e. it is not possible
to call a scoped operation (such as \AgdaFunction{share}) on an effectful data
structure.

More generally speaking, let us fix the universe level of the result type $X$ of
the subcomputation $\ell_X = l$.
The type is stored in the \AgdaField{Shape}, therefore the universe level of the
\AgdaField{Shape} type is given by $\ell_S = l + 1$.
Because the \AgdaDatatype{Prog} stores an element of the \AgdaField{Shape} its
level is given by $\ell_P = \ell_S$.
Effectful data structures live in the same universe as \AgdaDatatype{Prog}, but
are simultaneously required to be stored in the subcomputation.
We obtain the contradictory requirements $\ell_E = \ell_P = \ell_S = l + 1$ and
$\ell_E  \leqslant l$.

Holding on to the idea of storing types in the \AgdaField{Shape}, the only way to
fix this problem is to let all levels vary as needed.
This leads to different levels across the program, which are difficult to unify.
Furthermore, when mapping a scoped operation over a recursive data structure
(e.g. \AgdaFunction{share}) the increase in the universe level depends on the
depth of the structure.
Both of these phenomena are hard to deal with and in a complex program
potentially unsolvable.


\section{The Problem with Indexing}

One could try solving the problem of existential types by indexing the program
over a typing context.
The level of the index is independent from the level of the structure, therefore
the chain of reasoning from section \ref{higher-order:eff-data-ext-types} does
not apply.
The typing context needs to have the same structure as the program.
This is possible by reusing the arbitrary branching mechanism, known from the
free monad.

A central problem with this approach is that every call of \AgdaFunction{>>=}
changes the structure of the program and therefore the context.
These changes now have to be reflected on the type level, because the typing
context has to reflect the programs shape.
If \AgdaFunction{>>=} substitutes leaves differently, the changes to the context
aren't simple substitutions, but depend on the stored value.
As with increasing universe levels, this complications are increasingly hard to
deal with and are hard to hide from the user of the library.


\section{Limited Implementation}
\label{higher-order:limited-impl}

Although, this implementation makes working with deep effects difficult, it can
still implement scoped effects in a setting without them.
For completeness the following section will show key points of a simplified
implementation using this approach.
To write concise code we will work with Bunkenburg's indexed Bi-Containers,
because they model effects with a simple continuation accurately.
In a more complex implementation, where more control over the type of the
continuation is needed, a container with a \AgdaField{Ctx} for \AgdaArgument{A}
might be needed\footnote{To guarantied strict positivity one of the solutions
  mentioned in section \ref{higher-order:container} is needed.}.

First we port over the infrastructure for modular effects.
The coporduct carries over seamlessly.
We combine the position functions pairwise and handle the \AgdaFunction{Ctx}
functions using the coproduct mediator.

\begin{code}
_⊕_ : Effect → Effect → Effect
(S₁ ◁ P₁ + PX₁ / C₁) ⊕ (S₂ ◁ P₂ + PX₂ / C₂) = 
  (S₁ ⊎ S₂) ◁ [ P₁ , P₂ ] + [ PX₁ , PX₂ ] / [ C₁ , C₂ ]
\end{code}
To easily work in the higher order setting we adapt the \AgdaDatatype{Prog}
data type similarly to \AgdaDatatype{Free} monad from chapter
\ref{chapter:first-order} i.e. we parameterize over a list of effects and add a
\AgdaDatatype{Size} parameter.
To avoid excessive use of universe levels and avoid the \texttt{--cumulativity}
flag we work with a version of \AgdaDatatype{Prog} which takes a type parameter
from \AgdaDatatype{Set}\footnote{To be monad this parameter has to be an element
  of \AgdaDatatype{Set₁}. Such a structure is sometimes known as a \textit{relative
  monad}, because we can still define a \AgdaFunction{>>=} for which the usual
  laws hold. Adapting this structure to a normal monad is possible, but involves
  more level annotations and it is easier in a universe polymorphic setting.}.

\begin{code}[hide]
Void : Effect
Void = Lift _ ⊥ ◁ (λ()) + (λ()) / λ()

sum : List Effect → Effect
sum = foldr _⊕_ Void

infix 4 _∈_
data _∈_ {ℓ : Level} {A : Set ℓ} (x : A) : List A → Set ℓ where
  instance
    here   : ∀ {xs} → x ∈ x ∷ xs
    there  : ∀ {y xs} → ⦃ _∈_ {ℓ} x xs ⦄ → x ∈ y ∷ xs
\end{code}
\begin{code}
data Prog (effs : List Effect) (A : Set) : {Size} → Set₁ where
  pure    : A → Prog effs A {i}
  impure  : ⟦ sum effs ⟧ (λ X → Prog effs X {i}) A → Prog effs A {↑ i}
\end{code}
To implement \AgdaFunction{>>=} we define the \AgdaFunction{emap} function.
The function has the same signature as the one by
\textcite{DBLP:conf/haskell/WuSH14}.
In contrast to the implementation by \textcite{DBLP:conf/haskell/WuSH14} the
function can be defined generically for all effects, because the Bi-Container
representation is more restrictive than the their representation in Haskell.
Switching to a Bi-Container with a \AgdaField{Ctx} for the first position
function, which returns a \AgdaDatatype{Container}, preserves this general
definition. % :/

\begin{code}
emap : (F A → F B) → ⟦ E ⟧ F A → ⟦ E ⟧ F B
emap f p = π₁ p , f ∘ π₁ (π₂ p) , π₂ (π₂ p)
{-# INLINE emap #-}

_>>=_ : Prog effs A → (A → Prog effs B) → Prog effs B
pure x    >>= k = k x
impure x  >>= k = impure (emap {F = λ X → Prog _ X} (_>>= k) x)
\end{code}
\begin{code}[hide]
_>>_ : Prog effs A → Prog effs B → Prog effs B
ma >> mb = ma >>= λ _ → mb

run : Prog [] A → A
run (pure x) = x
\end{code}
The definition for \AgdaFunction{>>=} is identical to the one in Haskell.
Using the \AgdaKeyword{INLINE} pragma, as explained in section \ref{container},
we can define \AgdaFunction{emap} separately without obscuring the termination.

The infrastructure from chapter carries over with
minimal changes.
We reuse the \AgdaDatatype{\_∈\_} proposition from chapter
\ref{chapter:first-order}.
The \AgdaFunction{inj} and \AgdaFunction{op} functions have to be modified
slightly for the new program type.

\begin{code}
inj : E ∈ effs → ⟦ E ⟧ F A → ⟦ sum effs ⟧ F A
inj here           (s , κ) = inj₁ s , κ
inj {F = F} (there ⦃ p ⦄)  prog with inj {F = F} p prog
... | s , κ = inj₂ s , κ

op : ⦃ E ∈ effs ⦄ → ⟦ E ⟧ (λ X → Prog effs X) A → Prog effs A
op ⦃ p ⦄ = impure ∘ inj {F = λ X → Prog _ X} p
\end{code}
Usually, when an effect is handled the value type is lifted in a context,
represented by a functor (e.g. \AgdaDatatype{List} for \AgdaDatatype{Nondet}).

Following the approach by \citeauthor{DBLP:conf/haskell/WuSH14} we will define a
type class \AgdaDatatype{Syntax}, which, given a handler, allows evaluating a
computation in a context to a new computation producing values in the context.
To define such a type class we first have to define a context.
The normal definition of a functor does not suffice, because it lifts all type
to the same \AgdaDatatype{Setₙ}.
This is problematic, because scoped operations can only capture elements of
\AgdaDatatype{Set}, while computations are elements of \AgdaDatatype{Set₁}.
Therefore values and computations in context have different universe levels, but
during the evaluating we have to convert between the two. 
Even with \texttt{--cumulativity} this behavior is not handled automatically by
Agda\footnote{\url{https://agda.readthedocs.io/en/v2.6.1.1/language/cumulativity.html\#limitations}}.

To simulate the above behavior we define the \AgdaDatatype{Context} type class.
A context is essentially a functor which respects the universes structure.
Given a type from \AgdaDatatype{Setₙ} it lifts it to another type in the same
\AgdaDatatype{Setₙ}.
Furthermore, given a function between two data types in different universes it
lifts the function to a function between the lifted types i.e. between
universes.
An instances should satisfy the functors laws, even though they are not enforced
here.
Notice that \AgdaDatatype{Context} works with arbitrary \AgdaDatatype{Level}s
$\ell$ and therefore is an element of \AgdaDatatype{Setω}.

\begin{code}
record Context (F : ∀ {ℓ} → Set ℓ → Set ℓ) : Setω where
  field _<$>_ : ∀ {a b} {A : Set a} {B : Set b} → (A → B) → F A → F B
  _<$_ : ∀ {a b} {A : Set a} {B : Set b} → A → F B → F A
  a <$ mb = const a <$> mb
open Context ⦃...⦄
\end{code}
With the context in place we define the \AgdaDatatype{Syntax} type class by
\citeauthor{DBLP:conf/haskell/WuSH14}.
By generalizing to higher order abstract syntax it is possible to represent
computations in scope and continuations explicitly.
The order in which they are evaluated and therefore how an evaluation context
should be moved through the computation is a semantic question.
The type class explains how an arbitrary handler can be thread through an
effects syntax.
The first argument is the initial context.
Using \AgdaFunction{<\$} it is possible to move an arbitrary value or
computation into the context.
The second argument is a handler as defined by
\citeauthor{DBLP:conf/haskell/WuSH14}.
The handler takes a computation in a context and evaluates it.
The result computation has a different effect stack, usually it is the tail of
the given stack.
By partially evaluating the computation the context was moved through the
computation.
As a result the values are now lifted into the resulting context.
Using the initial context and the handler, the type class explains how an
arbitrary operation from its signature is evaluated.

Notice that the given programs have an arbitrary size. -- TODO: explain here or later?

\begin{code}
record Syntax (E : Effect) : Setω where
  field handle : ⦃ Context C ⦄ → C ⊤ →
          (∀ {X} → C (Prog effs′ X {i}) → Prog effs″ (C X)) →
          ⟦ E ⟧ (λ X → Prog effs′ X {i}) A → ⟦ E ⟧ (λ X → Prog effs″ X) (C A)
open Syntax ⦃...⦄
\end{code}

\begin{code}
instance
  Void-Syntax : Syntax Void
  Syntax.handle Void-Syntax _ _ ()
\end{code}

\subsection{Exceptions}

An an example for an effect in the higher order setting we define exceptions.
Exceptions support two operations, the usual algebraic operation

\paragraph{Syntax}
The two operations are the equivalent of the Haskell definition from section
\ref{higher-order:syntax}.
\AgdaFunction{throw} as well as the scoped operation \AgdaFunction{catch}.
\AgdaDatatype{throw} takes the thrown exception as an additional parameter an
has no continuations, because it terminates the computation.
\AgdaDatatype{catch}'s \AgdaField{Shape} stores the result type of the
computations in scope.

\begin{code}
data Excˢ (E : Set) : Set₁ where
  throwˢ  : (e : E) → Excˢ E
  catchˢ  : (X : Set) → Excˢ E
\end{code}
We use Bunkenburg's indexed Bi-Container.
The extension of the container is equipped with two positions functions, one for
computations resulting in
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}
and one for computations in scope i.e. such resulting in computations of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{Y}
where \AgdaArgument{Y} is defined by the context.
Let us first consider the computations in scope.

\begin{code}
data ExcCatchᴾ (E X : Set) : Set where
  mainᵖ    : ExcCatchᴾ E X
  handleᵖ  : (e : E) → ExcCatchᴾ E X

Excᵖˣ : ∀ E → Excˢ E → Set
Excᵖˣ E (throwˢ e)  = ⊥
Excᵖˣ E (catchˢ X)  = ExcCatchᴾ E X

Excᶜ : ∀ E s → Excᵖˣ E s → Set
Excᶜ E (catchˢ X) mainᵖ        = X
Excᶜ E (catchˢ X) (handleᵖ e)  = X
\end{code}
\AgdaFunction{throw} has no computations in scope and therefore no positions.
\AgdaFunction{catch}'s positions are given by \AgdaDatatype{ExcCatchᴾ}.
The operation has two kinds of continuations in scope.
The first single continuation is given by \AgdaInductiveConstructor{mainᵖ}, the
program in scope whose exceptions should be caught.
\AgdaInductiveConstructor{handleᵖ} provides a continuation for each error i.e.
corresponds to the exception handler.
Both computations result in a value of type \AgdaArgument{X}, which is expressed
using \AgdaFunction{Excᶜ}

Next we define the positions for the effects continuation i.e the computation
producing values of type \AgdaArgument{A}.

\begin{code}
Excᵖ : ∀ E → Excˢ E → Set
Excᵖ E (throwˢ e)  = ⊥
Excᵖ E (catchˢ X)  = X
\end{code}
Again, \AgdaFunction{throw} has no continuations, because it produces no
results.
\AgdaFunction{catch} provides a continuation which processes the result of the
computations in scope i.e. it provides a continuation for each value of
\AgdaArgument{X}.

Using the above definitions we define the \AgdaDatatype{Exc} effect.
Furthermore, we introduce pattern synonyms to easily pattern match on values of
the container extension in the handler.
\begin{code}
Exc : Set → Effect
Exc E = Excˢ E ◁ Excᵖ E + Excᵖˣ E / Excᶜ E

pattern Throw e      = impure (inj₁ (throwˢ e)  , _ ,  _)
pattern Catch κ σ    = impure (inj₁ (catchˢ _)  , κ ,  σ)
pattern Other s κ σ  = impure (inj₂ s           , κ ,  σ)
\end{code}
Lastly we define smart constructors for the operations.
\AgdaFunction{throw} has no continuations.
\AgdaFunction{catch} captures the program as well as the exception handler in
scope, therefore they are returned by \AgdaArgument{σ}.
The effects continuation \AgdaArgument{κ} is initially given by pure.
It is later extended using \AgdaFunction{>>=} this is analogous to the generic
operations in the first order approach.

\begin{code}[hide]
infix 0 _catch_
\end{code}
\begin{code}
throw : ⦃ Exc B ∈ effs ⦄ → (e : B) → Prog effs A
throw e = op (throwˢ e , (λ()) , λ())

_catch_ : ⦃ Exc B ∈ effs ⦄ → Prog effs A → (B → Prog effs A) → Prog effs A
p catch h = op $ catchˢ _ , pure , λ{ mainᵖ → p ; (handleᵖ e) → h e }
\end{code}

\paragraph{Handler}
Before we implement the handler we have to provide a \AgdaDatatype{Context}
instance for \AgdaArgument{E}\AgdaSpace{}\AgdaDatatype{⊎\_} to use
\AgdaFunction{handle} to traverse \AgdaInductiveConstructor{Other} operations.
The instance is nearly identical to the functor instance, except that the newly
constructed values maybe are element of another \AgdaDatatype{Set}.

\begin{AgdaAlign}
\begin{code}
instance
  _⊎-Context : ∀ {E : Set} → Context (E ⊎_)
  Context._<$>_ _⊎-Context f (inj₁ e) = inj₁ e
  Context._<$>_ _⊎-Context f (inj₂ x) = inj₂ (f x)
\end{code}
As explained above, the \AgdaDatatype{Syntax} instance is needed to thread the
handler  through the syntax of other effects i.e. the instance for
\AgdaDatatype{Exc} is not needed for the \AgdaDatatype{Exc} handler.
We still define a \AgdaDatatype{Syntax} instance for \AgdaDatatype{Exc} now to
explain the usual structure.

\begin{code}
  Exc-Syntax : ∀ {E} → Syntax (Exc E)
  Syntax.handle Exc-Syntax          _    _    (throwˢ e  , _  , _  ) = throwˢ e , (λ()) , λ()
  Syntax.handle Exc-Syntax {C = C}  ctx  hdl  (catchˢ X  , κ  , σ  ) = catchˢ (C X) ,
    (λ x         → hdl (κ              <$>  x    )) , λ where
    mainᵖ        → hdl (σ mainᵖ        <$   ctx  )
    (handleᵖ e)  → hdl (σ (handleᵖ e)  <$   ctx  )
\end{code}
\end{AgdaAlign}
The case for \AgdaInductiveConstructor{throwˢ} is trivial, because the operation
has no continuations, one which to evaluate the handler.
The case for \AgdaInductiveConstructor{catchˢ} is more complex.

The idea behind the \AgdaDatatype{Syntax} type class is to thread the handler
through the computation i.e. evaluate it on every subtree.
The given handler \AgdaArgument{hdl} is slightly different from the final
handler in that it only accepts computations inside its context.
This is needed to thread the handlers current state through the computation.
The continuation for the effects final continuation (the one producing a value
of the actual result type \AgdaArgument{A}) takes an argument of type
\AgdaArgument{C X}.
By mapping \AgdaArgument{κ} over the given \AgdaArgument{x} the continuation is
injected in the context of the argument \AgdaArgument{x}.
This make sense, because the given value is either the result of the sucessfull
captured computation or the handler.
The rest of the computation should continue where these compuations left of.
For example, in case of \AgdaDatatype{Nondet}, \AgdaArgument{κ} would continue
on each result of the program in scope, because \AgdaFunction{<\$>} applies the
given function simply to each element of the list.

Next we will look at the computations in scope i.e. the computations stored by
\AgdaArgument{σ}.
As in chapter \ref{chapter:first-order} and explained in
\ref{preliminaries:scoped-effects}, the handler should be evaluated on the
computation in scope in isolation i.e. not reuse the previous state.
In the first order case this was accomplished by calling the handler again when
finding an opening scope delimiter.
To call the handler the computations, given by the functions \AgdaArgument{κ}
and \AgdaArgument{σ}, have to be inject into a context.
In case of \AgdaArgument{κ} we were given a context, now we have to use the
given context.
The given value \AgdaArgument{cxt} holds a value of type \AgdaDatatype{⊤} i.e.
no information just handler state.
\AgdaArgument{cxt} should be the initial handler context or state for the
handler.
Using \AgdaFunction{<\$} we can inject any computation into it.
Injecting a computation into \AgdaArgument{ctx} and calling \AgdaArgument{hdl}
should be the same as calling the actual handler for the effect on the
computation.

The cases for the three computations are identical to the ones presented by
\citeauthor{DBLP:conf/haskell/WuSH14}.
After evaluating the handler on the sub-trees, values are lifted into the
context, therefore the captured intermediate result type changes.
In Agda we have to manage the type explicitly.
In contrast to the Haskell implementation by 
\citeauthor{DBLP:conf/haskell/WuSH14} we have to explicitly change the captured 
type.
Using the curly brackets we access the hidden type constructor \AgdaArgument{C}
for the context and simply evaluate it on the given type.

Lastly we define the handler for \AgdaDatatype{Exc}.
Notice that the handler takes a computation of an arbitrary size
\AgdaArgument{i}.
This is needed to prove termination, because the handler itself is threaded
through the \AgdaInductiveConstructor{Other} operations using
\AgdaFunction{handle}.
To use handle we require a \AgdaDatatype{Syntax} instance for the rest of the
effect stack.
The cases for \AgdaInductiveConstructor{pure} and
\AgdaInductiveConstructor{Throw} are trivial.

\begin{code}
runExc : ⦃ Syntax (sum effs) ⦄ → Prog (Exc B ∷ effs) A {i} → Prog effs (B ⊎ A)
runExc (pure x)     = pure (inj₂ x)
runExc (Throw e)    = pure (inj₁ e)
\end{code}
To handle \AgdaInductiveConstructor{Catch} we first evaluate the operation in
scope by calling \AgdaFunction{runExc} on the computation in the
\AgdaInductiveConstructor{mainᵖ} position.
Using \AgdaFunction{>>=} we can inspect the result and either call the rest of
the computation \AgdaArgument{κ} with the result or the exception handler using
\AgdaInductiveConstructor{handleᵖ}.
In the latter case we again inspect the result and in case of a value also
continue with \AgdaArgument{κ}.
\begin{code}
runExc (Catch κ σ)  = runExc (σ mainᵖ) >>= λ where
  (inj₁ e) → runExc (σ (handleᵖ e)) >>= λ where
    (inj₁ e) → pure (inj₁ e)
    (inj₂ x) → runExc (κ x)
  (inj₂ x) → runExc (κ x)
\end{code}
Lastly we handle \AgdaInductiveConstructor{Other} operations.
As in chapter \ref{chapter:first-order} we reconstruct the operation using
\AgdaInductiveConstructor{impure}.
Moving the handler along now requires us to use \AgdaFunction{handle}.
We call \AgdaFunction{handle} on the given value of the container extension,
constructed using \AgdaArgument{s}, \AgdaArgument{κ} and \AgdaArgument{σ}.
Notice that \AgdaInductiveConstructor{Other} hides the
\AgdaInductiveConstructor{inj₂}, therefore the newly constructed container
extension has a different type.
It is an element of the signature without the exception syntax.
\AgdaFunction{handle} requires two additional arguments, the initial context as
well has the handler.
The initial context is given by
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}\AgdaInductiveConstructor{tt} i.e. a
successful result of type \AgdaDatatype{⊤}.
The handler has to evaluate \AgdaDatatype{Exc} syntax for a computation in the
context.
We handle the two cases using \AgdaFunction{[\_,\_]}.
If the argument is already an error we simply produce a
\AgdaInductiveConstructor{pure} calculation which produces the error.
Otherwise it is a computation, which we can evaluate using \AgdaFunction{runExc}.
Notice that the initial context always leads to the second case.
\begin{code}
runExc (Other s κ σ) = impure (handle (inj₂ tt) [ (λ x → pure (inj₁ x)) , runExc ] (s , κ , σ))
\end{code}
Even tough we pass \AgdaFunction{runExc} to \AgdaFunction{handle}, Agda accepts this
definition as terminating.
Agda can prove termination, because the argument is of an arbitrary size
\AgdaArgument{i}, therefore the values produced by \AgdaArgument{κ} and
\AgdaArgument{σ} have a smaller size.
Note that in the definition of \AgdaFunction{handle} the size of the handler
argument is the same as the size of the last argument i.e. the operation, which
is handled.
Therefore, the argument passed to the coproduct mediator, which calls
\AgdaFunction{runExc}, is smaller than the currently handled value.

\paragraph{Example}
Using the \AgdaDatatype{Exc} effect we can define simple programs, which
\AgdaFunction{throw} and \AgdaFunction{catch} exceptions.
The first function simply raises an exception.
\begin{code}
testExc : ⦃ Exc String ∈ effs ⦄ → Prog effs ℕ
testExc = pure 1 >> throw "Foo"
\end{code}
As expected, evaluating it yields the error message.
\begin{center}
\begin{code}[inline,hide]
runTestExc :
\end{code}
\begin{code}[inline]
 run (runExc testExc) ≡ inj₁ "Foo"
\end{code}
\begin{code}[inline,hide]
runTestExc = refl
\end{code}
\end{center}
The second function calls the first one, but catches the exception, returning an
alternative result.
\begin{code}
catchTestExc : ⦃ Exc String ∈ effs ⦄ → Prog effs ℕ
catchTestExc = testExc catch λ _ → pure 42
\end{code}
Evaluating the second function yields the value returned by the exception
handler.
\begin{center}
\begin{code}[inline,hide]
runCatchTestExc :
\end{code}
\begin{code}[inline]
 run (runExc catchTestExc) ≡ inj₂ 42
\end{code}
\begin{code}[inline,hide]
runCatchTestExc = refl
\end{code}
\end{center}

