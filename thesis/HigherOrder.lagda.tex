\begin{code}[hide]
{-# OPTIONS --overlapping-instances #-}

module HigherOrder where

open import Size using (↑_; Size; ∞)
open import Function using (_∘_; id; case_of_; const; _$_)
open import Level using (Level; 0ℓ; Lift; lift; Setω)

open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Empty.Polymorphic using (⊥)
open import Data.Product using (Σ-syntax; _×_; _,_) renaming (proj₁ to π₁; proj₂ to π₂)
open import Data.Maybe using (Maybe; fromMaybe; nothing; just)
open import Data.Nat using (ℕ; suc; zero)
open import Data.List using (List; _∷_; []; foldr; _++_)
open import Data.Sum using (_⊎_; inj₁; inj₂; [_,_])
open import Data.String using (String)
open import Data.Unit using (⊤; tt)

open import Relation.Unary using (_⊆_)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong; sym; trans)

variable
  A B : Set
  F : Set → Set₁
  i : Size
  C : ∀ {ℓ} → Set ℓ → Set ℓ
\end{code}

To address problems of the first order approach, noted in Section
\ref{first-order:results}, \citeauthor{DBLP:conf/haskell/WuSH14} introduce a
second approach using higher order abstract
syntax~\cite{DBLP:conf/haskell/WuSH14} to directly represent scoping
constructs.
By changing the syntax, this approach moves away from the exact definition of
algebraic effects, but the general concept of defining syntax and inducing
semantics using a handler is still present.
This approach is usually used in Haskell to implement scoped effects[polysemy,
fused-effects].
\citeauthor{bunkenburg2019modeling} already tried to implement some scoped
effects using this approach in Coq.
His approach failed due to issues with Coq's positivity
checker~\cite{bunkenburg2019modeling}.
Due to sizes issues, needed for the consistency of Agda, this approach
ultimately failed again.

In Section \ref{higher-order:syntax} we introduce the concept of higher order
syntax as described by \textcite{DBLP:conf/haskell/WuSH14}.
We partially follows Bunkenburg's approach because the limitation of Coq
described by him does not exist in Agda.
In Section \ref{higher-order:container} we discuss different
representation for higher order syntax in Agda.
We explain a size issue with all of these representations, which generally
prohibits us from implementing deep effects, without making excessive changes.
In Section \ref{higher-order:fixes} we discuss some potential changes to the
representation and their consequences.
Because deep effects are an uncommon requirement, in Section
\ref{higher-order:limited-impl} we still presents a limited implementation
to highlight some details specific to Agda and lay groundwork for Chapter
\ref{chapter:scoped-algebras}.


\section{Higher Order Syntax}
\label{higher-order:syntax}

In the first order approach operations only store their continuation.
If the operation has a local scope, the result of the continuation is expected
to contain a closing scope delimiter, which the handler uses to reconstruct
the scope.
In the higher order approach by \textcite{DBLP:conf/haskell/WuSH14} scoped
operations store the part of the program in their scope and their continuation
separately.
Therefore, the handler can directly access the program in scope as well as the
rest of the program.
In the following, we explain the basic construction of higher order syntax in
Haskell by \textcite{DBLP:conf/haskell/WuSH14}.
Afterwards, we present results regarding our Agda implementation.

In the first order approach the functors, that describe the syntax, are applied
to types of the form \texttt{Free F A}.
These type represent programs consisting of syntax described by \texttt{Free F},
which produce values of type \texttt{A}.
In the higher order approach these functors are generalized to higher order
functors, that is, in Haskell data types of kind \texttt{(* -> *) -> (* -> *)}.
In the implementation by \textcite{DBLP:conf/haskell/WuSH14}, the
\mintinline{haskell}{Prog sig a} data type represents syntax.
It is a slight generalization from the free monad in the first order approach.
In the \mintinline{haskell}{Impure} constructor the higher order functor is
applied to the syntax (represented by \mintinline{haskell}{Prog sig}) and the
result type \mintinline{haskell}{a} separately.

\begin{minted}{haskell}
    data Prog sig a = Pure a | Impure (sig (Prog sig) a)
\end{minted}
Because the program type is separated in syntax and result type it is possible
to store programs, that use the same signature but produce values of different a
type.
Consider the following definition of the higher order exception syntax as given
by \textcite{DBLP:conf/haskell/WuSH14}.

\begin{minted}{haskell}
    data HExc e m a = Throw e | forall x. Catch (m x) (e -> m x) (x -> m a)
\end{minted}
The \texttt{Catch} operation stores the computation in the scope of the catch
block \texttt{m x}, the handler producing an alternate result in case of an
error \texttt{e -> m x} as well as the rest of the program \texttt{x -> m a}, in
the following called continuation.
The continuation maps from the intermediate result, produced by the programs in
scope, to the rest of the computation.
The three programs agree on an arbitrary but per \texttt{catch} fixed type
\texttt{x} as well as on syntax, defined by \texttt{m}.

For this generalized syntax the behavior of \AgdaFunction{>>=} is changed
slightly.
Calling \AgdaFunction{>>=} on a higher order term just extends the continuation,
i.e. just substitutes the variables in terms of type \texttt{m a}.
Figure \ref{higher-order:syntax:bind} demonstrates the action of
\AgdaFunction{>>=} on \AgdaFunction{catch}.
The program in scope and the $e$ indexed subprogram (the exception handler) both
produce values of the captured type $X$, therefore \AgdaFunction{>>=} does not
affect them.
Only the third computation produces values of type \AgdaArgument{A} and
therefore is affected by \AgdaFunction{>>=}.
In terms of operation, the programs in scope are not modified and just the
actual rest of the program, described by the continuation, is affected.
Therefore, by generalizing the syntax \textcite{DBLP:conf/haskell/WuSH14} allow
a direct representation of operations with scopes.
Before we can implement the infrastructure, we have to choose an appropriate
representations for higher-order functors in Agda.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}[level distance=1.0cm,sibling distance=1.7cm]
      \node[treenode] at (0,0) {\textbf{catch}$_X$}
          child[sibling distance=1.3cm] {
              node[treenode] {\textbf{p}}
          }
          child[sibling distance=1.3cm] {
              node[treenode] {\textbf{h}$\; e$} edge from parent node[right,draw=none] {$e$}
          }
          child[sibling distance=1.3cm] {
              node[treenode] {\textbf{cont}$\; x$} edge from parent node[right,draw=none,xshift=0.1cm] {$x$}
          }
      ;

      \node at (3.0,-0.5) {$\gg\!\!=\;k\quad \equiv$};

      \node[treenode] at (6.3,0) {\textbf{catch}$_X$}
          child[sibling distance=1.7cm] {
              node[treenode] {\textbf{p}}
          }
          child[sibling distance=1.7cm] {
            node[treenode] {\textbf{h}$\; e$} edge from parent node[right,draw=none] {$e$}
          }
          child[sibling distance=1.7cm] {
              node[treenode] {\textbf{cont}$\; x\;\bind{}\; k$} edge from parent node[right,draw=none,xshift=0.1cm] {$x$}
          }
      ;
    \end{tikzpicture}
  \end{center}
  \caption{Calling \bind{} on an operation with a local scope}
  \label{higher-order:syntax:bind}
\end{figure}


\subsection{Representing Strictly Positive Higher Order Functors}
\label{higher-order:container}

In Haskell the generalization to higher order syntax is straight forward.
\textcite{DBLP:conf/haskell/WuSH14} switch to the new representation and
introduce type constructor classes to define higher-order functors as well as
the notion of syntax in this implementation of scoped effects.

In Agda we again have to find an appropriate representation for higher-order
functors to guaranty strict positivity, which leads to the idea of an indexed
container, as described by \textcite{DBLP:journals/jfp/AltenkirchGHMM15}
\footnote{Note that this is not the first publication related to indexed
  containers. Papers of the same name, by the same author(s) exist, as well as
  data types, known as ``Interaction Structures'' with essentially the same
  shape.}. 
Indexed containers from the paper as well in the Agda standard library are
defined as follows\footnote{The names of the fields are changed and level
  polymorphism is omitted to highlight differences between the definitions.}.

\begin{code}
record IndexedContainer (I O : Set₁) : Set₂ where
  field
    Shape : O → Set₁
    Pos : ∀ {o} → Shape o → Set
    Ctx : ∀ {o} → (s : Shape o) → Pos s → I

  ⟦_⟧ : (I → Set₁) → (O → Set₁)
  ⟦_⟧ F A = Σ[ s ∈ Shape A ] ((p : Pos s) → F (Ctx s p))
\end{code}
Similar to the Haskell data type \mintinline[breaklines]{haskell}{HExc e m a} we
have to store an arbitrary type, when defining scoping operations.
Therefore the higher-order functor has to produce elements of the larger
universe \AgdaDatatype{Set₁}.
Instantiating \AgdaArgument{I} and \AgdaArgument{O} with \AgdaDatatype{Set}
gives rise to a container extension of the correct shape.

Bunkenburg's approach also uses indexed containers~\cite{bunkenburg2019modeling}.
The above definition is similar to his first definition of a container
representation for a higher order functor.
His definition is given below.
\begin{code}
record HContainer : Set₂ where
  field
    Shape : Set₁
    Pos : Shape → Set
    Ctx : (s : Shape) → Pos s → Set → Set

  ⟦_⟧ : (Set → Set₁) → (Set → Set₁)
  ⟦_⟧ F A = Σ[ s ∈ Shape ] ((p : Pos s) → F (Ctx s p A))
\end{code}
In the second definition the \AgdaField{Shape} and \AgdaField{Pos} types cannot
depend on the given index, i.e. the argument for the returned functor.
Otherwise, both definitions are quite similar.
All stored elements are lifted by the given functor \AgdaArgument{F}.
\AgdaArgument{F}'s argument is generated using \AgdaField{Ctx}.
\AgdaField{Ctx} has access to the chosen shape, accessed position and the 
argument type \AgdaArgument{A}.
Conceptually, \AgdaField{Ctx} is used to choose between the stored
\AgdaArgument{X} and the argument type \AgdaArgument{A} i.e. programs inside or
outside the operations scope.

\textcite{bunkenburg2019modeling} notes that it is not possible to generically
define \AgdaFunction{>>=} for the resulting monad using the above
representation.
Similar to the Haskell implementation by \textcite{DBLP:conf/haskell/WuSH14} we
could define a type constructor class to implement
\mintinline[breaklines]{haskell}{emap :: (Monad m) => (m a -> m b) -> (sig m a
-> sig m b)}
for all valid higher order functors, which would allow the definition
\AgdaFunction{>>=}.
Both representations share another problem, the produced type constructor is not
necessarily strictly positive.
This is a necessary requirement to define recursive, effectful data structures.

There are multiple ways to fix this problem.
Following the pattern from Chapter \ref{chapter:first-order} we could replace
the returned functor with normal \AgdaDatatype{Container}.
This option is the most expressive, but also quite complex.
Furthermore, for most effects this level of control over syntax is not needed.
In most cases the argument \AgdaArgument{A} is only used directly, i.e. the
Haskell functor contains \texttt{a} only as \texttt{m a}.

Working under this assumption, it is possible to replace the returned functor
with a value of type \AgdaDatatype{Maybe}\AgdaSpace{}\AgdaDatatype{Set} and
replace \AgdaInductiveConstructor{nothing} with \AgdaArgument{A} in the
container extension.
This also guaranties strict positivity for \AgdaArgument{A}.
Furthermore, it allows a generic definition of \AgdaFunction{>>=}, because it is
possible to pattern match on the result of \AgdaFunction{Ctx} and therefore
differentiate between container extension which do or do not contain
\AgdaArgument{A}\footnote{An example implementation can be found in the
  repository.}.
 
\textcite{bunkenburg2019modeling} fixes this problem by switching to version of
a bi-container.
A bi-container has two position types for each shape.
Its extension is a bifunctor, that is strictly positive in both arguments.
Bunkenburg extended the usual bi-functor to an indexed bi-functor by adding a
context, similar to the above definition, to one of the positions.
The definition of an indexed bi-container and its extension is given below.

\begin{code}
record Effect : Set₂ where
  constructor _◁_+_/_
  field
    Shape : Set₁
    Pos : Shape → Set
    PosX : Shape → Set
    Ctx : ∀ s → PosX s → Set
open Effect

⟦_⟧ : Effect → (Set → Set₁) → Set → Set₁
⟦ S ◁ P + PX / C ⟧ F A = Σ[ s ∈ S ] (((p : P s) → F A) × ((p : PX s) → F (C s p)))
\end{code}
An indexed bi-container has two sets of positions for each shape, \AgdaField{Pos}
and \AgdaField{PosX}.
Its extension consists of a shape and two position functions, one for each set
of positions.
In the above definition, the second set of positions is augmented with a context
function.
The definition is similar to the second indexed container definition, except
that the context has no access to the given type \AgdaArgument{A}.
Therefore, the first position function always produces values of type
\AgdaArgument{F A}, and the second position function always produces values of
type \AgdaArgument{F X}, where \AgdaArgument{X} does not contain
\AgdaArgument{A}.
Later they produce the continuation and the programs in scope respectively.
In Agda this definition is recognized as strictly positive in \AgdaArgument{A}.
The analogous definition in Bunkeburg's Coq implementation is
not~\cite{bunkenburg2019modeling}.
 
Ultimately the choice of representation for the functor does not matter because
all approaches based on storing a type directly encounter the problem described
in Section \ref{higher-order:eff-data-ext-types}.
Going forward we will use Bunkeburg's indexed bi-container for examples because
they are easiest to work with and allow us to continue the approach.
As a side note, some operations with more complex syntax, like
\mintinline[breaklines]{haskell}{pass :: m (a, w -> w) -> m a} and
\mintinline[breaklines]{haskell}{listen :: m a -> m (a, w)} for the 
\mintinline[breaklines]{haskell}{Writer} monad cannot be implemented with this
representation.
 
Using our choice of functor representation we can define the \AgdaDatatype{Prog}
monad for higher order syntax as described by
\textcite{DBLP:conf/haskell/WuSH14}.
It is analogous to the Haskell definition above.

\begin{code}
⟦_⟧′ : Effect → (Set₁ → Set₁) → Set₁ → Set₁
⟦ S ◁ P + PX / C ⟧′ F A = Σ[ s ∈ S ]
  (((p : P s) → F A) × ((p : PX s) → F (Lift _ $ C s p)))

data Progᵂ (C : Effect) (A : Set₁) : Set₁ where
  pure    : A → Progᵂ C A
  impure  : ⟦ C ⟧′ (Progᵂ C) A → Progᵂ C A
\end{code}
% TODO: explain alternative container extension
Notice that due to the potentially captured type the \AgdaField{Shape} is an
element of \AgdaDatatype{Set₁}.
Therefore, \AgdaDatatype{Progᵂ} is also an element of \AgdaDatatype{Set₁}.
Because \AgdaDatatype{Progᵂ} is an element of \AgdaDatatype{Set₁} we can also
increase the universe level for \AgdaArgument{A} to $1$, which is needed to
define effectful data structures.
Unfortunately, because the universe level of the captured type is smaller than
\AgdaDatatype{Progᵂ}'s, it is not possible to work with effectful data as in
Haskell.
Section \ref{higher-order:eff-data-ext-types} contains a detailed explanation of
the problem.

\begin{code}[hide]
private
  variable
    E E′ : Effect
    effs effs′ effs″ : List Effect
\end{code}

\subsection{Effectful Data and Existential Types}
\label{higher-order:eff-data-ext-types}

A central problem with this approach is that it cannot model deep effects
without involving variable levels.
Consider the the following definition of an effectful list.

\begin{code}
data Listᴹ (E : Effect) (A : Set₁) : Set₁ where
  nil   : Listᴹ E A
  cons  : Progᵂ E A → Progᵂ E (Listᴹ E A) → Listᴹ E A
\end{code}
In contrast to the Coq version this definition is valid, but it cannot be used
as expected with \AgdaDatatype{Progᵂ}.
\AgdaDatatype{Listᴹ}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A} is
an element of \AgdaDatatype{Set₁} because it stores elements of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{X},
which is an element of \AgdaDatatype{Set₁}.
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{X} is
an element of \AgdaDatatype{Set₁} because it holds values of the container
extension and therefore values of the \AgdaField{Shape} type.
The \AgdaField{Shape} type is an element \AgdaDatatype{Set₁} because it has to
store the result type of the subcomputation \AgdaArgument{X}.
Therefore,
\AgdaDatatype{Listᴹ}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A} is
to large to be stored as result type of a subcomputation, i.e. it is not possible
to call a scoped operation (such as \AgdaFunction{share}) on an effectful data
structure.

More generally speaking, let us fix the universe level of the result type $X$ of
the subcomputation $\ell_X = l$.
The type is stored in the \AgdaField{Shape}, therefore the universe level of the
\AgdaField{Shape} type is given by $\ell_S = l + 1$.
Because the \AgdaDatatype{Prog} stores an element of the \AgdaField{Shape} its
level is given by $\ell_P = \ell_S$.
Effectful data structures live in the same universe as \AgdaDatatype{Prog}, but
are simultaneously required to be stored in the subcomputation.
We obtain the contradictory requirements $\ell_E = \ell_P = \ell_S = l + 1$ and
$\ell_E  \leqslant l$.

Holding on to the idea of storing types in the \AgdaField{Shape}, the only way to
fix this problem is to let all levels vary as needed.
Calling a scoped operation on an effectful data structure containing
computations with level $\ell$ produces a computation on level $\ell + 1$.
This leads to different levels across the program, which are difficult to unify
because they require manual lifting of types.
Similar to \AgdaDatatype{Size}, \AgdaDatatype{Level} is a builtin type with a
limited set of associated functions.
Furthermore, when mapping a scoped operation over a recursive data structure
(e.g. \AgdaFunction{share}) the increase in the universe level depends on the
depth of the structure.
Both of these phenomena are hard to deal with and lead in our implementations to
an impractical library interface.
We were not able to solve the problem of data dependent levels in recursive data
structures.


\subsection{Indexing and Integrating Data}
\label{higher-order:fixes}

To solve the problem from Section \ref{higher-order:eff-data-ext-types} we
explore two approaches.
For an effect system it seems reasonable to not let universe level vary or in
the best case not increase it, that is, either make \AgdaDatatype{Progᵂ} an
element of \AgdaDatatype{Set} or represent effectful data in \AgdaDatatype{Set}.
In this section we mention two ideas, one for each goal.
Unfortunately, in our tests non of them lead to a concise solution.

\paragraph{Indexing}
We could try to solve the problem of increasing universe levels by not storing
the intermediate result types directly.
Instead we index the program over a data type storing all intermediate result
types, that is, we introduce a typing context.
The level of the index is independent from the level of the structure.
Therefore, the chain of reasoning from Section
\ref{higher-order:eff-data-ext-types} does not apply.
The typing context needs to have the same structure as the program.
This is possible by reusing the arbitrary branching mechanism, which is known
from the free monad.

% data Env (Σ : Effect) (A : Set) : Set₁ where
%   ∙     : A → Env Σ A
%   _,-   : ⟦ Ops  Σ ⟧ (Env Σ A) → Env Σ A
%   _,_+_ : (X : Set) → ⟦ Scps Σ ⟧ (Env Σ X) → Env Σ A → Env Σ A
% 
% data Prog (Σ : Effect) (A : Set) : Env Σ A → Set where
%   var : (a : A) → Prog Σ A (∙ a)
%   op  : (op : Shape (Ops Σ)) →
%     -- ^ Current operation symbol
%     {Γ : Pos (Ops Σ) op → Env Σ A} →
%     -- ^ Typing environment for each subcomputation
%     (κ : (p : Pos (Ops Σ) op) → Prog Σ A (Γ p)) →
%     -- ^ Subcomputations
%     Prog Σ A ((op , Γ) ,-)
%     scp : (op : Shape (Scps Σ)) →
%     -- ^ Current scope operation symbol
%     {Γ : Pos (Scps Σ) op → Env Σ X} →
%     -- ^ typing environment for each subcomputation
%     {Γ′ : Env Σ A} →
%     -- ^ typing environment for continuation
%     (ω : (p : Pos (Scps Σ) op) → Prog Σ X (Γ p)) →
%     -- ^ Subcomputations
%     (κ : X → Prog Σ A Γ′) →
%     -- ^ Continuation
%     Prog Σ A (X , (op , Γ) + Γ′)

A central problem with this approach is that every call of \AgdaFunction{>>=}
potentially grows the tree described by \AgdaDatatype{Prog} and therefore the
context.
These changes now have to be reflected on the type level because the context is
embedded in the type of \AgdaDatatype{Prog}
If \AgdaFunction{>>=} calls different operations for different values, leafs in
the context are substituted with different new contexts.
As with increasing universe levels, this complications are increasingly hard to
deal with and are hard to hide from the user of the library.
For example, in our tests the changes to the context required the definition of
helper functions that describe the modification.
This lead to an impractical interface.

\paragraph{Integrating Data and Computations}
We cannot model deep effects because effectful data structures are an element
of \AgdaDatatype{Set₁}, but data is required to be an element of
\AgdaDatatype{Set}.
But, these special data structures are only to large because they contain
values of the computation type \AgdaDatatype{Prog} itself, not arbitrary values
from \AgdaDatatype{Set₁}.
Conceptually these data structures continue the computation tree.
In the above definitions this fact is unused.
Instead, we try to store arbitrary elements of \AgdaDatatype{Set₁}, i.e. we over
approximate the class of types.
We tried using this fact by unifying data and computations.
For example, the following data type for computations can also store effectful
tuples.

\begin{code}
data Progᴰ (Effs : Effect) : Set → Set₁ where
  var     : A → Progᴰ Effs A
  impure  : ⟦ Effs ⟧ (Progᴰ Effs) A → Progᴰ Effs A
  _,_     : ⟦ Effs ⟧ (Progᴰ Effs) A → ⟦ Effs ⟧ (Progᴰ Effs) B → Progᴰ Effs (A × B)
\end{code}
By representing data structures using a small type and creating their actual
structure using a new \AgdaDatatype{Prog} constructor it is possible to avoid
the size issues.
We tried implementing this idea but failed when trying to represent generic,
recursive structures.
Furthermore, working with data described this way is unintuitive.

Following the same idea, one could try to store either type variables or data
type representation (e.g. polynomial functors) in the \AgdaField{Shape} of
effects and build an effectful representation in the container extension.


\section{Limited Implementation}
\label{higher-order:limited-impl}

Translating the approach by \textcite{DBLP:conf/haskell/WuSH14} without major
changes to Agda makes working with deep effects difficult.
However, it can still be used to implement scoped effects without deep effects.
For completeness, the following section will show key points of a simplified
implementation using this approach.
To write concise code we work with Bunkenburg's indexed bi-containers
because they model effects with a simple continuation accurately.
In a more complex implementation, where more control over the type of the
continuation is needed, a container with a \AgdaField{Ctx} for \AgdaArgument{A}
might be needed\footnote{To guarantied strict positivity one of the solutions
  mentioned in Section \ref{higher-order:container} is needed.}.
Furthermore, we do not define a level polymorphic version of \AgdaDatatype{Prog}
as its only advantage is a limited representation of deep effects.
Instead we limit value types to elements of \AgdaDatatype{Set}, i.e. those which
can always be scoped.

First we port over the infrastructure for modular effects.
The coporduct carries over seamlessly.
We combine the position functions pairwise and handle the \AgdaFunction{Ctx}
functions using the coproduct mediator.
\AgdaDatatype{Void} is also define analogous to the first order
setting.

\begin{code}
_⊕_ : Effect → Effect → Effect
(S₁ ◁ P₁ + PX₁ / C₁) ⊕ (S₂ ◁ P₂ + PX₂ / C₂) =
  (S₁ ⊎ S₂) ◁ [ P₁ , P₂ ] + [ PX₁ , PX₂ ] / [ C₁ , C₂ ]

Void : Effect
Void = ⊥ ◁ (λ()) + (λ()) / λ()
\end{code}
To easily work in the higher order setting we adapt the \AgdaDatatype{Prog}
data type similarly to the \AgdaDatatype{Free} monad from Chapter
\ref{chapter:first-order}, i.e. we parameterize over a list of effects and add a
\AgdaDatatype{Size} parameter.
To avoid excessive use of universe levels and to avoid the \texttt{--cumulativity}
flag we work with a version of \AgdaDatatype{Prog} with a
\AgdaDatatype{Set} value type\footnote{To be monad this parameter has to be an
  element of \AgdaDatatype{Set₁}.
  Such a structure is sometimes known as a \textit{relative monad} because we
  can still define a \AgdaFunction{>>=} for which the usual laws hold.
  Adapting this structure to a normal monad is possible but involves more level
  annotations and is easier in a universe polymorphic setting.}.
We try to avoid the flag in this exemplary implementation because it weakens
type inference, forcing us to write more implicit parameters explicitly.

\begin{code}[hide]
sum : List Effect → Effect
sum = foldr _⊕_ Void

infix 4 _∈_
data _∈_ {ℓ : Level} {A : Set ℓ} (x : A) : List A → Set ℓ where
  instance
    here   : ∀ {xs} → x ∈ x ∷ xs
    there  : ∀ {y xs} → ⦃ _∈_ {ℓ} x xs ⦄ → x ∈ y ∷ xs
\end{code}
\begin{code}
data Prog (effs : List Effect) (A : Set) : {Size} → Set₁ where
  pure    : A → Prog effs A {i}
  impure  : ⟦ sum effs ⟧ (λ X → Prog effs X {i}) A → Prog effs A {↑ i}
\end{code}
To implement \AgdaFunction{>>=} we define the \AgdaFunction{emap} function.
The function has the same signature as the one by
\textcite{DBLP:conf/haskell/WuSH14}.
In contrast to the implementation by \textcite{DBLP:conf/haskell/WuSH14} the
function can be defined generically for all effects because the indexed
bi-container representation is more restrictive than the their haskell
representation.

\begin{code}
emap : (F A → F B) → ⟦ E ⟧ F A → ⟦ E ⟧ F B
emap f p = π₁ p , f ∘ π₁ (π₂ p) , π₂ (π₂ p)
{-# INLINE emap #-}

_>>=_ : Prog effs A → (A → Prog effs B) → Prog effs B
pure x    >>= k = k x
impure x  >>= k = impure (emap {F = λ X → Prog _ X} (_>>= k) x)
\end{code}
\begin{code}[hide]
_>>_ : Prog effs A → Prog effs B → Prog effs B
ma >> mb = ma >>= λ _ → mb

_<*>_ : Prog effs (A → B) → Prog effs A → Prog effs B
mf <*> ma = mf >>= λ f → ma >>= λ a → pure (f a)

run : Prog [] A → A
run (pure x) = x
\end{code}
The definition of \AgdaFunction{>>=} is identical to the one in Haskell.
Using the \AgdaKeyword{INLINE} pragma and projections, as explained in Section
\ref{container}, we can define \AgdaFunction{emap} separately without obscuring
the termination.
Note that \AgdaFunction{emap} only applies the given function to the result of
the first position function because only it has access to \AgdaArgument{A}.
The programs in scope are ignored.
Therefore, the recursive calls to \AgdaFunction{>>=} also only affect to the
continuation.

The infrastructure from Chapter \ref{chapter:first-order} carries over with
minimal changes.
We reuse the \AgdaDatatype{\_∈\_} proposition.
The \AgdaFunction{inj} and \AgdaFunction{op} functions have to be modified
slightly for the new program type.

\begin{code}
inj : E ∈ effs → ⟦ E ⟧ F A → ⟦ sum effs ⟧ F A
inj here           (s , κ) = inj₁ s , κ
inj {F = F} (there ⦃ p ⦄)  prog with inj {F = F} p prog
... | s , κ = inj₂ s , κ

op : ⦃ E ∈ effs ⦄ → ⟦ E ⟧ (λ X → Prog effs X) A → Prog effs A
op ⦃ p ⦄ = impure ∘ inj {F = λ X → Prog _ X} p
\end{code}
Usually, when an effect is handled the value type is lifted in a context, which
is represented by a functor (e.g. \AgdaDatatype{List} for \AgdaDatatype{Nondet}).

Following the approach by \citeauthor{DBLP:conf/haskell/WuSH14} we define the
\AgdaDatatype{Syntax} type class for effects.
% Given a handler, the type class allows to partially interpret a program in a
% context to a new program producing values in the context. % Interprets parts of syntax?
Given a handler, the type class explains how to move handlers and evaluation contexts
for other effects through syntax of the given effect.
A handler is given by a function that transforms a program in a context to a new
program producing values inside the context, i.e. in Haskell a function of type
\mintinline[breaklines]{haskell}{c (Prog sig a) -> Prog sig' (c a)}.
We first have to define contexts.
The normal definition of a functor does not suffice because it lifts all types
to the same \AgdaDatatype{Setₙ}.
Because we have to lift programs as well as data, this means \AgdaDatatype{Set₁}.
Later, we will have to lift the intermediate result type of scoped operations in
the context.
This is problematic, because scoped operations can only capture elements of
\AgdaDatatype{Set}.
Therefore, the context should preserve the universe level of its argument, i.e.
lift values to types in \AgdaDatatype{Set} and programs to types in
\AgdaDatatype{Set₁}.
Even with \texttt{--cumulativity} this behavior is not handled automatically by
Agda\footnote{\url{https://agda.readthedocs.io/en/v2.6.1.1/language/cumulativity.html\#limitations}}.

To simulate the above behavior we define the \AgdaDatatype{Context} type
constructor class.
A context is essentially a functor that respects the universes structure.
Given a type from \AgdaDatatype{Setₙ}, it lifts it to another type in the same
\AgdaDatatype{Setₙ}.
Furthermore, a function between two data types in different universes is
lifted to a function the lifted types, i.e. between universes.
An instances should satisfy the functors laws even though they are not enforced
here.
Notice that \AgdaDatatype{Context} quantifies over arbitrary
\AgdaDatatype{Level}s $\ell$ and therefore is an element of \AgdaDatatype{Setω},
the universe which is larger than all natural number indexed universes.
\AgdaDatatype{Setω} represents the end of Agda's universe hierarchy.
There are no universes indexed by larger ordinals and therefore to preserve
consistency there are some restrictions on terms of this type.
In our case this should not be a problem because we only ever parameterize over
contexts.

\begin{code}
record Context (F : ∀ {ℓ} → Set ℓ → Set ℓ) : Setω where
  field _<$>_ : ∀ {a b} {A : Set a} {B : Set b} → (A → B) → F A → F B
  _<$_ : ∀ {a b} {A : Set a} {B : Set b} → A → F B → F A
  a <$ mb = const a <$> mb
open Context ⦃...⦄
\end{code}
With the context in place we define the \AgdaDatatype{Syntax} type class by
\citeauthor{DBLP:conf/haskell/WuSH14}.
By generalizing to higher order abstract syntax it is possible to represent
programs in scope and continuations explicitly.
The order in which they are evaluated and therefore how an evaluation context
should be moved through the program is a semantic question.
The type class explains how an arbitrary handler can be thread through an
effects syntax using the function \AgdaFunction{handle}.
The first argument is the initial context.
Using \AgdaFunction{<\$} it is possible to move an arbitrary value or
computation into the context.
The second argument is a handler as defined by
\citeauthor{DBLP:conf/haskell/WuSH14}.
The handler takes a program in a context and interprets parts of the syntax.
The resulting program has a different effect stack, usually the tail of the
given stack.
By partially evaluating the program the context is moved through the
program.
As a result, the values are now lifted into the context.
Using the initial context and the handler, the type class explains how an
arbitrary operation from the signature \AgdaArgument{E} is traversed.

Notice that the given operations contain program of an arbitrary size.
Furthermore, the given handler works on programs of the same size.
This will be important in Section \ref{higher-order:limited-impl} when we define
handlers which pass them self to \AgdaFunction{handle}.

\begin{code}
record Syntax (E : Effect) : Setω where
  field handle : ⦃ Context C ⦄ → C ⊤ →
          (∀ {X} → C (Prog effs′ X {i}) → Prog effs″ (C X)) →
          ⟦ E ⟧ (λ X → Prog effs′ X {i}) A → ⟦ E ⟧ (λ X → Prog effs″ X) (C A)
open Syntax ⦃...⦄
\end{code}
To finish the basic infrastructure we define two \AgdaDatatype{Syntax}
instances.
The instance for the empty signature \AgdaDatatype{Void} is trivial because the
type of container extensions is empty.
Combined signatures are handled by inspecting the given operation, calling the
\AgdaFunction{handle} for its signatures and injecting the result in the
combined signature.

\begin{code}
instance
  Void-Syntax : Syntax Void
  Syntax.handle Void-Syntax _ _ ()

  ⊕-syntax : ⦃ Syntax E ⦄ → ⦃ Syntax E′ ⦄ → Syntax (E ⊕ E′)
  Syntax.handle ⊕-syntax ctx hdl (inj₁ s , κ , σ) with handle ctx hdl (s , κ , σ)
  ... | s′ , κ′ , σ′ = (inj₁ s′) , κ′ , σ′
  Syntax.handle ⊕-syntax ctx hdl (inj₂ s , κ , σ) with handle ctx hdl (s , κ , σ)
  ... | s′ , κ′ , σ′ = (inj₂ s′) , κ′ , σ′
\end{code}


\subsection{Exceptions}
\label{higher-order:exceptions}

As an example for an effect in the higher order setting we implement exceptions.

\paragraph{Syntax}
Exceptions support two operations, the usual algebraic operation
\AgdaFunction{throw} as well as the scoped operation \AgdaFunction{catch}.
The two operations are identical to the Haskell definition from Section
\ref{higher-order:syntax}.
\AgdaDatatype{throw} takes the thrown exception as an additional parameter.
\AgdaDatatype{catch} has no additional parameters, but its \AgdaField{Shape}
stores the result type of the computations in scope.

\begin{code}
data Excˢ (E : Set) : Set₁ where
  throwˢ  : (e : E)    → Excˢ E
  catchˢ  : (X : Set)  → Excˢ E
\end{code}
The extension of an indexed bi-container is equipped with two positions
functions, one for programs resulting in
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}
and one for programs in scope, i.e. such resulting in programs of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{Y}
where \AgdaArgument{Y} is defined by the context.
Let us first consider the positions for programs in scope.

\begin{code}
data ExcCatchᴾ (E X : Set) : Set where
  mainᵖ    : ExcCatchᴾ E X
  handleᵖ  : (e : E) → ExcCatchᴾ E X

Excᵖˣ : ∀ E → Excˢ E → Set
Excᵖˣ E (throwˢ e)  = ⊥
Excᵖˣ E (catchˢ X)  = ExcCatchᴾ E X

Excᶜ : ∀ E s → Excᵖˣ E s → Set
Excᶜ E (catchˢ X) mainᵖ        = X
Excᶜ E (catchˢ X) (handleᵖ e)  = X
\end{code}
\AgdaFunction{throw} has no programs in scope and therefore no positions.
\AgdaFunction{catch}'s positions are given by \AgdaDatatype{ExcCatchᴾ}.
The operation has two kinds of programs in scope.
The first single program is given by \AgdaInductiveConstructor{mainᵖ}, the
program whose exceptions should be caught.
The program in the \AgdaInductiveConstructor{handleᵖ} position provides a
continuation for each exception.
It corresponds to the exception handler.
Both programs produce results of type \AgdaArgument{X}.
The result types for the programs in scope are defined using the context
\AgdaFunction{Excᶜ}.

Next we define the positions for the effects continuation, i.e the programs
producing values of type \AgdaArgument{A}.

\begin{code}
Excᵖ : ∀ E → Excˢ E → Set
Excᵖ E (throwˢ e)  = ⊥
Excᵖ E (catchˢ X)  = X
\end{code}
Again, \AgdaFunction{throw} has no continuations because it produces no
results.
\AgdaFunction{catch} provides a continuation that processes the result of the
program in scope, i.e. it provides a continuation for each value of type
\AgdaArgument{X}.

Using the above definitions we define the \AgdaDatatype{Exc} effect.
Furthermore, we introduce pattern synonyms to easily pattern match on values of
the container extension in the handler.
\begin{code}
Exc : Set → Effect
Exc E = Excˢ E ◁ Excᵖ E + Excᵖˣ E / Excᶜ E

pattern Throw e      = impure (inj₁ (throwˢ e)  , _ ,  _)
pattern Catch κ σ    = impure (inj₁ (catchˢ _)  , κ ,  σ)
pattern Other s κ σ  = impure (inj₂ s           , κ ,  σ)
\end{code}
Lastly we define smart constructors for the operations.
Because \AgdaFunction{throw} has no continuations, we define the container
extensions as $\lambda ()$.
\AgdaFunction{catch} captures a program \AgdaArgument{p} as well as the
exception handler in scope.
Therefore, they are returned by \AgdaArgument{σ}.
The effects continuation \AgdaArgument{κ} is initially given by
\AgdaInductiveConstructor{pure}.
It is later extended using \AgdaFunction{>>=}.
This is analogous to the generic operations in the first order approach.

\begin{code}[hide]
infix 0 _catch_
\end{code}
\begin{code}
throw : ⦃ Exc B ∈ effs ⦄ → (e : B) → Prog effs A
throw e = op (throwˢ e , (λ()) , λ())

_catch_ : ⦃ Exc B ∈ effs ⦄ → Prog effs A → (B → Prog effs A) → Prog effs A
p catch h = op $ catchˢ _ , pure , λ{ mainᵖ → p ; (handleᵖ e) → h e }
\end{code}

\paragraph{Instances}
Before we implement the handler we have to provide a \AgdaDatatype{Context}
instance for \AgdaArgument{E}\AgdaSpace{}\AgdaDatatype{⊎\_} to use
\AgdaFunction{handle}, to traverse \AgdaInductiveConstructor{Other} operations.
The instance is nearly identical to the functor instance, except that the values
that are constructed using \AgdaArgument{f} could be elements of another
\AgdaDatatype{Set}. 
Because \AgdaDatatype{E ⊎\_} is polymorphic in the level of its argument type,
this is not a problem.

\begin{AgdaAlign}
\begin{code}
instance
  _⊎-Context : ∀ {E : Set} → Context (E ⊎_)
  Context._<$>_ _⊎-Context f (inj₁ e) = inj₁ e
  Context._<$>_ _⊎-Context f (inj₂ x) = inj₂ (f x)
\end{code}
As explained above, the \AgdaDatatype{Syntax} instance is needed to thread the
handler through the syntax of \textit{other} effects.
Therefore, the instance for \AgdaDatatype{Exc} is not needed for the
\AgdaDatatype{Exc} handler.
Nevertheless, we define a \AgdaDatatype{Syntax} instance for \AgdaDatatype{Exc}
next to explain the usual structure.

\begin{code}
  Exc-Syntax : ∀ {E} → Syntax (Exc E)
  Syntax.handle Exc-Syntax          _    _    (throwˢ e  , _  , _  ) = throwˢ e , (λ()) , λ()
  Syntax.handle Exc-Syntax {C = C}  ctx  hdl  (catchˢ X  , κ  , σ  ) = catchˢ (C X) ,
    (λ cx        → hdl (κ              <$>  cx   )) , λ where
    mainᵖ        → hdl (σ mainᵖ        <$   ctx  )
    (handleᵖ e)  → hdl (σ (handleᵖ e)  <$   ctx  )
\end{code}
\end{AgdaAlign}
The case for \AgdaInductiveConstructor{throwˢ} is trivial because the operation
has no continuations on which to evaluate the handler.
The case for \AgdaInductiveConstructor{catchˢ} is more complex.

The idea behind the \AgdaDatatype{Syntax} type class is to thread the handler
through the operations, i.e. to evaluate the syntax of another effect in all
subprograms while the context moves through the computation.
The given handler \AgdaArgument{hdl} is slightly different from the final
handler in that it only accepts computations inside its context.
This is needed to thread the handlers current state through the computation.
Moving the context correctly through the syntax is a semantic problem and
therefore has to be defined on a case by case basis.
Therefore, we have to consider how \AgdaFunction{catch} is evaluated.
The \AgdaFunction{catch} operations is evaluated by evaluating the program in
the \AgdaInductiveConstructor{mainᵖ} position first.
In case of an exception we produce an alternative result using the program in
the \AgdaInductiveConstructor{handleᵖ} position.
At last we feed the result in the continuation.
Handlers for other effects should traverse the effect similarly.
Therefore, the intermediate result is lifted into the handlers context.

The effects continuation \AgdaArgument{κ} now takes an argument of type
\AgdaArgument{C X}, i.e. the result of a program in scope inside the foreign
handlers context.
By mapping the given \AgdaArgument{κ} over the given \AgdaArgument{cx} the
continuation is applied to the argument of type \AgdaArgument{X} and lifted
inside its context.
By applying \AgdaFunction{hdl} we partially evaluate the syntax and move the
context through the continuation of the operation.
For example, in case of threading \AgdaDatatype{Nondet} through exception
syntax the context is a list.
\AgdaArgument{κ} would continue on each result of the program in scope,
because \AgdaFunction{<\$>} applies the given function simply to each element of
the list.

Next we will look at the programs in scope, i.e. the programs produced by
\AgdaArgument{σ}.
To correctly thread its state through the syntax of other operations the handler
requires that all computations are lifted into the context.
In case of \AgdaArgument{κ} we were given an argument in a context.
Because the programs in scope are evaluated first, they are lifted into the
initial context.
The given value \AgdaArgument{cxt} holds a value of type \AgdaDatatype{⊤}, i.e.
no information just handler state.
Using \AgdaFunction{<\$} we can inject any program into it.
Injecting a program into \AgdaArgument{ctx} and calling \AgdaArgument{hdl}
should be the same as calling the actual handler for the effect on the
computation.

The three cases are identical to the ones presented by
\textcite{DBLP:conf/haskell/WuSH14}.
After evaluating the handler on the sub-trees, values are lifted into the
context.
Therefore, the captured intermediate result type changes.
In Agda we explicitly store the type.
Therefore, in contrast to the Haskell implementation by
\textcite{DBLP:conf/haskell/WuSH14}, we have to explicitly change the captured
type.
Using the curly brackets we access the hidden type constructor \AgdaArgument{C}
for the context and simply evaluate it on the given type.
Furthermore, injecting a program into a context is only possible because we
defined special versions of the functor operators that respect the universe
structure.
If we had used a normal functor we either could not have stored the lifted
intermediate result type or could not have injected results of \AgdaArgument{κ}
and \AgdaArgument{σ} into the context.

\paragraph{Handler}
Lastly we define the handler for \AgdaDatatype{Exc}.
Notice that the handler takes a program of an arbitrary size
\AgdaArgument{i}.
The size is needed to prove termination because the handler itself is threaded
through the \AgdaInductiveConstructor{Other} operations using
\AgdaFunction{handle}.
To use \AgdaField{handle} we require a \AgdaDatatype{Syntax} instance for the
rest of the effect stack.
The cases for \AgdaInductiveConstructor{pure} and
\AgdaInductiveConstructor{Throw} are trivial.

\begin{code}
runExc : ⦃ Syntax (sum effs) ⦄ → Prog (Exc B ∷ effs) A {i} → Prog effs (B ⊎ A)
runExc (pure x)     = pure (inj₂ x)
runExc (Throw e)    = pure (inj₁ e)
\end{code}
To handle \AgdaInductiveConstructor{Catch} we first evaluate the operation in
scope by calling \AgdaFunction{runExc} on the program in the
\AgdaInductiveConstructor{mainᵖ} position.
Using \AgdaFunction{>>=} we can inspect the result and either call the rest of
the program \AgdaArgument{κ} with the result or the exception handler using
\AgdaInductiveConstructor{handleᵖ}.
In the latter case we again inspect the result and in case of a value also
continue with \AgdaArgument{κ}.
\begin{code}
runExc (Catch κ σ)  = runExc (σ mainᵖ) >>= λ where
  (inj₁ e) → runExc (σ (handleᵖ e)) >>= λ where
    (inj₁ e) → pure (inj₁ e)
    (inj₂ x) → runExc (κ x)
  (inj₂ x) → runExc (κ x)
\end{code}
Lastly we handle \AgdaInductiveConstructor{Other} operations.
As in Chapter \ref{chapter:first-order} we reconstruct the operation using
\AgdaInductiveConstructor{impure}.
Moving the handler along requires us to use \AgdaFunction{handle}.
We call \AgdaFunction{handle} on the given value of the container extension,
constructed using \AgdaArgument{s}, \AgdaArgument{κ} and \AgdaArgument{σ}.
Notice that \AgdaInductiveConstructor{Other} hides the
\AgdaInductiveConstructor{inj₂}.
Therefore, the newly constructed container extension has a different type.
It is an element of the signature without the exception syntax.
\AgdaFunction{handle} requires two additional arguments, the initial context as
well has the handler.
The initial context is given by
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}\AgdaInductiveConstructor{tt}, i.e. a
successful result of type \AgdaDatatype{⊤}.
The handler has to evaluate \AgdaDatatype{Exc} syntax for a program in the
context.
We handle the two cases using \AgdaFunction{[\_,\_]}.
If the argument is already an exception we simply produce a
\AgdaInductiveConstructor{pure} program which produces the exception.
Otherwise it is a program that we can evaluate using \AgdaFunction{runExc}.
Notice that the initial context always leads to the second case.
\begin{code}
runExc (Other s κ σ) = impure (handle (inj₂ tt) [ (λ x → pure (inj₁ x)) , runExc ] (s , κ , σ))
\end{code}
Even tough we pass \AgdaFunction{runExc} to \AgdaFunction{handle}, Agda accepts this
definition as terminating.
Agda can prove termination because the argument is of an arbitrary size
\AgdaArgument{i}.
Therefore, the programs produced by \AgdaArgument{κ} and \AgdaArgument{σ} have a
smaller size.
Note that in the definition of \AgdaFunction{handle} the size of the handler
argument is the same as the size of the traversed operation.
Therefore, the argument passed to the coproduct mediator that calls
\AgdaFunction{runExc} is smaller than the currently handled value.

\paragraph{Example}
Using the \AgdaDatatype{Exc} effect we can define simple programs that
\AgdaFunction{throw} and \AgdaFunction{catch} exceptions.
The first function simply raises an exception.
\begin{code}
testExc : ⦃ Exc String ∈ effs ⦄ → Prog effs ℕ
testExc = pure 1 >> throw "Foo"
\end{code}
As expected, evaluating it yields the error message.
\begin{center}
\begin{code}[inline,hide]
runTestExc :
\end{code}
\begin{code}[inline]
 run (runExc testExc) ≡ inj₁ "Foo"
\end{code}
\begin{code}[inline,hide]
runTestExc = refl
\end{code}
\end{center}
The second function calls the first one, catches the exception and returns
an alternative result.
\begin{code}
catchTestExc : ⦃ Exc String ∈ effs ⦄ → Prog effs ℕ
catchTestExc = testExc catch λ _ → pure 42
\end{code}
Evaluating the second function yields the value returned by the exception
handler.
\begin{center}
\begin{code}[inline,hide]
runCatchTestExc :
\end{code}
\begin{code}[inline]
 run (runExc catchTestExc) ≡ inj₂ 42
\end{code}
\begin{code}[inline,hide]
runCatchTestExc = refl
\end{code}
\end{center}


\subsection{Lifting First Order Syntax}
\label{higher-order:lifting}

\textcite{DBLP:conf/haskell/WuSH14} present a construction for lifting first
order syntax to the higher order setting.
A similar construction is possible with the container representations.
In this section we present the corresponding construction and use it to
lift nondeterminism syntax into the higher order setting. 

Given the two fields of a normal container we construct an indexed bi-container.
The shapes and positions for \AgdaArgument{A} correspond exactly to the first
two arguments for the indexed bi-container.
The second position type and the context are precisely the generalization from
the first-order to the higher-order setting.
Therefore, we simply use \AgdaDatatype{⊥} to ignore them.

We did not use the cumulativitiy flag to simplify this exemplary implementation.
This simplified the earlier implementation, but forces us now to do some manual
lifting.
The \AgdaDatatype{Lift} data type is element of an arbitrary universe and stores
a value of an arbitrary type from a smaller universe.
Using \AgdaDatatype{Lift} we can pass the given shape type to the constructor.
To apply the position function we unwrap the lifted shape.

\begin{code}
_▷_ : (Shape : Set) → (Pos : Shape → Set) → Effect
S ▷ P = Lift _ S ◁ (λ (lift s) → P s) + (λ _ → ⊥) / λ _ ()
\end{code}
As shown by \textcite{DBLP:conf/haskell/WuSH14}, we can define a general
\AgdaDatatype{Syntax} instance for lifted first order syntax.
The second type of positions is empty.
Therefore, we can omit the definition of \AgdaArgument{σ}.
Notice that this definition applies to all effects constructed using
\AgdaFunction{▷}.
Therefore, we avoid defining parts of the infrastructure for effects without
scoping operations.

\begin{code}
instance
  ▷-Syntax : ∀ {S P} → Syntax (S ▷ P)
  Syntax.handle ▷-Syntax ctx hdl (s , κ , σ) = s , (λ p → hdl (κ p <$ ctx)) , λ()
\end{code}

\paragraph{Example: Nondet}
Using the above function and \AgdaKeyword{instance} we can lift the
nondeterminism syntax from Chapter \ref{chapter:first-order} to the higher-order
setting.

\begin{code}[hide]
data Nondetˢ : Set where ⁇ˢ failˢ : Nondetˢ
\end{code}
\begin{code}
Nondet : Effect
Nondet = Nondetˢ ▷ λ where failˢ → ⊥ ; ⁇ˢ → Bool

pattern Fail      = impure (inj₁ (lift failˢ)  , _ , _)
pattern Choice κ  = impure (inj₁ (lift ⁇ˢ)     , κ , _)
\end{code}
We still have to define a \AgdaDatatype{Context} instance and a custom handler
for \AgdaDatatype{Nondet} because we have to define the interaction with other
higher order syntax.
Again, the \AgdaDatatype{Context} instance corresponds to the normal functor
instance.

\begin{code}
instance
  List-Context : Context List
  Context._<$>_ List-Context f []        = []
  Context._<$>_ List-Context f (x ∷ xs)  = f x ∷ (f <$> xs)
\end{code}
The first three cases of the handler are identical to the implementation in
Section \ref{nondeterminism}.
The interesting new case is the one for \AgdaInductiveConstructor{Other} syntax.
We must use \AgdaFunction{handle} to traverse the arbitrary operation.
Analougous to exceptions we evaluate \AgdaFunction{handle} on the reconstructed
given operation.
The initial context has to be singleton list, because empty lists would
stop the compuation, while lists with two or more elements would duplicate
parts of the program.

\AgdaFunction{hdl} has to map from a \AgdaDatatype{List} of program with
\AgdaDatatype{Nondet} syntax to a program without \AgdaDatatype{Nondet}
syntax and a \AgdaDatatype{List} as value type.
Consider the \AgdaDatatype{Syntax} instance for \AgdaDatatype{Exc}, given in
Section \ref{higher-order:exceptions}.
The two program in scope use the inital context, i.e. the given list is a
singleton.
The continuation uses \AgdaFunction{<\$>} to apply the rest of the program to
the given results of the compuatation in scope and evaluates them using
\AgdaFunction{hdl}.
Conceptually, the argument of \AgdaFunction{hdl} corresponds to the
programs that produce results for each result of some earlier compuatation.
We therefore use the obvious (and usually given) implementation of the
\AgdaFunction{hdl} function i.e. we sequence the computations from left to right
and concat the results.

\begin{code}
runNondet : ⦃ Syntax (sum effs) ⦄ → Prog (Nondet ∷ effs) A {i} → Prog effs (List A)
runNondet (pure x)       = pure (x ∷ [])
runNondet Fail           = pure []
runNondet (Choice κ)     = ⦇ runNondet (κ true) ++ runNondet (κ false) ⦈
runNondet (Other s κ σ)  = impure (handle (tt ∷ []) hdl (s , κ , σ))
  where  hdl : ⦃ Syntax (sum effs) ⦄ →
           List (Prog (Nondet ∷ effs) B {i}) → Prog effs (List B)
         hdl []          = pure []
         hdl (mx ∷ mxs)  = ⦇ runNondet mx ++ hdl mxs ⦈
\end{code}
Notice that the argument of the handler as well as the \AgdaFunction{hdl}
function are of size \AgdaArgument{i} to guaranty termination, following the
pattern explained in Section \ref{higher-order:exceptions}.

\begin{code}
_⁇_ : ⦃ Nondet ∈ effs ⦄ → Prog effs A → Prog effs A → Prog effs A
p ⁇ q = op (lift ⁇ˢ , (if_then p else q) , λ())
\end{code}

\paragraph{Ordering of Operations}
It is important to note that the above handler induces unexpected semantics when
combined with certain other effects.
Interpreting \AgdaDatatype{Nondet} syntax yields the results in depth first
ordering.

If a part of a nondeterministic program is captured in a scope the order of
operations changes.
The program in scope is evaluated, yielding its results in depth first ordering.
Afterwards, using \AgdaFunction{hdl} the continuation is evaluated on each
intermediate result and the final results are concatenated.
The results are in the expected depth first order, but the operations not.
The order of operations is introduced by \AgdaFunction{>>=}.
A scoping operation is evaluated by first evaluating the part of the computation
in scope and afterwards the continuations outside the scope.
Therefore the unevaluated operations are now also in this order.
The potential unexpected semantics of this implementation is that introducing a
semantically irrelevant scoping operation (e.g. \texttt{local id}) influences
the ordering of operations of other globally evaluated effects.
This behavior is known, because it also occurs in some Haskell implementations
of scoped
effects\footnote{https://github.com/polysemy-research/polysemy/issues/246}.

Encountering the above behavior is quite uncommon, because the program has to
evaluate a scoping operation globally over a nondeterministic program, while
simultaneously using global operations whose ordering can be observed.
Most effects only provide one of the two.
% Furthermore, evaluating effects globally over \AgdaDatatype{Nondet} inherently
% depends on the ordering of branches, which is precisely what nondeterminism
% abstracts away.
The most common examples are global state to collect results, global writer to
log and global partiality to stop all branches, which do not encounter the above
behavior.
When catching global exceptions over a nondeterministic program the above
behavior seems more reasonable.
More complex semantics (e.g. leaving and reentering the scoped computation) are
conceivable, but not captured by the standard representation of higher order
syntax.


\subsection{Modular Higher Order Effects}

In the last to sections we presented effects in isolation.
Similar to the combined semantics described in Section
\ref{first-order:combined-effects} we can induced different semantics by
reordering the handlers.
Consider the following program, which chooses between a
\AgdaInductiveConstructor{pure} value and an exception.

\begin{code}
throwNondet : ⦃ Nondet ∈ effs ⦄ → ⦃ Exc ⊤ ∈ effs ⦄ → Prog effs ℕ
throwNondet = pure 42 ⁇ throw tt
\end{code}
Evaluating \AgdaDatatype{Exc} first runs it locally in each branch of the
nondeterministic computation i.e. each branch either returns a result or an
exception. 
\begin{center}
\begin{code}[inline,hide]
localExc : 
\end{code}
\begin{code}[inline]
 run (runNondet (runExc throwNondet)) ≡ inj₂ 42 ∷ inj₁ tt ∷ []
\end{code}
\begin{code}[inline,hide]
localExc = refl
\end{code}
\end{center}
Evaluating \AgdaDatatype{Exc} last evaluates it globally.
Therefore, throwing an exception stops the current, by the \AgdaDatatype{Nondet}
handler induced, ordered evaluation of nondeterministic branches and just
returns the exception.
\begin{center}
\begin{code}[inline,hide]
globalExc : 
\end{code}
\begin{code}[inline]
 run (runExc (runNondet throwNondet)) ≡ inj₁ tt
\end{code}
\begin{code}[inline,hide]
globalExc = refl
\end{code}
\end{center}


\section{Results}

In this chapter, we tired to implement scoped effects a higher order
syntax representation approach by \textcite{DBLP:conf/haskell/WuSH14}.
We continued Bunkeburg's~\cite{bunkenburg2019modeling} investigation of this
approach and uncovered a deep seated problem while implementing it in Agda,
which arises due to more restrictive requirements for programs compared to
Haskell.
The problem occurs because we have to work in a consistent hierarchy of
universes to preserve Agda's consistency.
When using higher order syntax, computations potentially have to store the type
of data they produce and therefore are larger than the data.
This prevents scoping operations from capturing other computations, without
switching to a larger type of computations.
This specifically includes effectful data structures, which are needed for the
implementation of deep effects.
In case of deep sharing this leads to a dependence between universe levels and
the depth of data structures.
We discussed two general approaches to avoid increasing universe levels when
working with effectful data.
However, both of them require a more complex representation for either types or
data, probably leading to a more complex implementations, which is harder to
work with in real programs.

Because deep effects are an uncommon requirement, we still presented key points
of a limited implementation.
Although, we removed deep effects as a requirement, we still had to work with
different universe levels, while implementing the \AgdaDatatype{Syntax}
instances.
This lead to manual lifting between universes and structures involving
\AgdaDatatype{Setω}, which should generally be avoided.
A level polymorphic implementation, needed for increasing the size of the
computation types, uses both constructs more frequently.
