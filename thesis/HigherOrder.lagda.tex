\begin{code}[hide]
{-# OPTIONS --overlapping-instances #-}

module HigherOrder where

open import Size using (↑_; Size; ∞)
open import Function using (_∘_; id; case_of_; const; _$_)
open import Level using (Level; 0ℓ; Lift; lift; Setω)

open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Empty using (⊥)
open import Data.Product using (Σ-syntax; _×_; _,_) renaming (proj₁ to π₁; proj₂ to π₂)
open import Data.Maybe using (Maybe; fromMaybe; nothing; just)
open import Data.Nat using (ℕ; suc; zero)
open import Data.List using (List; _∷_; []; foldr; _++_)
open import Data.Sum using (_⊎_; inj₁; inj₂; [_,_])
open import Data.String using (String)
open import Data.Unit using (⊤; tt)

open import Relation.Unary using (_⊆_)
open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong; sym; trans)

variable
  A B : Set
  F : Set → Set₁
  i : Size
  C : ∀ {ℓ} → Set ℓ → Set ℓ
\end{code}

To address problems of the first order approach, noted in Section
\ref{first-order:results}, \citeauthor{DBLP:conf/haskell/WuSH14} introduce a
second approach using higher order abstract
syntax~\cite{DBLP:conf/haskell/WuSH14} to directly represent scoping
constructs.
By changing the syntax, this approach moves away from the exact definition of
algebraic effects, but the general concept of defining syntax and inducing
semantics using a handler is still present.
This approach is usually used in Haskell to implement scoped effects[polysemy,
fused-effects].
\citeauthor{bunkenburg2019modeling} already tried to implement some scoped
effects using this approach in Coq.
His approach failed due to issues with Coq's positivity
checker~\cite{bunkenburg2019modeling}.
Due to sizes issues, needed for the consistency of Agda, this approach
ultimately failed again.

In Section \ref{higher-order:syntax} we introduce the concept of higher order
syntax as described by \textcite{DBLP:conf/haskell/WuSH14}.
We partially follows Bunkenburg's approach, because the limitation of Coq
described by him does not exist in Agda.
In Section \ref{higher-order:container} we discuss different
representation for higher order syntax in Agda.
We explain a size issue with all of these representations, which generally
prohibits us from implementing deep effects, without making excessive changes.
In Section \ref{higher-order:fixes} we discuss some potential changes to the
representation and their consequences.
Because deep effects are an uncommon requirement, in Section
\ref{higher-order:limited-impl} we still presents a limited implementation,
to highlight some details specific to Agda and lay groundwork for Chapter
\ref{chapter:scoped-algebra}.


\section{Higher Order Syntax}
\label{higher-order:syntax}

In the first order approach operations only store their continuation.
If the operation has a local scope, the result of the continuation is expected
to contain a closing scope delimiter, which the handler uses to reconstruct
the scope.
In the higher order approach by \textcite{DBLP:conf/haskell/WuSH14} scoped
operations store their continuation as well as the part of the program in their
scope.
Therefore, the handler can directly access the program in scope.
In the following, we explain the basic construction of higher order syntax in
Haskell by \textcite{DBLP:conf/haskell/WuSH14}.
Afterwards, we present results regarding an Agda implementation.

In the first order approach the functors, that describe the syntax, are applied
to types of the form \texttt{Free F A} i.e. programs consisting of syntax
described by \texttt{Free F}, which produce values of type \texttt{A}.
In the higher order approach these functors are generalized to higher order
functors, that is in Haskell data types of kind \texttt{(* -> *) -> (* -> *)}.
The \mintinline{haskell}{Prog sig a} data type represents syntax.
It is a slight generalization from the free monad in the first order approach.
In the \mintinline{haskell}{Impure} constructor the now higher-roder functors
are applied to the syntax (represented by \mintinline{haskell}{Prog sig}) and
the result type \mintinline{haskell}{a} separately.

\begin{minted}{haskell}
    data Prog sig a = Pure a | Impure (sig (Prog sig) a)
\end{minted}
Because the program type is separated in syntax and result type it is possible
to store programs, that use the same signature but produce values of different
types.
Consider the following definition of the higher order exception syntax as given
by \textcite{DBLP:conf/haskell/WuSH14}.

\begin{minted}{haskell}
    data HExc e m a = Throw e | forall x. Catch (m x) (e -> m x) (x -> m a)
\end{minted}
The \texttt{Catch} operation stores the computation in the scope of the catch
block \texttt{m x}, the handler producing an alternate result in case of an
error \texttt{e -> m x} as well as the rest of the program \texttt{x -> m a}, in
the following called continuation.
The continuation maps from the intermediate result, produced by the programs in
scope, to the rest of the computation.
The three programs agree on an arbitrary but per \texttt{catch} fixed type
\texttt{x} as well as on syntax, defined by \texttt{m}.

For this generalized syntax the behavior of \AgdaFunction{>>=} is changed
slightly.
Calling \AgdaFunction{>>=} on a higher order term just extends the continuation,
i.e. just substitutes the variables in terms of type \texttt{m a}.
Figure \ref{higher-order:syntax:bind} demonstrates the action of
\AgdaFunction{>>=} on \AgdaFunction{catch}.
The program in scope and the $e$ indexed subprogram (the exception handler) both
produce values of the captured type $X$, therefore \AgdaFunction{>>=} does not
affect them.
Only the third computation is of type \AgdaArgument{A} and therefore affected by
\AgdaFunction{>>=}.
The programs in scope are not modified.
Just the actual rest of the program, described by the continuation, is affected.
Therefore, by generalizing the syntax \textcite{DBLP:conf/haskell/WuSH14} allow
a direct representation of operations with scopes.
Before we can implement the infrastructure, we have to choose an appropriate
representations for higher-order functors in Agda.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}[level distance=1.0cm,sibling distance=1.7cm]
      \node[treenode] at (0,0) {\textbf{catch}$_X$}
          child[sibling distance=1.3cm] {
              node[treenode] {\textbf{p}}
          }
          child[sibling distance=1.3cm] {
              node[treenode] {\textbf{h}$\; e$} edge from parent node[right,draw=none] {$e$}
          }
          child[sibling distance=1.3cm] {
              node[treenode] {\textbf{cont}$\; x$} edge from parent node[right,draw=none,xshift=0.1cm] {$x$}
          }
      ;

      \node at (3.0,-0.5) {$\gg\!\!=\;k\quad \equiv$};

      \node[treenode] at (6.3,0) {\textbf{catch}$_X$}
          child[sibling distance=1.7cm] {
              node[treenode] {\textbf{p}}
          }
          child[sibling distance=1.7cm] {
            node[treenode] {\textbf{h}$\; e$} edge from parent node[right,draw=none] {$e$}
          }
          child[sibling distance=1.7cm] {
              node[treenode] {\textbf{cont}$\; x\;\bind{}\; k$} edge from parent node[right,draw=none,xshift=0.1cm] {$x$}
          }
      ;
    \end{tikzpicture}
  \end{center}
  \caption{Calling \bind{} on an operation with a local scope}
  \label{higher-order:syntax:bind}
\end{figure}


\subsection{Representing Strictly Positive Higher Order Functors}
\label{higher-order:container}

In Haskell the generalization to higher order syntax is straight forward.
\textcite{DBLP:conf/haskell/WuSH14} switch to the new representation and
introduce type constructor classes to define higher-order functors as well as
the notion of syntax in this implementation of scoped effects.

In Agda we again have to find an appropriate representation for functors to
guaranty strict positivity, which leads to the idea of an indexed container as
described by \textcite{DBLP:journals/jfp/AltenkirchGHMM15}
\footnote{Note that this is not the first publication related to indexed
  containers. Papers of the same name, by the same author(s) exist, as well as
  data types, known as ``Interaction Structures'' with essentially the same
  shape.}. 
Indexed containers from the paper as well in the Agda standard library are
defined as follows\footnote{The names of the fields are changed and level
  polymorphism is omitted to highlight differences between the definitions.}.

\begin{code}
record IndexedContainer (I O : Set₁) : Set₂ where
  field
    Shape : O → Set₁
    Pos : ∀ {o} → Shape o → Set
    Ctx : ∀ {o} → (s : Shape o) → Pos s → I

  ⟦_⟧ : (I → Set₁) → (O → Set₁)
  ⟦_⟧ F A = Σ[ s ∈ Shape A ] ((p : Pos s) → F (Ctx s p))
\end{code}
Allowing indicies of arbitrary levels and instantiating \AgdaArgument{I} and
\AgdaArgument{O} with \AgdaDatatype{Set} gives rise to a container extension
of the correct shape.

Bunkenburg's approach also uses indexed container~\cite{bunkenburg2019modeling}.
The above definition is similar to his first definition of a container
representation for a higher order functor.
His definition is given below.
\begin{code}
record HContainer : Set₂ where
  field
    Shape : Set₁
    Pos : Shape → Set
    Ctx : (s : Shape) → Pos s → Set → Set

  ⟦_⟧ : (Set → Set₁) → (Set → Set₁)
  ⟦_⟧ F A = Σ[ s ∈ Shape ] ((p : Pos s) → F (Ctx s p A))
\end{code}
In the second definition the \AgdaField{Shape} and \AgdaField{Pos} types cannot
depend on the given index i.e. the argument for the returned functor.
Otherwise, both definitions are quite similar.
All stored elements are lifted by the given functor \AgdaArgument{F}.
\AgdaArgument{F}'s argument is generated using \AgdaField{Ctx}.
\AgdaField{Ctx} has access to the chosen shape, accessed position and the 
argument type \AgdaArgument{A}.
Conceptually, \AgdaField{Ctx} is used to choose between the stored
\AgdaArgument{X} and the argument type \AgdaArgument{A} i.e. programs inside or
outside the operations scope.

\textcite{bunkenburg2019modeling} notes that it is not possible to generically
define \AgdaFunction{>>=} for the resulting monad, that uses the above
representation.
Similar to the Haskell implementation by \textcite{DBLP:conf/haskell/WuSH14} we
could define a type constructor class to implement a
\mintinline[breaklines]{haskell}{emap :: (Monad m) => (m a -> m b) -> (sig m a
-> sig m b)}
for all valid higher-order functors, which would allows the definition
\AgdaFunction{>>=}.
Both representations share another problem, the produced type constructor is not
necessarily strictly positive.
This is a necessary requirement to define recursive, effectful data structures.

There are multiple ways to fix this problem.
Following the pattern from Chapter \ref{chapter:first-order} we could replace
the returned functor with normal \AgdaDatatype{Container}.
This option is the most expressive, but also quite complex.
Furthermore, for most effects this level of control over syntax is not needed.
In most cases the argument \AgdaArgument{A} is only used directly i.e. the
Haskell functor contains \texttt{a} only as \texttt{m a}.

Working under this assumption, it is possible to replace the returned functor
with a value of type \AgdaDatatype{Maybe}\AgdaSpace{}\AgdaDatatype{Set} and
replace \AgdaInductiveConstructor{nothing} with \AgdaArgument{A} in the
container extension.
This also guaranties strict positivity for \AgdaArgument{A}.
Furthermore, it allows a generic definition of \AgdaFunction{>>=}, because it is
possible to pattern match on the result of \AgdaFunction{Ctx} and therefore
differentiate between container extension which do or do not contain
\AgdaArgument{A}\footnote{An example implementation can be found in the
  repository.}.
 
\textcite{bunkenburg2019modeling} fixes this problem by switching to version of
a bi-container.
A bi-container has two position types for each shape.
Its extension is a bifunctor, that is strictly positive in both arguments.
Bunkenburg extended the usual bi-functor to an indexed bi-functor by adding a
context, similar to the above definition, to one of the positions.
The definition of an indexed bi-container and its extension is given below.

\begin{code}
record Effect : Set₂ where
  constructor _◁_+_/_
  field
    Shape : Set₁
    Pos : Shape → Set
    PosX : Shape → Set
    Ctx : ∀ s → PosX s → Set
open Effect

⟦_⟧ : Effect → (Set → Set₁) → Set → Set₁
⟦ S ◁ P + PX / C ⟧ F A = Σ[ s ∈ S ] (((p : P s) → F A) × ((p : PX s) → F (C s p)))
\end{code}
An indexed bi-container has two sets of positions for each shape, \AgdaField{Pos}
and \AgdaField{PosX}.
Its extension consists of a shape and two position functions, one for each set
of positions.
In the above definition, the second set of positions is augmented with a context
function.
The definition is similar to the second indexed container definition, except
that the context has no access to the given type \AgdaArgument{A}.
Therefore, the first position function always produces values of type
\AgdaArgument{F A}, and the second position function always produces values of
type \AgdaArgument{F X}, where \AgdaArgument{X} does not contain
\AgdaArgument{A}.
Later they produce the continuation and the programs in scope respectively.
In Agda this definition is recognized as strictly positive in \AgdaArgument{A}.
The analogous definition in Bunkeburg's Coq implementation is
not~\cite{bunkenburg2019modeling}.
 
Ultimately the choice of representation for the functor does not matter, because
all approaches based on storing a type directly encounter the problem described
in Section \ref{higher-order:eff-data-ext-types}.
Going forward we will use Bunkeburg's indexed bi-container for examples, because
they are easiest to work with and allow us to continue the approach.
As a side note, some operations with more complex syntax, like \texttt{pass :: m
(a, w -> w) -> m a} and \texttt{listen :: m a -> m (a, w)} for the
\texttt{Writer} monad cannot be implemented with this representation.
 
Using our choice of functor representation we can define the \AgdaDatatype{Prog}
monad for higher order syntax as described by
\textcite{DBLP:conf/haskell/WuSH14}.
It is analogous to the Haskell definition above.

\begin{code}
⟦_⟧′ : Effect → (Set₁ → Set₁) → Set₁ → Set₁
⟦ S ◁ P + PX / C ⟧′ F A = Σ[ s ∈ S ]
  (((p : P s) → F A) × ((p : PX s) → F (Lift _ $ C s p)))

data Progᵂ (C : Effect) (A : Set₁) : Set₁ where
  pure    : A → Progᵂ C A
  impure  : ⟦ C ⟧′ (Progᵂ C) A → Progᵂ C A
\end{code}
% TODO: explain alternative container extension
Notice that due to the potentially captured type in the \AgdaField{Shape} is an
element of \AgdaDatatype{Set₁}.
Therefore, \AgdaDatatype{Progᵂ} is also an element of \AgdaDatatype{Set₁}.
Because \AgdaDatatype{Progᵂ} is an element of \AgdaDatatype{Set₁} we can also
increase the universe level for \AgdaArgument{A} to $1$, which is needed to
define effectful data structures.
Unfortunately, because the universe level of the captured type is smaller than
\AgdaDatatype{Progᵂ}'s it is not possible to work with effectful data as in
Haskell.
Section \ref{higher-order:eff-data-ext-types} contains a detailed explanation of
the problem.

\begin{code}[hide]
private
  variable
    E E′ : Effect
    effs effs′ effs″ : List Effect
\end{code}

\subsection{Effectful Data and Existential Types}
\label{higher-order:eff-data-ext-types}

A central problem with this approach is that it cannot model deep effects
without involving variable levels.
Consider the the following definition of an effectful list.
Although it is valid, in contrast to the Coq version, it cannot be used as
expected with \AgdaDatatype{Progᵂ}

\begin{code}
data Listᴹ (E : Effect) (A : Set₁) : Set₁ where
  nil   : Listᴹ E A
  cons  : Progᵂ E A → Progᵂ E (Listᴹ E A) → Listᴹ E A
\end{code}
\AgdaDatatype{Listᴹ}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A} is
an element of \AgdaDatatype{Set₁}, because it stores elements of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{X},
which is an element of \AgdaDatatype{Set₁}.
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{X} is
an element of \AgdaDatatype{Set₁}, because it holds values of the container
extension i.e. elements of the \AgdaField{Shape} type, which is an element
\AgdaDatatype{Set₁}, because it has to store the result type of the
subcomputation \AgdaArgument{X}.
Therefore,
\AgdaDatatype{Listᴹ}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A} is
to large to be stored as result type of a subcomputation i.e. it is not possible
to call a scoped operation (such as \AgdaFunction{share}) on an effectful data
structure.

More generally speaking, let us fix the universe level of the result type $X$ of
the subcomputation $\ell_X = l$.
The type is stored in the \AgdaField{Shape}, therefore the universe level of the
\AgdaField{Shape} type is given by $\ell_S = l + 1$.
Because the \AgdaDatatype{Prog} stores an element of the \AgdaField{Shape} its
level is given by $\ell_P = \ell_S$.
Effectful data structures live in the same universe as \AgdaDatatype{Prog}, but
are simultaneously required to be stored in the subcomputation.
We obtain the contradictory requirements $\ell_E = \ell_P = \ell_S = l + 1$ and
$\ell_E  \leqslant l$.

Holding on to the idea of storing types in the \AgdaField{Shape}, the only way to
fix this problem is to let all levels vary as needed.
Calling a scoped operation on an effectful data structure containing
computations with level $\ell$ produces a computation on level $\ell + 1$.
This leads to different levels across the program, which are difficult to unify,
because they require manual lifting of types.
Similar to \AgdaDatatype{Size}, \AgdaDatatype{Level} is a builtin type with a
limited set of associated functions.
Furthermore, when mapping a scoped operation over a recursive data structure
(e.g. \AgdaFunction{share}) the increase in the universe level depends on the
depth of the structure.
Both of these phenomena are hard to deal with and lead in our implementations to
an impractical library interface.
We were not able to solve the problem of data dependent levels in recursive data
structures.


\subsection{Indexing and Integrating Data}
\label{higher-order:fixes}

To solve the problem from Section \ref{higher-order:eff-data-ext-types} we
explored two approaches.
For an effect system it seems reasonable to not let universe level vary or in
the best case not increase it, that is either make \AgdaDatatype{Progᵂ} an
element of \AgdaDatatype{Set} or represent effectful data in \AgdaDatatype{Set}.
In this section we mention two ideas, one for each goal.
Unfortunately, in our tests non of them lead to a concise solution.

\paragraph{Indexing}
We could tried to solve the problem of increasing universe levels by not storing
the intermediate result types directly.
Instead we indexing the program over a data type storing all intermediate result
types, a typing context.
The level of the index is independent from the level of the structure, therefore
the chain of reasoning from Section \ref{higher-order:eff-data-ext-types} does
not apply.
The typing context needs to have the same structure as the program.
This is possible by reusing the arbitrary branching mechanism, known from the
free monad.

% data Env (Σ : Effect) (A : Set) : Set₁ where
%   ∙     : A → Env Σ A
%   _,-   : ⟦ Ops  Σ ⟧ (Env Σ A) → Env Σ A
%   _,_+_ : (X : Set) → ⟦ Scps Σ ⟧ (Env Σ X) → Env Σ A → Env Σ A
% 
% data Prog (Σ : Effect) (A : Set) : Env Σ A → Set where
%   var : (a : A) → Prog Σ A (∙ a)
%   op  : (op : Shape (Ops Σ)) →
%     -- ^ Current operation symbol
%     {Γ : Pos (Ops Σ) op → Env Σ A} →
%     -- ^ Typing environment for each subcomputation
%     (κ : (p : Pos (Ops Σ) op) → Prog Σ A (Γ p)) →
%     -- ^ Subcomputations
%     Prog Σ A ((op , Γ) ,-)
%     scp : (op : Shape (Scps Σ)) →
%     -- ^ Current scope operation symbol
%     {Γ : Pos (Scps Σ) op → Env Σ X} →
%     -- ^ typing environment for each subcomputation
%     {Γ′ : Env Σ A} →
%     -- ^ typing environment for continuation
%     (ω : (p : Pos (Scps Σ) op) → Prog Σ X (Γ p)) →
%     -- ^ Subcomputations
%     (κ : X → Prog Σ A Γ′) →
%     -- ^ Continuation
%     Prog Σ A (X , (op , Γ) + Γ′)

A central problem with this approach is that every call of \AgdaFunction{>>=}
potentially grows the tree described by \AgdaDatatype{Prog} and therefore the
context.
These changes now have to be reflected on the type level, because the context is
embedded in the type of \AgdaDatatype{Prog}
If \AgdaFunction{>>=} calls different operations for different values then leafs
in the context are substituted with different new contexts.
As with increasing universe levels, this complications are increasingly hard to
deal with and are hard to hide from the user of the library.
For example, in our tests the changes to the context require the definition of
helper function, that describe the modification.

\paragraph{Integrating Data and Computations}
We cannot model deep effects, because effectful data structures are an element
of \AgdaDatatype{Set₁}, but data is required to be an element of
\AgdaDatatype{Set}.
But, these special data structures are only to large, because they contain
values of the computation type \AgdaDatatype{Prog} itself, not arbitrary values
from \AgdaDatatype{Set₁}.
Conceptually these data structures continue the computation tree.
In the above definitions this fact is unused.
Instead, we try to store arbitrary elements of \AgdaDatatype{Set₁}, i.e. we over
approximate the class of types.
We tried using this fact by unifying data and computations.
For example, the following data type for computations can also store effectful
tuples.

\begin{code}
data Progᴰ (Effs : Effect) : Set → Set₁ where
  var     : A → Progᴰ Effs A
  impure  : ⟦ Effs ⟧ (Progᴰ Effs) A → Progᴰ Effs A
  _,_     : ⟦ Effs ⟧ (Progᴰ Effs) A → ⟦ Effs ⟧ (Progᴰ Effs) B → Progᴰ Effs (A × B)
\end{code}
By representing an data structures using a small type and creating its actual
structure, using a new \AgdaDatatype{Prog} constructor, it is possible to avoid
the size issues.
We tried implementing this idea, but failed when trying to represent generic,
recursive structures.
Furthermore, working with data described this way is unintuitive.

Following the same idea, one could try to store either type variables or data
type representation (e.g. polynomial functors) in the \AgdaField{Shape} of
effects and build an effectful representation in the container extension.


\section{Limited Implementation}
\label{higher-order:limited-impl}

Translating the approach by \textcite{DBLP:conf/haskell/WuSH14} without major
changes to Agda makes working with deep effects difficult.
However, it can still be used to implement scoped effects without deep effects.
For completeness, the following section will show key points of a simplified
implementation using this approach.
To write concise code we will work with Bunkenburg's indexed bi-containers,
because they model effects with a simple continuation accurately.
In a more complex implementation, where more control over the type of the
continuation is needed, a container with a \AgdaField{Ctx} for \AgdaArgument{A}
might be needed\footnote{To guarantied strict positivity one of the solutions
  mentioned in Section \ref{higher-order:container} is needed.}.

First we port over the infrastructure for modular effects.
The coporduct carries over seamlessly.
We combine the position functions pairwise and handle the \AgdaFunction{Ctx}
functions using the coproduct mediator.

\begin{code}
_⊕_ : Effect → Effect → Effect
(S₁ ◁ P₁ + PX₁ / C₁) ⊕ (S₂ ◁ P₂ + PX₂ / C₂) =
  (S₁ ⊎ S₂) ◁ [ P₁ , P₂ ] + [ PX₁ , PX₂ ] / [ C₁ , C₂ ]
\end{code}
To easily work in the higher order setting we adapt the \AgdaDatatype{Prog}
data type similarly to \AgdaDatatype{Free} monad from Chapter
\ref{chapter:first-order}, i.e. we parameterize over a list of effects and add a
\AgdaDatatype{Size} parameter.
To avoid excessive use of universe levels and to avoid the \texttt{--cumulativity}
flag we work with a version of \AgdaDatatype{Prog} which takes a type parameter
from \AgdaDatatype{Set}\footnote{To be monad this parameter has to be an element
  of \AgdaDatatype{Set₁}. Such a structure is sometimes known as a \textit{relative
  monad}, because we can still define a \AgdaFunction{>>=} for which the usual
  laws hold. Adapting this structure to a normal monad is possible, but involves
  more level annotations and is easier in a universe polymorphic setting.}.
We try to avoid the flag in this exemplary implementation, because it weakens
type inference, forcing us to write more implicit parameters explicitly.

\begin{code}[hide]
Void : Effect
Void = Lift _ ⊥ ◁ (λ()) + (λ()) / λ()

sum : List Effect → Effect
sum = foldr _⊕_ Void

infix 4 _∈_
data _∈_ {ℓ : Level} {A : Set ℓ} (x : A) : List A → Set ℓ where
  instance
    here   : ∀ {xs} → x ∈ x ∷ xs
    there  : ∀ {y xs} → ⦃ _∈_ {ℓ} x xs ⦄ → x ∈ y ∷ xs
\end{code}
\begin{code}
data Prog (effs : List Effect) (A : Set) : {Size} → Set₁ where
  pure    : A → Prog effs A {i}
  impure  : ⟦ sum effs ⟧ (λ X → Prog effs X {i}) A → Prog effs A {↑ i}
\end{code}
To implement \AgdaFunction{>>=} we define the \AgdaFunction{emap} function.
The function has the same signature as the one by
\textcite{DBLP:conf/haskell/WuSH14}.
In contrast to the implementation by \textcite{DBLP:conf/haskell/WuSH14} the
function can be defined generically for all effects, because the indexed
bi-container representation is more restrictive than the their representation in
Haskell.

\begin{code}
emap : (F A → F B) → ⟦ E ⟧ F A → ⟦ E ⟧ F B
emap f p = π₁ p , f ∘ π₁ (π₂ p) , π₂ (π₂ p)
{-# INLINE emap #-}

_>>=_ : Prog effs A → (A → Prog effs B) → Prog effs B
pure x    >>= k = k x
impure x  >>= k = impure (emap {F = λ X → Prog _ X} (_>>= k) x)
\end{code}
\begin{code}[hide]
_>>_ : Prog effs A → Prog effs B → Prog effs B
ma >> mb = ma >>= λ _ → mb

_<*>_ : Prog effs (A → B) → Prog effs A → Prog effs B
mf <*> ma = mf >>= λ f → ma >>= λ a → pure (f a)

run : Prog [] A → A
run (pure x) = x
\end{code}
The definition for \AgdaFunction{>>=} is identical to the one in Haskell.
Using the \AgdaKeyword{INLINE} pragma, as explained in Section \ref{container},
we can define \AgdaFunction{emap} separately without obscuring the termination.
Note that \AgdaFunction{emap} only applies the given function to the result of
the first position function, because only it has access to \AgdaArgument{A}.
The programs in scope are ignored.

The infrastructure from Chapter \ref{chapter:first-order} carries over with
minimal changes.
We reuse the \AgdaDatatype{\_∈\_} proposition.
The \AgdaFunction{inj} and \AgdaFunction{op} functions have to be modified
slightly for the new program type.

\begin{code}
inj : E ∈ effs → ⟦ E ⟧ F A → ⟦ sum effs ⟧ F A
inj here           (s , κ) = inj₁ s , κ
inj {F = F} (there ⦃ p ⦄)  prog with inj {F = F} p prog
... | s , κ = inj₂ s , κ

op : ⦃ E ∈ effs ⦄ → ⟦ E ⟧ (λ X → Prog effs X) A → Prog effs A
op ⦃ p ⦄ = impure ∘ inj {F = λ X → Prog _ X} p
\end{code}
Usually, when an effect is handled the value type is lifted in a context,
represented by a functor (e.g. \AgdaDatatype{List} for \AgdaDatatype{Nondet}).

Following the approach by \citeauthor{DBLP:conf/haskell/WuSH14} we will define a
type class \AgdaDatatype{Syntax}, which, given a handler, allows evaluating a
computation in a context to a new computation producing values in the context.
To define such a type class we first have to define a context.
The normal definition of a functor does not suffice, because it lifts all type
to the same \AgdaDatatype{Setₙ}.
This is problematic, because scoped operations can only capture elements of
\AgdaDatatype{Set}, while computations are elements of \AgdaDatatype{Set₁}.
Therefore values and computations in context have different universe levels, but
during the evaluating we have to lift both in the context.
Even with \texttt{--cumulativity} this behavior is not handled automatically by
Agda\footnote{\url{https://agda.readthedocs.io/en/v2.6.1.1/language/cumulativity.html\#limitations}}.

To simulate the above behavior we define the \AgdaDatatype{Context} type
constructor class.
A context is essentially a functor which respects the universes structure.
Given a type from \AgdaDatatype{Setₙ} it lifts it to another type in the same
\AgdaDatatype{Setₙ}.
Furthermore, given a function between two data types in different universes it
lifts the function to a function between the lifted types i.e. between
universes.
An instances should satisfy the functors laws, even though they are not enforced
here.
Notice that \AgdaDatatype{Context} quantifies over arbitrary
\AgdaDatatype{Level}s $\ell$ and therefore is an element of \AgdaDatatype{Setω},
the universe, which is larger than all natural number indexed universes.
\AgdaDatatype{Setω} represents the end of Agda's universe hierarchy, i.e. there
are no universes indexed by larger ordinals and therefore there are some
restrictions on terms of this type.
In our case this should not be a problem, because we only parameterize over
contexts.

\begin{code}
record Context (F : ∀ {ℓ} → Set ℓ → Set ℓ) : Setω where
  field _<$>_ : ∀ {a b} {A : Set a} {B : Set b} → (A → B) → F A → F B
  _<$_ : ∀ {a b} {A : Set a} {B : Set b} → A → F B → F A
  a <$ mb = const a <$> mb
open Context ⦃...⦄
\end{code}
With the context in place we define the \AgdaDatatype{Syntax} type class by
\citeauthor{DBLP:conf/haskell/WuSH14}.
By generalizing to higher order abstract syntax it is possible to represent
computations in scope and continuations explicitly.
The order in which they are evaluated and therefore how an evaluation context
should be moved through the computation is a semantic question.
The type class explains how an arbitrary handler can be thread through an
effects syntax.
The first argument is the initial context.
Using \AgdaFunction{<\$} it is possible to move an arbitrary value or
computation into the context.
The second argument is a handler as defined by
\citeauthor{DBLP:conf/haskell/WuSH14}.
The handler takes a computation in a context and evaluates it.
The resulting computation has a different effect stack, usually it is the tail
of the given stack.
By partially evaluating the computation the context was moved through the
computation.
As a result the values are now lifted into the resulting context.
Using the initial context and the handler, the type class explains how an
arbitrary operation from the signature \AgdaArgument{E} is traversed.

Notice that the given operations contain computations of an arbitrary size.
Furthermore, the given handler works on computations of the same size.
This will be important in Section \ref{higher-order:limited-impl} when we define
handlers, which pass them self to \AgdaFunction{handle}.

\begin{code}
record Syntax (E : Effect) : Setω where
  field handle : ⦃ Context C ⦄ → C ⊤ →
          (∀ {X} → C (Prog effs′ X {i}) → Prog effs″ (C X)) →
          ⟦ E ⟧ (λ X → Prog effs′ X {i}) A → ⟦ E ⟧ (λ X → Prog effs″ X) (C A)
open Syntax ⦃...⦄
\end{code}
To finish the basic infrastructure we define two \AgdaDatatype{Syntax}
instances.
The instance for the empty signature \AgdaDatatype{Void} is trivial, because the
type of container extensions is empty.
Combined signatures are handled by inspecting the value, calling the
\AgdaFunction{handle} for one of the given signatures and injecting the result
in the combined signature.

\begin{code}
instance
  Void-Syntax : Syntax Void
  Syntax.handle Void-Syntax _ _ ()

  ⊕-syntax : ⦃ Syntax E ⦄ → ⦃ Syntax E′ ⦄ → Syntax (E ⊕ E′)
  Syntax.handle ⊕-syntax ctx hdl (inj₁ s , κ , σ) with handle ctx hdl (s , κ , σ)
  ... | s′ , κ′ , σ′ = (inj₁ s′) , κ′ , σ′
  Syntax.handle ⊕-syntax ctx hdl (inj₂ s , κ , σ) with handle ctx hdl (s , κ , σ)
  ... | s′ , κ′ , σ′ = (inj₂ s′) , κ′ , σ′
\end{code}


\subsection{Exceptions}
\label{higher-order:exceptions}

An an example for an effect in the higher order setting we define exceptions.

\paragraph{Syntax}
Exceptions support two operations, the usual algebraic operation
\AgdaFunction{throw} as well as the scoped operation \AgdaFunction{catch}.
The two operations are equivalent to the Haskell definition from Section
\ref{higher-order:syntax}.
\AgdaDatatype{throw} takes the thrown exception as an additional parameter.
\AgdaDatatype{catch}'s \AgdaField{Shape} stores the result type of the
computations in scope.

\begin{code}
data Excˢ (E : Set) : Set₁ where
  throwˢ  : (e : E)    → Excˢ E
  catchˢ  : (X : Set)  → Excˢ E
\end{code}
We use Bunkenburg's indexed bi-container~\cite{bunkenburg2019modeling}.
The extension of the container is equipped with two positions functions, one for
computations resulting in
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}
and one for computations in scope i.e. such resulting in computations of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{Y}
where \AgdaArgument{Y} is defined by the context.
Let us first consider the computations in scope.

\begin{code}
data ExcCatchᴾ (E X : Set) : Set where
  mainᵖ    : ExcCatchᴾ E X
  handleᵖ  : (e : E) → ExcCatchᴾ E X

Excᵖˣ : ∀ E → Excˢ E → Set
Excᵖˣ E (throwˢ e)  = ⊥
Excᵖˣ E (catchˢ X)  = ExcCatchᴾ E X

Excᶜ : ∀ E s → Excᵖˣ E s → Set
Excᶜ E (catchˢ X) mainᵖ        = X
Excᶜ E (catchˢ X) (handleᵖ e)  = X
\end{code}
\AgdaFunction{throw} has no computations in scope and therefore no positions.
\AgdaFunction{catch}'s positions are given by \AgdaDatatype{ExcCatchᴾ}.
The operation has two kinds of program in scope.
The first single program is given by \AgdaInductiveConstructor{mainᵖ}, the
program whose exceptions should be caught.
\AgdaInductiveConstructor{handleᵖ} provides a continuation for each exception,
it corresponds to the exception handler.
Both computations produce results of type \AgdaArgument{X}, which is expressed
using \AgdaFunction{Excᶜ}

Next we define the positions for the effects continuation, i.e the computations
producing values of type \AgdaArgument{A}.

\begin{code}
Excᵖ : ∀ E → Excˢ E → Set
Excᵖ E (throwˢ e)  = ⊥
Excᵖ E (catchˢ X)  = X
\end{code}
Again, \AgdaFunction{throw} has no continuations, because it produces no
results.
\AgdaFunction{catch} provides a continuation which processes the result of the
computations in scope, i.e. it provides a continuation for each value of
\AgdaArgument{X}.

Using the above definitions we define the \AgdaDatatype{Exc} effect.
Furthermore, we introduce pattern synonyms to easily pattern match on values of
the container extension in the handler.
\begin{code}
Exc : Set → Effect
Exc E = Excˢ E ◁ Excᵖ E + Excᵖˣ E / Excᶜ E

pattern Throw e      = impure (inj₁ (throwˢ e)  , _ ,  _)
pattern Catch κ σ    = impure (inj₁ (catchˢ _)  , κ ,  σ)
pattern Other s κ σ  = impure (inj₂ s           , κ ,  σ)
\end{code}
Lastly we define smart constructors for the operations.
Because \AgdaFunction{throw} has no continuations, we define the container
extensions as $\lambda ()$.
\AgdaFunction{catch} captures the program as well as the exception handler in
scope, therefore they are returned by \AgdaArgument{σ}.
The effects continuation \AgdaArgument{κ} is initially given by pure.
It is later extended using \AgdaFunction{>>=}.
This is analogous to the generic operations in the first order approach.

\begin{code}[hide]
infix 0 _catch_
\end{code}
\begin{code}
throw : ⦃ Exc B ∈ effs ⦄ → (e : B) → Prog effs A
throw e = op (throwˢ e , (λ()) , λ())

_catch_ : ⦃ Exc B ∈ effs ⦄ → Prog effs A → (B → Prog effs A) → Prog effs A
p catch h = op $ catchˢ _ , pure , λ{ mainᵖ → p ; (handleᵖ e) → h e }
\end{code}

\paragraph{Syntax}
Before we implement the handler we have to provide a \AgdaDatatype{Context}
instance for \AgdaArgument{E}\AgdaSpace{}\AgdaDatatype{⊎\_} to use
\AgdaFunction{handle} to traverse \AgdaInductiveConstructor{Other} operations.
The instance is nearly identical to the functor instance, except that the newly
constructed values maybe are element of another \AgdaDatatype{Set}.

\begin{AgdaAlign}
\begin{code}
instance
  _⊎-Context : ∀ {E : Set} → Context (E ⊎_)
  Context._<$>_ _⊎-Context f (inj₁ e) = inj₁ e
  Context._<$>_ _⊎-Context f (inj₂ x) = inj₂ (f x)
\end{code}
As explained above, the \AgdaDatatype{Syntax} instance is needed to thread the
handler  through the syntax of other effects i.e. the instance for
\AgdaDatatype{Exc} is not needed for the \AgdaDatatype{Exc} handler.
We still define a \AgdaDatatype{Syntax} instance for \AgdaDatatype{Exc} now to
explain the usual structure.

\begin{code}
  Exc-Syntax : ∀ {E} → Syntax (Exc E)
  Syntax.handle Exc-Syntax          _    _    (throwˢ e  , _  , _  ) = throwˢ e , (λ()) , λ()
  Syntax.handle Exc-Syntax {C = C}  ctx  hdl  (catchˢ X  , κ  , σ  ) = catchˢ (C X) ,
    (λ x         → hdl (κ              <$>  x    )) , λ where
    mainᵖ        → hdl (σ mainᵖ        <$   ctx  )
    (handleᵖ e)  → hdl (σ (handleᵖ e)  <$   ctx  )
\end{code}
\end{AgdaAlign}
The case for \AgdaInductiveConstructor{throwˢ} is trivial, because the operation
has no continuations, one which to evaluate the handler.
The case for \AgdaInductiveConstructor{catchˢ} is more complex.

The idea behind the \AgdaDatatype{Syntax} type class is to thread the handler
through the operations, i.e. to evaluate the syntax of another effect in all
captured subprograms, while context moves through the computation.
The given handler \AgdaArgument{hdl} is slightly different from the final
handler in that it only accepts computations inside its context.
This is needed to thread the handlers current state through the computation.
The \AgdaFunction{catch} operations is evaluated by evaluating the program in
the \AgdaInductiveConstructor{mainᵖ} position and in case of an exception
providing an alternative result using the program in the
\AgdaInductiveConstructor{handleᵖ} position and feeding the result in the
continuation.
Handlers for other effects should traverse the effect similarly.
Therefore, the intermediate result is lifted into the handlers context.
The effects continuation (the one producing a value of the actual result type
\AgdaArgument{A}) now takes an argument of type \AgdaArgument{C X} i.e. the
result of a program in scope inside the foreign handlers context.
By mapping \AgdaArgument{κ} over the given \AgdaArgument{x} the continuation is
applied to the argument \AgdaArgument{x} and continues inside its context.
This make sense, because the given value is either the result of the sucessfull
captured computation or the result of the exception handler.
For example, in case of threading \AgdaDatatype{Nondet} through exception
syntax the context is a list.
\AgdaArgument{κ} would continue on each result of the program in scope,
because \AgdaFunction{<\$>} applies the given function simply to each element of
the list.

Next we will look at the computations in scope i.e. the computations stored by
\AgdaArgument{σ}.
As in Chapter \ref{chapter:first-order} the handler should be evaluated on the
computation in scope in isolation and not reuse the previous state.
In the first order case this was accomplished by calling the handler again when
finding an opening scope delimiter.
To call the handler, the program, given by the functions \AgdaArgument{κ}
and \AgdaArgument{σ}, have to be inject into a context.
In case of \AgdaArgument{κ} we were given a context, now we have to use the
given context.
The given value \AgdaArgument{cxt} holds a value of type \AgdaDatatype{⊤} i.e.
no information just handler state.
\AgdaArgument{cxt} should be the initial handler context or state for the
handler.
Using \AgdaFunction{<\$} we can inject any computation into it.
Injecting a computation into \AgdaArgument{ctx} and calling \AgdaArgument{hdl}
should be the same as calling the actual handler for the effect on the
computation.

The cases for the three computations are identical to the ones presented by
\citeauthor{DBLP:conf/haskell/WuSH14}.
After evaluating the handler on the sub-trees, values are lifted into the
context, therefore the captured intermediate result type changes.
In Agda we have to manage the type explicitly.
In contrast to the Haskell implementation by
\citeauthor{DBLP:conf/haskell/WuSH14} we have to explicitly change the captured
type.
Using the curly brackets we access the hidden type constructor \AgdaArgument{C}
for the context and simply evaluate it on the given type.

\paragraph{Handler}
Lastly we define the handler for \AgdaDatatype{Exc}.
Notice that the handler takes a program of an arbitrary size
\AgdaArgument{i}.
This is needed to prove termination, because the handler itself is threaded
through the \AgdaInductiveConstructor{Other} operations using
\AgdaFunction{handle}.
To use \AgdaField{handle} we require a \AgdaDatatype{Syntax} instance for the
rest of the effect stack.
The cases for \AgdaInductiveConstructor{pure} and
\AgdaInductiveConstructor{Throw} are trivial.

\begin{code}
runExc : ⦃ Syntax (sum effs) ⦄ → Prog (Exc B ∷ effs) A {i} → Prog effs (B ⊎ A)
runExc (pure x)     = pure (inj₂ x)
runExc (Throw e)    = pure (inj₁ e)
\end{code}
To handle \AgdaInductiveConstructor{Catch} we first evaluate the operation in
scope by calling \AgdaFunction{runExc} on the program in the
\AgdaInductiveConstructor{mainᵖ} position.
Using \AgdaFunction{>>=} we can inspect the result and either call the rest of
the program \AgdaArgument{κ} with the result or the exception handler using
\AgdaInductiveConstructor{handleᵖ}.
In the latter case we again inspect the result and in case of a value also
continue with \AgdaArgument{κ}.
\begin{code}
runExc (Catch κ σ)  = runExc (σ mainᵖ) >>= λ where
  (inj₁ e) → runExc (σ (handleᵖ e)) >>= λ where
    (inj₁ e) → pure (inj₁ e)
    (inj₂ x) → runExc (κ x)
  (inj₂ x) → runExc (κ x)
\end{code}
Lastly we handle \AgdaInductiveConstructor{Other} operations.
As in Chapter \ref{chapter:first-order} we reconstruct the operation using
\AgdaInductiveConstructor{impure}.
Moving the handler along now requires us to use \AgdaFunction{handle}.
We call \AgdaFunction{handle} on the given value of the container extension,
constructed using \AgdaArgument{s}, \AgdaArgument{κ} and \AgdaArgument{σ}.
Notice that \AgdaInductiveConstructor{Other} hides the
\AgdaInductiveConstructor{inj₂}, therefore the newly constructed container
extension has a different type.
It is an element of the signature without the exception syntax.
\AgdaFunction{handle} requires two additional arguments, the initial context as
well has the handler.
The initial context is given by
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}\AgdaInductiveConstructor{tt}, i.e. a
successful result of type \AgdaDatatype{⊤}.
The handler has to evaluate \AgdaDatatype{Exc} syntax for a program in the
context.
We handle the two cases using \AgdaFunction{[\_,\_]}.
If the argument is already an exception we simply produce a
\AgdaInductiveConstructor{pure} program which produces the exception.
Otherwise it is a program, which we can evaluate using \AgdaFunction{runExc}.
Notice that the initial context always leads to the second case.
\begin{code}
runExc (Other s κ σ) = impure (handle (inj₂ tt) [ (λ x → pure (inj₁ x)) , runExc ] (s , κ , σ))
\end{code}
Even tough we pass \AgdaFunction{runExc} to \AgdaFunction{handle}, Agda accepts this
definition as terminating.
Agda can prove termination, because the argument is of an arbitrary size
\AgdaArgument{i}.
Therefore, the values produced by \AgdaArgument{κ} and \AgdaArgument{σ} have a
smaller size.
Note that in the definition of \AgdaFunction{handle} the size of the handler
argument is the same as the size of the last argument, i.e. the operation, which
is handled.
Therefore, the argument passed to the coproduct mediator, which calls
\AgdaFunction{runExc}, is smaller than the currently handled value.

\paragraph{Example}
Using the \AgdaDatatype{Exc} effect we can define simple programs, which
\AgdaFunction{throw} and \AgdaFunction{catch} exceptions.
The first function simply raises an exception.
\begin{code}
testExc : ⦃ Exc String ∈ effs ⦄ → Prog effs ℕ
testExc = pure 1 >> throw "Foo"
\end{code}
As expected, evaluating it yields the error message.
\begin{center}
\begin{code}[inline,hide]
runTestExc :
\end{code}
\begin{code}[inline]
 run (runExc testExc) ≡ inj₁ "Foo"
\end{code}
\begin{code}[inline,hide]
runTestExc = refl
\end{code}
\end{center}
The second function calls the first one, but catches the exception, returning an
alternative result.
\begin{code}
catchTestExc : ⦃ Exc String ∈ effs ⦄ → Prog effs ℕ
catchTestExc = testExc catch λ _ → pure 42
\end{code}
Evaluating the second function yields the value returned by the exception
handler.
\begin{center}
\begin{code}[inline,hide]
runCatchTestExc :
\end{code}
\begin{code}[inline]
 run (runExc catchTestExc) ≡ inj₂ 42
\end{code}
\begin{code}[inline,hide]
runCatchTestExc = refl
\end{code}
\end{center}


\subsection{Lifting First Order Syntax}
\label{higher-order:lifting}

\textcite{DBLP:conf/haskell/WuSH14} present a construction for lifting first
order syntax to the higher order setting.
A similar construction is possible with container representations.
In this section we present the corresponding construction and use it to
lift nondeterminism syntax into the higher order setting. 

Given the two fields of a normal container we construct an indexed bi-container.
The shapes and positions for \AgdaArgument{A} correspond exactly to the first
two arguments for the indexed bi-container.
The second postion type and the context are precisely the generalization from
the first-order to the higher-order setting.
Therefore, we simply use \AgdaDatatype{⊥} to ignore them.

We did not use the cumulativitiy flag to simplifiy this examplary implementation.
This simplified the earlier implementation, but forces us now to do some manual
lifting.
The \AgdaDatatype{Lift} data type is element of an arbitrary universe and stores
a value of an arbitrary type from a smaller universe.
Using \AgdaDatatype{Lift} we can pass the given shape type to the constructor.
To apply the position function we unwrap the lifted shape.

\begin{code}
_▷_ : (Shape : Set) → (Pos : Shape → Set) → Effect
S ▷ P = Lift _ S ◁ (λ (lift s) → P s) + (λ _ → ⊥) / λ _ ()
\end{code}
As shown by \textcite{DBLP:conf/haskell/WuSH14}, we can define a general
\AgdaDatatype{Syntax} instance for lifted first order syntax.
The second type of positions is empty, therefore we can omitt the definition of
\AgdaArgument{σ}.
Notice that this definition applies to all effects constructed using
\AgdaFunction{▷}.
Therefore, we avoid defining parts of the infrastructure for effects without
scoping operations.

\begin{code}
instance
  ▷-Syntax : ∀ {S P} → Syntax (S ▷ P)
  Syntax.handle ▷-Syntax ctx hdl (s , κ , σ) = s , (λ p → hdl (κ p <$ ctx)) , λ()
\end{code}

\paragraph{Example: Nondet}
Using the above function and \AgdaKeyword{instance} we can lift the
nondeterminism syntax from Chapter \ref{chapter:first-order} to the higher-order
setting.

\begin{code}[hide]
data Nondetˢ : Set where ⁇ˢ failˢ : Nondetˢ
\end{code}
\begin{code}
Nondet : Effect
Nondet = Nondetˢ ▷ λ where failˢ → ⊥ ; ⁇ˢ → Bool

pattern Fail      = impure (inj₁ (lift failˢ)  , _ , _)
pattern Choice κ  = impure (inj₁ (lift ⁇ˢ)     , κ , _)
\end{code}
We still have to define a \AgdaDatatype{Context} instance and a custom handler
for \AgdaDatatype{Nondet}, because we have to define the interaction with other
higher order syntax.
Again, the \AgdaDatatype{Context} instance corresponds to the normal functor
instance.

\begin{code}
instance
  List-Context : Context List
  Context._<$>_ List-Context f []        = []
  Context._<$>_ List-Context f (x ∷ xs)  = f x ∷ (f <$> xs)
\end{code}
The first three cases of the handler are identical to the implementation in
Section \ref{nondeterminism}.
The interesting new case is the one for \AgdaInductiveConstructor{Other} syntax.
We must use use \AgdaFunction{handle} to traverse the arbitrary operation.
Analougous to exceptions we evaluate \AgdaFunction{handle} on the reconstructed,
given operation.
The initial context have to be signleton lists, because empty lists would
stop the compuation, while lists with two or more elements would duplicate
parts of the program.

\AgdaFunction{hdl} has to map from a \AgdaDatatype{List} of program with
\AgdaDatatype{Nondet} syntax to a program without \AgdaDatatype{Nondet}
syntax and a \AgdaDatatype{List} as carrier type.
Consider the \AgdaDatatype{Syntax} instance for \AgdaDatatype{Exc}, given in
Section \ref{higher-order:exceptions}.
The two program in scope use the inital context, i.e. the given list is a
singleton.
The continuation uses \AgdaFunction{<\$>} to apply the rest of the program to
the given results of the compuatation in scope and evaluates them using
\AgdaFunction{hdl}.
Conceptually, the argument of \AgdaFunction{hdl} corresponds to the
programs, which prodce results for each result of some earlier compuatation.
We therefore use the obvious (and usually given) implementation of the
\AgdaFunction{hdl} function i.e. we sequence the computations from left to right
and concat the results.

\begin{code}
runNondet : ⦃ Syntax (sum effs) ⦄ → Prog (Nondet ∷ effs) A {i} → Prog effs (List A)
runNondet (pure x)       = pure (x ∷ [])
runNondet Fail           = pure []
runNondet (Choice κ)     = ⦇ runNondet (κ true) ++ runNondet (κ false) ⦈
runNondet (Other s κ σ)  = impure (handle (tt ∷ []) hdl (s , κ , σ))
  where  hdl : ⦃ Syntax (sum effs) ⦄ →
           List (Prog (Nondet ∷ effs) B {i}) → Prog effs (List B)
         hdl []          = pure []
         hdl (mx ∷ mxs)  = ⦇ runNondet mx ++ hdl mxs ⦈
\end{code}
Notice that the argument of the handler as well as the \AgdaFunction{hdl}
function are of size \AgdaArgument{i} to guaranty termination, following the
pattern explained in Section \ref{higher-order:exceptions}.

\begin{code}
_⁇_ : ⦃ Nondet ∈ effs ⦄ → Prog effs A → Prog effs A → Prog effs A
p ⁇ q = op (lift ⁇ˢ , (if_then p else q) , λ())
\end{code}

\paragraph{Ordering of Operations}
It is important to note that the above handler induces unexpected semantics when
combined with certain other effects.
Interpreting \AgdaDatatype{Nondet} syntax yields the results in depth first
ordering.

If a part of a nondeterministic program is captured in a scope the order of
operations changes.
The program in scope is evaluated, yielding its results in depth first ordering.
Afterwards, using \AgdaFunction{hdl} the continuation is evaluated on each
intermediate result and the final results are concatenated.
The results are in the expected depth first order, but the operations not.
The order of operations is introduced by \AgdaFunction{>>=}.
A scoping operation is evaluated by first evaluating the part of the computation
in scope and afterwards the continuations outside the scope.
Therefore the unevaluated operations are now also in this order.
The potential unexpected semantics of this implementation is that introducing a
semantically irrelevant scoping operation (e.g. \texttt{local id}) influences
the ordering of operations of other globally evaluated effects.
This behavior is known, because it also occurs in some Haskell implementations
of scoped
effects\footnote{https://github.com/polysemy-research/polysemy/issues/246}.

Encountering the above behavior is quite uncommon, because the program has to
evaluate a scoping operation globally over a nondeterministic program, while
simultaneously using global operations whose ordering can be observed.
Most effects only provide one of the two.
% Furthermore, evaluating effects globally over \AgdaDatatype{Nondet} inherently
% depends on the ordering of branches, which is precisely what nondeterminism
% abstracts away.
The most common examples are global state to collect results, global writer to
log and global partiality to stop all branches, which do not encounter the above
behavior.
When catching global exceptions over a nondeterministic program the above
behavior seems more reasonable.
More complex semantics (e.g. leaving and reentering the scoped computation) are
conceivable, but not captured by the standard representation of higher order
syntax.


\subsection{Modular Higher Order Effects}

In the last to sections we presented effects in isolation.
Similar to the combined semantics described in Section
\ref{first-order:combined-effects} we can induced different semantics by
reordering the handlers.
Consider the following program, which chooses between a
\AgdaInductiveConstructor{pure} value and an exception.

\begin{code}
throwNondet : ⦃ Nondet ∈ effs ⦄ → ⦃ Exc ⊤ ∈ effs ⦄ → Prog effs ℕ
throwNondet = pure 42 ⁇ throw tt
\end{code}
Evaluating \AgdaDatatype{Exc} first runs it locally in each branch of the
nondeterministic computation i.e. each branch either returns a result or an
exception. 
\begin{center}
\begin{code}[inline,hide]
localExc : 
\end{code}
\begin{code}[inline]
 run (runNondet (runExc throwNondet)) ≡ inj₂ 42 ∷ inj₁ tt ∷ []
\end{code}
\begin{code}[inline,hide]
localExc = refl
\end{code}
\end{center}
Evaluating \AgdaDatatype{Exc} last evaluates it globally.
Therefore, throwing an exception stops the current, by the \AgdaDatatype{Nondet}
handler induced, ordered evaluation of nondeterministic branches and just
returns the exception.
\begin{center}
\begin{code}[inline,hide]
globalExc : 
\end{code}
\begin{code}[inline]
 run (runExc (runNondet throwNondet)) ≡ inj₁ tt
\end{code}
\begin{code}[inline,hide]
globalExc = refl
\end{code}
\end{center}


\section{Results}

In this chapter, we tired to implement scoped effects a higher order
syntax representation approach by \textcite{DBLP:conf/haskell/WuSH14}.
We continued Bunkeburg's~\cite{bunkenburg2019modeling} investigation of this
approach and uncovered a deep seated problem while implementing it in Agda,
which arises due to more restrictive requirements for programs compared to
Haskell.
The problem occurs because we have to work in a consistent hierarchy of
universes to preserve Agda's consistency.
When using higher order syntax, computations potentially have to store the type
of data they produce and therefore are larger than the data.
This prevents scoping operations from capturing other computations, without
switching to a larger type of computations.
This specifically includes effectful data structures, which are needed for the
implementation of deep effects.
In case of deep sharing this leads to a dependence between universe levels and
the depth of data structures.
We discussed two general approaches to avoid increasing universe levels when
working with effectful data.
However, both of them require a more complex representation for either types or
data, probably leading to a more complex implementations, which is harder to
work with in real programs.

Because deep effects are an uncommon requirement, we still presented key points
of a limited implementation.
Although, we removed deep effects as a requirement, we still had to work with
different universe levels, while implementing the \AgdaDatatype{Syntax}
instances.
This lead to manual lifting between universes and structures involving
\AgdaDatatype{Setω}, which should generally be avoided.
A level polymorphic implementation, needed for increasing the size of the
computation types, uses both constructs more frequently.
