\begin{code}[hide]
{-# OPTIONS --overlapping-instances #-}
module FirstOrder where

open import Level using (Level; suc; zero; _⊔_)
open import Function
open import Size using (Size; ↑_)

open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Empty using (⊥)
open import Data.List using (List; []; _∷_; _++_; foldr)
open import Data.List.Properties using (++-identityʳ)
open import Data.Nat using (ℕ; _+_)
open import Data.Nat.Properties using (<-strictTotalOrder)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.Product using (Σ-syntax; _×_; _,_; proj₂)
open import Data.Product.Relation.Binary.Lex.Strict using (×-strictTotalOrder)
open import Data.Sum using (_⊎_; [_,_]; inj₁; inj₂)
open import Data.Unit using (⊤; tt)

order = ×-strictTotalOrder (×-strictTotalOrder <-strictTotalOrder <-strictTotalOrder) <-strictTotalOrder
open import Data.Tree.AVL.Map order using (Map; empty; insert; lookup)

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl; cong; sym)
open Eq.≡-Reasoning using (begin_; _≡⟨⟩_; step-≡; _∎)

postulate
  extensionality : ∀ {ℓ ℓ′ : Level} {A : Set ℓ} {B : A → Set ℓ′} {f g : (x : A) → B x}
      → (∀ (x : A) → f x ≡ g x) → f ≡ g

record Container : Set₁ where
  constructor _▷_
  field
    Shape : Set
    Pos : Shape → Set
open Container public

⟦_⟧ : {ℓ : Level} → Container → Set ℓ → Set ℓ
⟦ S ▷ P ⟧ A = Σ[ s ∈ S ] (P s → A)
\end{code}

In this chapter we present our first implementation of algebraic effects in Agda.
The implementation uses a traditional approach, i.e. it represents effects as
functors and uses the free monad, as described in Section
\ref{preliminaries:free-monad}.
We focus on implementation details specific to Agda, for example termination and
positivity checks.

In Section \ref{first-order:functor} we introduce our general infrastructure for
modular effects, which provides a similar interface to the one by
\textcite{DBLP:conf/haskell/WuSH14}.
The basic idea of operating on lists of effects is similar to the Idris effect
library by \textcite{DBLP:conf/icfp/Brady13}.
In Section \ref{first-order:effects-and-handlers} we implement some of the
examples by \textcite{DBLP:conf/haskell/WuSH14} to explain the general
construction of effects and handlers using this approach.
In Section \ref{fist-order:scoped-effects} we implement scoped effects using
explicit scoped delimiters as described by \textcite{DBLP:conf/haskell/WuSH14}.
To define handlers for effects with and without scopes we use a general
construction using sized types to prove termination.
This allows us to conveniently implement handlers in Agda, i.e. without changing
the structure of handlers to prove termination.
As a more complex example, we implement the sharing handler by
\textcite{bunkenburg2019modeling}, providing a way of simulating call-time
choice semantics in Agda.


\section{Functors {\`{a}} la Carte}
\label{first-order:functor}

When modelling effects each functor represents the signature, i.e. the operations for
an effect.
Theoretically, it is possible to represent each operation as a functor.
Usually, operations which are handled together are implemented as a single functor.
For containers each shape constructor corresponds to an operation symbol and the
type of position for a shape corresponds to the arity set for the operation.
The additional parameter of an operation is embedded in the shape.
The free monad over a container describes a program using the effect's syntax,
i.e. it is the free model for the algebraic theory without the equations.
To combine the syntax of multiple effects we can combine the underlying
functors because the free monad preserves coproducts\footnote{This follows from
the facts that \texttt{Free} is the left half of a free-forgetful adjunction and
that all left-adjoints preserve colimits.}.
This method of modularization of syntax was presented by
\textcite{DBLP:journals/jfp/Swierstra08}.

The approach for modularization functors described by
\textcite{DBLP:conf/haskell/WuSH14} is based on
\citetitle{DBLP:journals/jfp/Swierstra08} by
\textcite{DBLP:journals/jfp/Swierstra08}.
The functor coproduct is modelled as the data type
\mintinline[breaklines]{haskell}{data (f :+: g) a = Inl (f a) | Inr (g a)},
which is again a \texttt{Functor} in \texttt{a}.
In Section \ref{preliminaries:free-monad}, we defined the free monad over
a strictly positive functor, which was represented by a
\AgdaDatatype{Container}.
We could use a similar data type to combine the extensions of two containers,
but we would lose the advantages of containers, i.e. that container extension is
a strictly positive functor.
Containers are closed under multiple operations, coproducts being one of
them~\cite{DBLP:conf/fossacs/AbbottAG03}.
Therefore, we can combine two container functors by combining the underlying
containers.
The coproduct of two containers $F$ and $G$ is the container whose
\AgdaField{Shape} is the disjoint union of $F$'s and $G$'s shapes and whose
position function \AgdaField{Pos} is given by the coproduct
mediator\footnote{The function \AgdaFunction{[\_,\_]} corresponds to the Haskell
function \mintinline{haskell}{either :: (a -> c) -> (b -> c) -> Either a b ->
c}.} of $F$'s and $G$'s position functions.

\begin{code}[hide]
infixr 1 _⊕_
\end{code}
\begin{code}
_⊕_ : Container → Container → Container
(Shape₁ ▷ Pos₁) ⊕ (Shape₂ ▷ Pos₂) = (Shape₁ ⊎ Shape₂) ▷ [ Pos₁ , Pos₂ ]
\end{code}
The functor represented by the coproduct of two containers is isomorphic to the
functor coproduct of their representations.
The container without shapes, usually called \AgdaDatatype{Void}, is the neutral
element for the coproduct of containers.
This allows us to define $n$-ary coproducts for containers.

\begin{code}
Void : Container
Void = ⊥ ▷ λ()

sum : List Container → Container
sum = foldr _⊕_ Void
\end{code}
To generically work with arbitrary coproducts of functors, we define two utility
functions.
Given a value $x:A$ we want to be able to inject it into any coproduct
mentioning $A$.
Given any coproduct mentioning $A$ we want to be able to project a value of
type $A$ from the coproduct, if the coproduct was constructed using a value of
type $A$.
Therefore, we produce a value of type
\AgdaDatatype{Maybe}\AgdaSpace{}\AgdaArgument{A} and return
\AgdaInductiveConstructor{nothing} in case the coproduct was constructed
differently.

In the
\citetitle{DBLP:journals/jfp/Swierstra08}~\cite{DBLP:journals/jfp/Swierstra08}
approach the type class \texttt{:<:} is introduced.
\texttt{:<:} relates a functor to a coproduct of functors, marking it as an
option in the coproduct.
\texttt{:<:}'s functions can be used to inject or potentially extract values
from a coproduct.
The two instances for \texttt{:<:} mark $F$ as an element of the coproduct if
it is on the left-hand side of the coproduct (in the head) or if it is already
in the right-hand side (in the tail).
Usually one would add a third instances \texttt{f :<: f}, relating \texttt{f} to
itself, but this instance is not needed if the last functor is always
\texttt{Void}.

\begin{minted}{haskell}
     class (Syntax sub, Syntax sup) => sub :<: sup where
       inj :: sub m a -> sup m a
       prj :: sup m a -> Maybe (sub m a)

     instance {-# OVERLAPPABLE #-} (Syntax f, Syntax g) => f :<: (f :+: g) where
       inj = Inl
       prj (Inl a) = Just a
       prj _       = Nothing

     instance {-# OVERLAPPABLE #-} (Syntax h, f :<: g) => f :<: (h :+: g) where
       inj = Inr . inj
       prj (Inr ga) = prj ga
       prj _        = Nothing
\end{minted}
The two instances overlap, resulting in possible slower instance resolution.
Furthermore, \texttt{:+:} is assumed to be right associative and only to be
used in a right associative way to avoid backtracking.
Because in Agda the result of \AgdaFunction{\_⊕\_} is another container, not
just a value of a simple data type, instance resolution using
\AgdaFunction{\_⊕\_} is not as straight forward as in Haskell and in some cases
slow\footnote{We encountered cases where type checking of overlapping instances
  involving \AgdaFunction{\_⊕\_} did not seem to terminate.}.

Instead, we used an similar approach similar to the Idris effect library
by \textcite{DBLP:conf/icfp/Brady13}.
The free monad is not parameterised over a single container, but a list
\AgdaArgument{ops} of containers.
This has the benefit that we cannot associate coproducts to the left by
accident.
The elements of the list are combined later using \AgdaFunction{sum}.
To track which functors are part of the coproduct we introduce the new type
\AgdaDatatype{\_∈\_}.

\begin{code}[hide]
infix 4 _∈_
\end{code}
\begin{code}
data _∈_ {ℓ : Level} {A : Set ℓ} (x : A) : List A → Set ℓ where
  instance
    here   : ∀ {xs} → x ∈ x ∷ xs
    there  : ∀ {y xs} → ⦃ x ∈ xs ⦄ → x ∈ y ∷ xs
\end{code}
The type
\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{∈}\AgdaSpace{}\AgdaArgument{xs}
represents the proposition\footnote{This proposition is just a special case of
  the \AgdaDatatype{Any} proposition on \AgdaDatatype{List}s.
  For simplicity, we implement the proposition here directly.
  Types like \AgdaDatatype{\_∈\_} are an example of a common pattern in
  dependently typed languages called \textit{view}.
  The purpose view type is just to pattern match on its values, to reveal more
  information about its indices~\cite{DBLP:conf/afp/Norell08}.}
that \AgdaArgument{x} is an element of \AgdaArgument{xs}.
The two constructors can be read as inference rules.
One can always construct a proof that \AgdaArgument{x} is in a list with
\AgdaArgument{x} in its head and given a proof that
\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{∈}\AgdaSpace{}\AgdaArgument{xs}
one can construct a proof that \AgdaArgument{x} is also in the extended list
\AgdaArgument{y}\AgdaSpace{}\AgdaInductiveConstructor{∷}\AgdaSpace{}\AgdaArgument{xs}.
The \AgdaKeyword{instance} keyword marks the two constructors as possible
solution for instance arguments.
Instance arguments are special hidden arguments which are denoted using
$\lBrace$ and $\rBrace$.
Instances and instance arguments are resolved using a special instance
resolution algorithm and can be used similar to Haskell's type classes
and type class constraints.

The two instances still overlap resulting in a potentially exponential slowdown
in instance resolution\footnote{\url{https://agda.readthedocs.io/en/v2.6.1.1/language/instance-arguments.html\#overlapping-instances}}.
Using Agda's internal instance resolution can be avoided by using a
tactic to infer \AgdaDatatype{\_∈\_} arguments.
For simplicity the following code will still use instance arguments.
This version can easily be adapted to one using macros, by replacing the
instance arguments with hidden ones with \AgdaKeyword{tactic} annotations.
The repository contains an implementation using \AgdaKeyword{tactic}s, based on
the work by Norell.

Using this proposition we can define functions for injection into and projection
out of coproducts.

\begin{code}
inject : ∀ {C ops ℓ} {A : Set ℓ} → C ∈ ops → ⟦ C ⟧ A → ⟦ sum ops ⟧ A
inject here           (s , pf)  = (inj₁ s) , pf
inject (there ⦃ p ⦄)  prog      with inject p prog
... | s , pf = (inj₂ s) , pf

project : ∀ {C ops ℓ} {A : Set ℓ} → C ∈ ops → ⟦ sum ops ⟧ A → Maybe (⟦ C ⟧ A)
project here           (inj₁ s  , pf  )  = just (s , pf)
project here           (inj₂ _  , _   )  = nothing
project there          (inj₁ _  , _   )  = nothing
project (there ⦃ p ⦄)  (inj₂ s  , pf  )  = project p (s , pf)
\end{code}
Both \AgdaFunction{inject} and \AgdaFunction{project} require a proof that
specific effect is an element of the list used to construct the coproduct.

Let us consider \AgdaFunction{inject} first.
By pattern matching on the evidence we acquire more information about the type
\AgdaFunction{sum}\AgdaSpace{}\AgdaArgument{ops}.
In case of \AgdaInductiveConstructor{here} we know that \AgdaArgument{C} is in
the head of the list of containers.
Because the return type is constructed using \AgdaFunction{sum} over the given
list, we know that the given value
\AgdaArgument{s}\AgdaSpace{}\AgdaInductiveConstructor{,}\AgdaSpace{}\AgdaArgument{pf}
has the same type as the left alternative in the returned coproduct.
In case of \AgdaInductiveConstructor{there} we obtain a proof that the container
is in the tail of the list, which we use to make a recursive call.
The \AgdaKeyword{with} keyword allows us to call a function and add its result
to the left-hand side of our function equation. % footnote with McBrides paper
                                % ``The view from the left'' + dependent pattern matching?
By pattern matching on and repackaging the result we obtain a value of the
correct type.

\AgdaFunction{project} functions similarly.
By pattern matching on the proof we either know that the value we found has
the correct type or we obtain a proof for the tail of the list, allowing us to
either make a recursive call or stop the search.
Notice that in both cases we do not handle cases related to the empty list,
because it is impossible to prove that the empty list has a member.


\subsection{The Free Monad for Effect Handling}
\label{first-order:free-monad}

Using the coproduct machinery we can now define a version of the free monad,
suitable for working with effects.
In contrast to our first definition in section \ref{preliminaries:free-monad},
this version is parameterized over a list of containers.
In the \AgdaInductiveConstructor{impure} constructor the containers are combined
using \AgdaFunction{sum}.
The parameterization over a list ensures that the containers are not combined
prematurely.
We could store a proof that some effect \AgdaArgument{E} is an element of
\AgdaArgument{effs} directly.
This would allow us to use \AgdaArgument{E} directly, allowing us to omit the
\AgdaFunction{sum}, but also raise the universe level of \AgdaDatatype{Free}.

\begin{code}
data Free (ops : List Container) (A : Set) : {Size} → Set where
  pure    : ∀ {i} → A → Free ops A {i}
  impure  : ∀ {i} → ⟦ sum ops ⟧ (Free ops A {i}) → Free ops A {↑ i}
\end{code}
The free monad is indexed over an argument of type \AgdaDatatype{Size}.
We follow the pattern described in section \ref{preliminaries:sized-types}, to
annotate the data type.
\AgdaInductiveConstructor{pure} values have an arbitrary size.
When constructing an \AgdaInductiveConstructor{impure} value, the new value is
strictly larger than the ones produced by the container's position function.
Therefore, a calculation is larger than its continuations or a computation is
finite.
Using the annotation it is possible to prove that functions preserve or decrease
the size of a computation and therefore that complex recursive functions
terminate.

Next we define utility functions for working with the free monad.
\AgdaFunction{inj} and \AgdaFunction{prj} provide the same functionality as the
ones used by \textcite{DBLP:conf/haskell/WuSH14}.
\AgdaFunction{inj} allows injecting syntax into a program whose signature allows
the operation.
\AgdaFunction{prj} allows to inspect the next operation of a
program, restricted to the signature for a specific effect.
Furthermore, we add the functions \AgdaFunction{op} and \AgdaFunction{upcast}.

Writing operations with explicit continuations is unintuitive.
Furthermore, \AgdaFunction{>>=} and \AgdaKeyword{do}-notation provide a more
convenient syntax for extending the continuation.
\AgdaFunction{op} generates the \textit{generic operation} for any operation
symbol.
The generic operation for $\mathrm{op} : P \leadsto A$ is the operation with
\AgdaInductiveConstructor{pure} as continuation.
Therefore, it is a function of type $P \rightarrow \mathrm{Free}_T(A)$,
justifying the $\leadsto$-notation.

\AgdaFunction{upcast} transforms a program using any signature to one using a
larger signature.
Notice that \AgdaFunction{upcast} preserves the size of its input, because it
just traverses the tree and repackages the contents.
\AgdaFunction{prj} decreases the input of its argument by one, because it
deconstructs the root of the given tree.
These size preserving functions are essential when we later define handlers.

\begin{code}
inj : ∀ {C ops A} → ⦃ C ∈ ops ⦄ → ⟦ C ⟧ (Free ops A) → Free ops A
inj ⦃ p ⦄ = impure ∘ inject p

prj : ∀ {C ops A i} → ⦃ C ∈ ops ⦄ → Free ops A {↑ i} → Maybe (⟦ C ⟧ (Free ops A {i}))
prj ⦃ p ⦄ (pure x)    = nothing
prj ⦃ p ⦄ (impure x)  = project p x

op : ∀ {C ops} → ⦃ C ∈ ops ⦄ → (s : Shape C) → Free ops (Pos C s)
op s = inj (s , pure)

upcast : ∀ {C ops A i} → Free ops A {i} → Free (C ∷ ops) A {i}
upcast (pure x) = pure x
upcast (impure (s , κ)) = impure (inj₂ s , upcast ∘ κ)
\end{code}
Next we define the basic monadic operations for the above monad.
Usually \AgdaFunction{>>=} and \AgdaFunction{return} would be enough to define
all the other functions, but \AgdaFunction{>>=} is not size preserving, while
some other functions can be defined such that they are.
For example, later we rely on the fact that \AgdaFunction{<\$>} preserves
the size of its argument.
Consider the following definition of \AgdaFunction{fmap} for the free
monad\footnote{in the following code $A$, $B$ and $C$ are arbitrary types}.

\begin{code}[hide]
variable
  ℓᵃ ℓᵇ ℓᶜ : Level
  i : Size
  A : Set ℓᵃ
  B : Set ℓᵇ
  C : Set ℓᶜ
  ops : List Container

infixl 1 _>>=_ _>>_
infixl 4 _<$>_ _<*>_
\end{code}
\begin{code}
fmap _<$>_ : {F : List Container} {i : Size} → (A → B) → Free F A {i} → Free F B {i}
f <$> pure x           = pure (f x)
f <$> impure (s , pf)  = impure (s , (f <$>_) ∘ pf)

fmap = _<$>_
\end{code}
\AgdaFunction{fmap} applies the given function \AgdaArgument{f} to the values
stored in the \AgdaInductiveConstructor{pure} leafs.
The height of the tree is left unchanged.
This fact is witnessed by the same index \AgdaArgument{i} on the argument and
return type.

In contrast to \AgdaFunction{fmap}, \AgdaFunction{>>=} does not preserve the
size.
\AgdaFunction{>>=} replaces every \AgdaInductiveConstructor{pure} leaf with a
subtree, which is generated from the stored value.
The resulting tree is therefore at least as high as the given one.
Because there is no addition for sized types the only correct size estimate for
the returned value is unbounded (\AgdaInductiveConstructor{∞}).
This means that by using \AgdaFunction{>>=} on a value we lose our size
estimate.
This is a problem in recursive functions, because in terms of termination
checking it renders the annotation useless.
For later programs using effects this is not a problem, because they should not rely
on the size annotation of the free monad, because they should not recurse on a
value of type \AgdaDatatype{Free}.
The return type is not explicitly indexed, because the compiler correctly
infers \AgdaInductiveConstructor{∞}.

\begin{code}
_>>=_ : ∀ {ops} → Free ops A {i} → (A → Free ops B) → Free ops B
pure x           >>= k = k x
impure (s , pf)  >>= k = impure (s , (_>>= k) ∘ pf)

_>>_ : ∀ {ops} → Free ops A {i} → Free ops B → Free ops B
ma >> mb = ma >>= λ _ → mb
\end{code}
To complete our basic set of monadic functions we also define \AgdaFunction{ap}.

\begin{code}
_<*>_ : ∀ {ops} → Free ops (A → B) → Free ops A → Free ops B
pure f           <*> ma = f <$> ma
impure (s , pf)  <*> ma = impure (s , (_<*> ma) ∘ pf)
\end{code}

\subsection{Properties}
\label{first-order:free-monad:properties}

The definition of the free monad from section \ref{first-order:free-monad} is a
functor because it satisfies the two functor laws.
The two laws state that the lifting of functions via \AgdaFunction{fmap}
preserves the identity and the composition of functions.

Both properties are proven by structural induction over the free monad.
Let us consider the first proof.
It is written using chain reasoning operators~\cite{norell:thesis} to display
the general structure of the later proofs.
The operators provide a convenient way of writing down transitive equalities.
If the equality of two terms is not proven by \AgdaInductiveConstructor{refl},
we use \AgdaFunction{\_≡⟨\_⟩\_}, which allows us to give a proof of their
equality as second argument.
In the definition of \AgdaFunction{<\$>}, in the case for
\AgdaInductiveConstructor{pure} the given function is simply applied to the
stored value.
Therefore, the base case is proven by \AgdaInductiveConstructor{refl}.
In the induction step we reach a point were we have to show the equivalence of
the two continuations.
Using \AgdaFunction{cong} we reduce the equality on the whole terms to the
equality on the continuations.
Next we invoke \AgdaFunction{extensionality} to show point-wise equivalence.
This equivalence is exactly the induction hypothesis, which we obtain using a
recursive call.

Because all steps using \AgdaFunction{≡⟨⟩} are proven by
\AgdaInductiveConstructor{refl}, they can be omitted.
The other proofs follow the same pattern and therefore are written more concise.

\begin{code}[number=fmap-id]
fmap-id : (p : Free ops A) → fmap id p ≡ p
fmap-id (pure x)           = refl
fmap-id (impure (s , pf))  = begin
  fmap id (impure (s , pf))          ≡⟨⟩ -- definition of fmap
  impure (s , fmap id ∘ pf)          ≡⟨⟩ -- definition of ∘
  impure (s , λ p → fmap id (pf p))  ≡⟨ cong (λ t → impure (s , t))
                                         (extensionality λ p → fmap-id (pf p)) ⟩
  impure (s , λ p → pf p)            ≡⟨⟩ -- η-conversion
  impure (s , pf)                    ∎
\end{code}
\begin{code}[number=fmap-comp]
fmap-∘ : ∀ (f : B → C) (g : A → B) (p : Free ops A) →
  fmap (f ∘ g) p ≡ (fmap f ∘ fmap g) p
fmap-∘ f g (pure x)           = refl
fmap-∘ f g (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (fmap-∘ f g ∘ pf))
\end{code}
Later we will need the interchange law for applicative functors.
The law essentially allows us to swap the arguments of \AgdaFunction{<*>} if one
of the is \AgdaInductiveConstructor{pure}.
Because \AgdaFunction{<*>} is defined in terms of \AgdaFunction{<\$>}, it allows
us to reduce some \AgdaFunction{<*>} calls to \AgdaFunction{<\$>}.

\begin{code}[number=ap-interchange]
interchange : ∀ a (f : Free ops (A → B)) →
  (f <*> pure a) ≡ (pure (_$ a) <*> f)
interchange a (pure f)          = refl
interchange a (impure (s , κ))  = cong (impure ∘ (s ,_)) (extensionality (interchange a ∘ κ))
\end{code}
This definition of the free monad also satisfies the three monad laws.
Written using the Kleisli composition
(\AgdaArgument{f}\AgdaSpace{}\AgdaFunction{>=>}\AgdaSpace{}\AgdaArgument{g}$\,=$
\AgdaArgument{g}\AgdaSpace{}\AgdaFunction{∘}\AgdaSpace{}$($\AgdaFunction{\_}\AgdaFunction{>>=}\AgdaSpace{}\AgdaArgument{f}$)$)
they reduce to the laws for morphism composition in a category, i.e.
\AgdaInductiveConstructor{pure} is the left and right identity for the
associative composition.
We are more interested in this formulation using \AgdaFunction{>>=}, because it
is the one occurring more directly in programs.

\begin{code}[number=bind-ident-left]
bind-identˡ : ∀ {ops} (f : A → Free ops B) (x : A) → (pure x >>= f) ≡ f x
bind-identˡ f x = refl
\end{code}
\begin{code}[number=bind-ident-right]
bind-identʳ : ∀ {ops} (x : Free ops A) → (x >>= pure) ≡ x
bind-identʳ (pure x)           = refl
bind-identʳ (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (bind-identʳ ∘ pf))
\end{code}
\begin{code}[number=bind-assoc]
bind-assoc : ∀ {ops} (f : A → Free ops B) (g : B → Free ops C) (p : Free ops A) →
  ((p >>= f) >>= g) ≡ (p >>= (λ x → f x >>= g)) -- inner parens can be omitted
bind-assoc f g (pure x)           = refl
bind-assoc f g (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (bind-assoc f g ∘ pf))
\end{code}


\section{Implementing Algebraic Effects and Handlers}
\label{first-order:effects-and-handlers}

In section \ref{preliminaries:handler} we introduced effect handlers more
formally.
In this section we implement algebraic effect and their handlers in Agda.

All handlers in the following sections have the same basic structure.
They take a program, a variable of type
\AgdaDatatype{Free}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A},
where the head of \AgdaArgument{C} is the effect interpreted by the handler.
Each handler produces a program without the interpreted syntax, i.e. just the
tail of \AgdaArgument{C} in its effect stack.
Furthermore, they potentially modify the type \AgdaArgument{A} to one modelling
the result of the effect.
They transform an impure computation partially to a pure one.
By interpreting the syntax of an effect (mapping to a model for the theory) the
handler defines the semantics for the effect's syntax.
For example, a handler for exceptions removes exception syntax and transforms a
program producing a value of type \AgdaArgument{A} to one producing a value of
type
\AgdaArgument{E}\AgdaSpace{}\AgdaFunction{⊎}\AgdaSpace{}\AgdaArgument{A},
either an exception or a result.
Internally the handler maps the \AgdaInductiveConstructor{impure}
\AgdaFunction{throw} operation to a \AgdaInductiveConstructor{pure}
computations, witch simply yields the exception inside an either monad.
Some later handlers will also modify syntax of other effects.
These handlers are usually called \textit{non-orthogonal handlers}.

A simple but important handler is the one handling the empty effect stack and
therefore the \AgdaDatatype{Void} effect.
A program containing just \AgdaDatatype{Void} syntax contains no
\AgdaInductiveConstructor{impure} constructors, because \AgdaDatatype{Void} has
no operations, because its \AgdaField{Shape} type has no constructors.
Pattern matching on the impure constructor yields $()$.
The program does not call \AgdaInductiveConstructor{impure} operations and
always yields a value of type \AgdaArgument{A}.
The handler for \AgdaDatatype{Void} is important, because it can be used to
escape the \AgdaDatatype{Free} context after all other effects have been
handled.

\begin{code}
run : Free [] A → A
run (pure x) = x
\end{code}
The following two sections describe the implementation of handlers for
\AgdaDatatype{State} and \AgdaDatatype{Nondeterminism}.
By means of examples, they explain the construction of handlers as well as
lay groundwork for more complex handlers.


\subsection{Nondeterministic Choice}
\label{nondeterminism}

The nondeterminism effect has two operations \AgdaFunction{⁇} and
\AgdaFunction{fail}.
\AgdaFunction{⁇} introduces a nondeterministic choice between two execution
paths and \AgdaFunction{fail} discards the current path.
Nondeterministically choosing between two paths means that \AgdaFunction{⁇}
nondeterministically produces a boolean or has two continuations.
Therefore, we have a nullary and a binary operation, both without additional
parameters.

$$
\Sigma_{\text{Nondet}} = \{ ?\!? : \mathbb{1} \leadsto \mathbb{2}, \mathrm{fail}
: \mathbb{1} \leadsto \mathbb{0} \}
$$
Expressed as a container, we have a shape with two constructors, one for each
operation and both without parameters.

\begin{code}
data Nondetˢ : Set where ⁇ˢ failˢ : Nondetˢ
\end{code}
When constructing the container we assign the correct arities to each shape, by
defining a $\Pi$-type which produces the correct type for each shape.

\begin{code}
Nondet : Container
Nondet = Nondetˢ ▷ λ where ⁇ˢ → Bool ; failˢ → ⊥
\end{code}
We can now define smart constructors for each operation.
These are not the generic operations, but helper functions based on them.
The generic operations take no additional parameters and always use
\AgdaInductiveConstructor{pure} as continuation.
These versions of the operations already process the continuations parameter.
The generic \AgdaFunction{⁇} operation nondeterministically produces a boolean,
but usually we want to use it analogous to Curry's \texttt{?} operator.
Therefore, we implement this refined version.
\AgdaFunction{op}\AgdaSpace{}\AgdaInductiveConstructor{failˢ} produces a
computation with result type \AgdaDatatype{⊥}, i.e. the operation has no
continuations.
To avoid continuing with $λ()$ after every call of \AgdaFunction{fail} (to
produce a computation of the correct type) we add the continuation to the smart
constructor.

\begin{code}
_⁇_ : ∀ {ops} → ⦃ Nondet ∈ ops ⦄ → Free ops A → Free ops A → Free ops A
p ⁇ q = op ⁇ˢ >>= λ b → if b then p else q

fail : ∀ {ops} → ⦃ Nondet ∈ ops ⦄ → Free ops A
fail = op failˢ >>= λ()
\end{code}
With the syntax in place we can now move on to semantics and define a handler
for the effect.
\textcite{DBLP:conf/haskell/WuSH14} use Haskell language extensions like pattern
synonyms and view patterns to simplify their implementations.
Agda also has \AgdaKeyword{pattern} synonyms, which we use to simplify at least
simple effect handlers, i.e. those which do not rely on \AgdaFunction{prj}.
Similar to Haskell, the left-hand side of a \AgdaKeyword{pattern} defines an
abbreviation for the right-hand side, which can be used on the left- and
right-hand side of function rules.
We introduce \AgdaKeyword{pattern}s for each operation from the signature as
well as for other operations, i.e. those who are not part of the currently
handled signature.

\begin{code}
pattern Other s κ  = impure (inj₂ s , κ)
pattern Fail κ     = impure (inj₁ failˢ , κ)
pattern Choice κ   = impure (inj₁ ⁇ˢ , κ)
\end{code}
\begin{AgdaAlign}
  The handler interprets \AgdaDatatype{Nondet} syntax and removes it from the
  program.
  Therefore, \AgdaDatatype{Nondet} is removed from the front of the effect stack.
  For the handler different semantics are conceivable.
  For example, a handler could implement backtracking, that is, search for the
  first result that is not \AgdaFunction{fail}.
  The result type of such a handler could be modelled using a
  \AgdaDatatype{Maybe}.
  In our case, we implement a handler that returns all results.
  Therefore, the result is wrapped in a \AgdaDatatype{List}.
  The \AgdaDatatype{List} contains the results of all successful execution
  paths.
  \begin{code}
runNondet : ∀ {ops} → Free (Nondet ∷ ops) A → Free ops (List A)
  \end{code}
  The \AgdaInductiveConstructor{pure} constructor represents a program without
  effects.
  A singleton list is returned, because no nondeterminism is used in a
  \AgdaInductiveConstructor{pure} calculation.
  \begin{code}
runNondet (pure x)     = pure (x ∷ [])
  \end{code}
  The \AgdaInductiveConstructor{fail} constructor represents an unsuccessful
  calculation.
  No result is returned.
  \begin{code}
runNondet (Fail κ)     = pure []
  \end{code}
  In case of a \AgdaInductiveConstructor{Choice} both paths can produce an
  arbitrary number of results.
  We execute both programs recursively using \AgdaFunction{runNondet} and
  collect the results in a single \AgdaDatatype{List}.
  Note that we invoked the continuation of the operation with all possible
  arguments.
  A handler just searching for a single result would potentially discard one
  execution path.

  $\llparenthesis$ and $\rrparenthesis$ are \textit{idiom brackets} and denote
  applicative functor style function application, i.e.
  \AgdaInductiveConstructor{pure}\AgdaSpace{}\AgdaArgument{f}\AgdaSpace{}\AgdaFunction{<*>}$\dots$\AgdaFunction{<*>}$\dots$\AgdaFunction{<*>}$\dots$.
  In this case the function \AgdaArgument{f} is the mixfix operator
  \AgdaFunction{++} which can still be written in infix notation.
  \begin{code}
runNondet (Choice κ)   = ⦇ runNondet (κ true) ++ runNondet (κ false) ⦈
  \end{code}
  In case of syntax from another effect we just execute \AgdaFunction{runNondet}
  on every subtree by mapping the function over the container.
  Note that the newly constructed value has a different type.
  \AgdaInductiveConstructor{Other} hides the \AgdaInductiveConstructor{inj₂}
  constructor.
  Therefore, the newly constructed \AgdaInductiveConstructor{impure} value is of
  type
  \AgdaDatatype{Free}\AgdaSpace{}\AgdaArgument{ops}\AgdaSpace{}$($\AgdaDatatype{List}\AgdaSpace{}\AgdaArgument{A}$)$.
  Furthermore, notice that this function rule corresponds to one of the equations
  for handlers, given in section \ref{preliminaries:handler}.
  \begin{code}
runNondet (Other s κ)  = impure (s , runNondet ∘ κ)
  \end{code}
  Even though, this handler is defined recursively the definition from section
  \ref{preliminaries:handler} can still be recognized.
  The case for \AgdaInductiveConstructor{pure} corresponds to the function
  mapping values to computations.
  The cases for each operation correspond to the maps $h_i$, which process the
  parameter and the results of the continuation.
  The handler is not explicitly composed with the continuation before calling
  $h_i$, but in the cases above all results of $\kappa$ are processed by
  \AgdaFunction{runNondet}.
\end{AgdaAlign}


\subsubsection{Properties}
\label{first-order:nondet:properties}

As explained in section \ref{preliminaries:free-monad}, the free monad
represents the free model for the theory without equations, i.e. some terms
should be equal but are not.
The handler for an algebraic effect's syntax defines its semantics by removing
and interpreting its syntax.
The result of a handler should again be a model for the effect, i.e. the
equations characterizing the effect should hold.
We can prove that our handler produces a valid (but not necessarily free) model
for our equations by verifying that after interpreting the syntax the laws hold.
The ability to rigorously prove properties of a program, such as these laws for
our handler, is one of the main advantages of Agda.

We have four laws governing our \AgdaDatatype{Nondet} effect.
The first law states that \AgdaFunction{const}\AgdaSpace{}\AgdaFunction{fail}
should be an absorbing element for the Kleisli composition.
Writing the law using bind leaves us with the following equality.

\begin{code}[number=fail-annihilating]
bind-fail : {k : A → Free (Nondet ∷ ops) B} → 
  runNondet (fail >>= k) ≡ runNondet fail
bind-fail = refl
\end{code}
The proof is trivial, because \AgdaFunction{fail} has no continuations.
Simplifying both sides yields \AgdaFunction{fail}.

The other three laws state that \AgdaFunction{⁇} and \AgdaFunction{fail} form a
monoid.
The proofs for all three are similar.
By using functor, applicative and monad laws one can reduce the proof to one for
pure lists and simply use the corresponding equality from the standard library.

\begin{code}
⁇-identˡ : (q : Free (Nondet ∷ ops) A) → runNondet (fail ⁇ q) ≡ runNondet q
⁇-identˡ q = begin
  runNondet (fail ⁇ q)                      ≡⟨⟩ -- def. of handler for ⁇
  _++_ <$> runNondet fail  <*> runNondet q  ≡⟨⟩ -- def. of handler for fail
  _++_ <$> pure []         <*> runNondet q  ≡⟨⟩ -- def. of <$>
  pure ([] ++_)            <*> runNondet q  ≡⟨⟩ -- def. of <*> / ap-ident-left
  [] ++_                   <$> runNondet q  ≡⟨⟩ -- def. of ++ / ++-ident-left
  id                       <$> runNondet q  ≡⟨ fmap-id (runNondet q) ⟩
  runNondet q                               ∎
\end{code}
The proof for the left identity is straight forward.
No standard library equality is needed, because \AgdaFunction{++} is recursive
in its first argument.
To eliminate \AgdaFunction{<\$>} a functor law is required.

\begin{code}
⁇-identʳ : (p : Free (Nondet ∷ ops) A) → runNondet (p ⁇ fail) ≡ runNondet p
⁇-identʳ p = begin
  runNondet (p ⁇ fail)                          ≡⟨⟩ -- def. of handler
  _++_ <$> runNondet p        <*> pure []       ≡⟨ interchange [] (_++_ <$> runNondet p) ⟩
  pure (_$ [])    <*>  (_++_  <$> runNondet p)  ≡⟨⟩ -- def. of <*> / ap-ident-left
  (_$ [])         <$>  (_++_  <$> runNondet p)  ≡⟨ sym (fmap-∘ (_$ []) _++_ (runNondet p)) ⟩
  (_$ [])         ∘    _++_   <$> runNondet p   ≡⟨⟩ -- def. of ∘ and $
  (_++ [])                    <$> runNondet p   ≡⟨ cong  (_<$> runNondet p)
                                                         (extensionality ++-identityʳ) ⟩
  id                          <$> runNondet p   ≡⟨ fmap-id (runNondet p) ⟩
  runNondet p                                   ∎
\end{code}
Proving the right identity is more complicated, because \AgdaFunction{fail} is
on the right-hand side of \AgdaFunction{⁇}.
All monad functions from section \ref{first-order:free-monad} are recursive in
their left argument, therefore most propositions involving right arguments do
not follow trivially from the definition and need own proofs.

This is a common pattern.
Because \AgdaFunction{++} is recursive in its first argument, the left
identity is given by definitional equality, while the right one is not, but
follows from the definition.
Notice that partially applying \AgdaFunction{++} with
\AgdaInductiveConstructor{[]} is only equal to \AgdaFunction{id} on the left
without invoking \AgdaFunction{extensionality}.

Using the proofs from section \ref{first-order:free-monad:properties} we
can simplify the equations and reduce them to a problem for a normal
\AgdaDatatype{List}.
The proof for associativity is longer, but follows the same patterns.


\subsection{State}

The state effect has two operations \AgdaFunction{get} and \AgdaFunction{put}.
The whole effect is parameterized over the state type \AgdaArgument{S}.

\AgdaFunction{get} simply returns the current state.
The operation takes no additional parameters and has \AgdaArgument{S} positions.
This can either be interpreted as \AgdaFunction{get} being an
\AgdaArgument{S}-ary operation (one argument for each possible state) or
simply the parameter of the continuation being a value of type \AgdaArgument{S}.

\AgdaFunction{put} updates the current state.
The operation takes an additional parameter, the new state.
The operation itself is unary, i.e. the continuation is called with
\AgdaInductiveConstructor{tt} to start the rest of the program.

$$
\Sigma_{State} = \{ \mathrm{get} : \mathbb{1} \leadsto S, \mathrm{put} :
S \leadsto \mathbb{1} \}
$$
As before we translate this definition in a corresponding container and
define \AgdaKeyword{pattern}s to simplify the handler.

\begin{code}
data Stateˢ (S : Set) : Set where getˢ : Stateˢ S ; putˢ : S → Stateˢ S

State : Set → Container
State S = Stateˢ S ▷ λ where getˢ → S ; (putˢ _) → ⊤

pattern Get κ    = impure (inj₁ getˢ      , κ)
pattern Put s κ  = impure (inj₁ (putˢ s)  , κ)
\end{code}
To simplify working with the \AgdaDatatype{State} effect we add smart
constructors.
These correspond to the generic operations, which we can implement using
\AgdaFunction{op}.

\begin{code}
get : ∀ {ops S} → ⦃ State S ∈ ops ⦄ → Free ops S
get = op getˢ

put : ∀ {ops S} → ⦃ State S ∈ ops ⦄ → S → Free ops ⊤
put s = op (putˢ s)
\end{code}
Using these definitions for the syntax we can define the handler for
\AgdaDatatype{State}.

\begin{AgdaAlign}
The effect handler for \AgdaDatatype{State} takes an initial state together
with a program containing the effect syntax.
The final state is returned in addition to the result.

\begin{code}
runState : ∀ {ops S} → S → Free (State S ∷ ops) A → Free ops (S × A)
\end{code}
A \AgdaInductiveConstructor{pure} calculation does not change the current state.
Therefore, the initial is also the final state and returned in addition to the
result of the calculation.
\begin{code}
runState s₀ (pure x)     = pure (s₀ , x)
\end{code}
The continuation for \AgdaFunction{get} maps a state to the rest of the
computations, which somehow processes the given state.
By applying \AgdaArgument{s₀} to \AgdaArgument{κ} we obtain the rest of the
computation for the current state, which we evaluate recursively.
Notice that this operation technical has $|S|$ continuations, but we only call a
single one.
The handler for \AgdaDatatype{Nondet} always uses all of its continuations.
In reality the continuations are of course implemented as a single function,
which takes a parameter of type $S$.
\begin{code}
runState s₀ (Get κ)      = runState s₀ (κ s₀)
\end{code}
\AgdaFunction{put} updates the current state.
Therefore, we pass the new state \AgdaArgument{s₁} to the recursive call of
\AgdaFunction{runState}.
\begin{code}
runState _  (Put s₁ κ)   = runState s₁ (κ tt)
\end{code}
Similar to the handler for \AgdaDatatype{Nondet} we apply the handler to every
subterm of non \AgdaFunction{State} operations.
The current state is passed to the recursive calls of the handler for each
continuation.
\begin{code}
runState s₀ (Other s κ)  = impure (s , runState s₀ ∘ κ)
\end{code}
\end{AgdaAlign}
Lastly we define the usual helper function \AgdaFunction{evalState}, which
simply drops the final state.
\begin{code}
evalState : ∀ {ops S} → S → Free (State S ∷ ops) A → Free ops A
evalState s₀ p = proj₂ <$> runState s₀ p
\end{code}


\subsubsection{Example}

Here is a simple example for a function using the \AgdaDatatype{State}
effect.
The function \AgdaFunction{tick} returns \AgdaInductiveConstructor{tt} and
as side effect increases the state.

\begin{code}
tick : ∀ {ops} → ⦃ State ℕ ∈ ops ⦄ → Free ops ⊤
tick = do i ← get ; put (1 + i)
\end{code}
Using the \AgdaFunction{runState} handler we can evaluate programs, which use
the \AgdaDatatype{State} effect.

\begin{center}
\begin{code}[inline,hide]
example₁ :
\end{code}
\begin{code}[inline]
 (run $ runState 0 $ tick >> tick) ≡ (2 , tt)
\end{code}
\begin{code}[inline,hide]
example₁ = refl
\end{code}
\end{center}


\subsubsection{Properties}

To show that our implementation of \AgdaDatatype{State} is correct, i.e. that it
is a model, we have to show that the equations characterizing the effect hold.
Because some equations use just \AgdaFunction{get} and \AgdaFunction{put},
\AgdaArgument{ops} cannot be automatically inferred.

\begin{code}[inline,hide]
module StateLaws (S : Set) (ops : List Container) (s₀ : S) where
\end{code}
\begin{code}
  go : Free (State S ∷ ops) A → Free ops (S × A)
  go = runState {_} {ops} s₀
\end{code}
Given an arbitrary initial state \AgdaArgument{s₀} and rest effect stack
\AgdaArgument{ops} the following equations have to hold.

\begin{code}[hide]
  put-put :
\end{code}
\begin{code}
    ∀ {s₁ s₂ : S} → go (put s₁ >> put s₂) ≡ go (put s₂)
\end{code}
\begin{code}[hide]
  put-get :
\end{code}
\begin{code}
    ∀ {s : S} → go (put s >> get) ≡ go (put s >> pure s)
\end{code}
\begin{code}[hide]
  get-get :
\end{code}
\begin{code}
    ∀ {k : S → S → Free (State S ∷ ops) A} →
      go (get >>= λ s → get >>= k s) ≡ go (get >>= λ s → k s s)
\end{code}
\begin{code}[hide]
  get-put :
\end{code}
\begin{code}
    go (get >>= put) ≡ go (pure tt)
\end{code}
\begin{code}[hide]
  put-put = refl
  put-get = refl
  get-get = refl
  get-put = refl
\end{code}
All four equalities are proven trivially using \AgdaInductiveConstructor{refl}.
Our model for \AgdaDatatype{State} is just the usual state monad.
\textcite{DBLP:conf/fossacs/PlotkinP02} showed that the four equalities above
are enough to determine the state effect and that the free model is the usual
state monad.


\subsection{Handling Combined Effects}
\label{first-order:combined-effects}

As described in section \ref{first-order:functor}, signatures can be combined by
combining the underlying functors.
Handlers can be used to partially evaluate programs over a combined signature.
Consider the following program using nondeterminism and state.

\begin{code}[hide]
variable
  S : Set
\end{code}
\begin{code}
chooseTick : ⦃ Nondet ∈ ops ⦄ → ⦃ State ℕ ∈ ops ⦄ → Free ops ℕ
chooseTick = tick >> ((tick >> get) ⁇ (tick >> tick >> get))
\end{code}
As explained by \textcite{DBLP:conf/haskell/WuSH14}, for the interaction of
\AgdaDatatype{State} and \AgdaDatatype{Nondet} two semantics are conceivable.
\paragraph{Local State}
Each branch in the nondeterministic calculation has its own state.
When \AgdaFunction{⁇} is used to choose between two programs, both branches
continue with their own state.
The initial state for both branches is the current state of the branch calling
\AgdaFunction{⁇}.
\paragraph{Global State}
All branches share a single, global state.
Based on the evaluation strategy for the nondeterminism (first result/all
results; depth first search/breath first search/fair search) an ordering for all
operations in the tree is induced.
The state operations are executed in this order and all act on the same state.

The handlers for the two effects define semantics for their operations.
Operations of the other signature are just traversed.
The interaction semantics are induced by the ordering of the
handlers~\cite{DBLP:conf/haskell/WuSH14}.
We obtain two combined handlers, each corresponding to one of the two cases
above.

\begin{code}
localState : S → Free (State S ∷ Nondet ∷ []) A → List (S × A)
localState s₀ = run ∘ runNondet ∘ runState s₀

globalState : S → Free (Nondet ∷ State S ∷ []) A → S × List A
globalState s₀ = run ∘ runState s₀ ∘ runNondet
\end{code}
Let us consider the above example under both combined handlers with initial
state \AgdaNumber{0}.

\paragraph{Local State}
The first \AgdaFunction{tick} increases the state to \AgdaNumber{1}.
Both branches are executed independently with initial state \AgdaNumber{1}.
The first ticks once, therefore the \AgdaFunction{get} yields \AgdaNumber{2}.
The second ticks twice, therefore the \AgdaFunction{get} yields \AgdaNumber{3}.

\begin{center}
\begin{code}[inline,hide]
runChooseTickLocal :
\end{code}
\begin{code}[inline]
 localState 0 chooseTick ≡ (2 , 2) ∷ (3 , 3) ∷ []
\end{code}
\begin{code}[inline,hide]
runChooseTickLocal = refl
\end{code}
\end{center}

\paragraph{Global State}
The nondet handler executes the banches from left to right.
The final state of one branch is the inital one for the next branch.
Therefore, the second branch continues with state \AgdaNumber{2} increasing it
twice.

\begin{center}
\begin{code}[inline,hide]
runChooseTickGlobal :
\end{code}
\begin{code}[inline]
 globalState 0 chooseTick ≡ (4 , 2 ∷ 4 ∷ [])
\end{code}
\begin{code}[inline,hide]
runChooseTickGlobal = refl
\end{code}
\end{center}


\section{Effects with Scopes using Brackets}
\label{fist-order:scoped-effects}

To correctly handle operations with local scopes Wu et al. introduce scoped
effects \cite{DBLP:conf/haskell/WuSH14}.
They presented two syntactic approaches to explicitly declare how far an
operations scopes over an arbitrary program.
In the following section we implement the scoped effect
\AgdaDatatype{Cut} following \textcite{DBLP:conf/haskell/WuSH14} in Agda.

The central idea by \textcite{DBLP:conf/haskell/WuSH14} is to add new effect
syntax, representing explicit scope delimiters.
When handling the new syntax, whenever an opening delimiter is encountered
another handler, that implements the non-algebraic operation, evaluates the
program in scope.
Whenever the second handler encounters a closing delimiter it stops the
evaluation and returns the rest of the program.
Due to a closing delimiters the end of a scope can be found.
Therefore, calling \AgdaFunction{>>=} on a scoped operation, to extend the
continuation, is not a problem, because the continuation can be separated in the
parts inside and outside the scope.
By introducing scope delimiters \textcite{DBLP:conf/haskell/WuSH14} move the
problem of scoping from the handler to the syntax and therefore allows a flexible
ordering of the handlers and the implementation of operations with scopes.
Furthermore, this change allows calling all handlers for the program at once,
similar to \texttt{runM} functions for monad transformers.
A more in depth explanation, as well as an example were the handler orders for
semantics and scoping do not coincide can be found in the original paper by
\textcite{DBLP:conf/haskell/WuSH14} as well as in the repository.

Separating the program into the parts inside and outside the scope requires a
more complex recursive handler, because scopes could be nested. 
Using our size annotated free monad we are able to transfer the implementation
by \textcite{DBLP:conf/haskell/WuSH14}, without making large changes.
In the following sections we will implement scoped effects and exemplarily
present how the Haskell implementation can be transferred to Agda.


\subsection{Cut and Call}

As first example for an effect with explicit scope delimiters we implement
\AgdaFunction{cut} and \AgdaFunction{call} following \textcite{DBLP:conf/haskell/WuSH14}.
The effect is implemented in two stages.
First we implement the traditional effect \AgdaDatatype{Cut}.
It allows to prune branches from nondeterministic computations.
The handler for the effect determines the scope of the pruning operation.
It corresponds to the usual \AgdaFunction{call} operation, which restricts the
\AgdaFunction{cut}'s scope.
Second we implement an effect which marks scopes, when handled isolates the
programs in scope and evaluates the handler for \AgdaDatatype{Cut} on each
of them.
This allows us to implement a version of \AgdaFunction{call}, which is not a
handler.
First we define the syntax for the actual effect and its delimiters.

\begin{code}
data Cutˢ   : Set where cutfailˢ : Cutˢ
data Callˢ  : Set where bcallˢ ecallˢ : Callˢ

pattern Cutfail   = impure (inj₁ cutfailˢ , _)
pattern BCall  κ  = impure (inj₁ bcallˢ , κ)
pattern ECall  κ  = impure (inj₁ ecallˢ , κ)

Cut Call : Container
Cut   = Cutˢ    ▷ λ _ → ⊥
Call  = Callˢ   ▷ λ _ → ⊤
\end{code}
The \AgdaDatatype{Cut} effect has just a single operation, \AgdaFunction{cutfail}.
\AgdaFunction{cutfail} can only be used in a context with nondeterminism.
When \AgdaFunction{cutfail} is called it prunes all unexplored branches and
calls \AgdaFunction{fail}.
Using \AgdaFunction{cutfail} we can implement the usual \AgdaFunction{cut}
operation.
The structure of the Agda implementation of the handlers is identical to the one
by \textcite{DBLP:conf/haskell/WuSH14}, but to prove termination we have to use
the size annotation.

\begin{AgdaAlign}
Internally, the handler calls the function \AgdaFunction{go}, which accumulates
the unexplored alternatives in its second argument using \AgdaFunction{⁇}.
\AgdaFunction{fail} is the neutral element for \AgdaFunction{⁇} and therefore
the default argument.
Since this handler is non-orthogonal (it interacts with another effect's syntax)
\AgdaDatatype{Nondet} is required to be in the effect stack, but its position is
irrelevant.
We require a proof that \AgdaDatatype{Nondet} is in the effect stack.
Using \AgdaFunction{prj} we can inspect \AgdaDatatype{Nondet} syntax without
explicitly knowing how the container coproduct was constructed.

To prove termination we mark the second argument of \AgdaFunction{go} with an
arbitrary size \AgdaArgument{i}.
The continuations for each operation return subterms indexed by a smaller size.
Therefore, recursive calls to \AgdaFunction{go} with these terms as argument
terminate.

\begin{code}
call : ⦃ Nondet ∈ ops ⦄ → Free (Cut ∷ ops) A → Free ops A
call = go fail
  where
    go : ⦃ Nondet ∈ ops ⦄ → Free ops A → Free (Cut ∷ ops) A {i} → Free ops A
\end{code}
In case of a \AgdaInductiveConstructor{pure} value no \AgdaFunction{cutfail}
happened.
Therefore, we return a program that chooses between the value and the earlier
separated alternatives.

\begin{code}
    go q (pure a)       = (pure a) ⁇ q
\end{code}
In case of a \AgdaFunction{cutfail} we terminate the current computation by calling
\AgdaFunction{fail} and prune the alternatives by discarding \AgdaArgument{q}.

\begin{code}
    go _ Cutfail        = fail
\end{code}
To interact with \AgdaDatatype{Nondet} syntax we have to find it.
We have a proof that the \AgdaDatatype{Nondet} effect is an element of the effect
list.
Whenever we find syntax from another effect we can therefore try to project the
\AgdaDatatype{Nondet} option from the coproduct.
Notice that \AgdaFunction{prj} hides the structural recursion but decreases the
\AgdaDatatype{Size} index.
Therefore, we can still prove that the function terminates.

\begin{code}
    go q p@(Other s κ)  with prj {Nondet} p
\end{code}
The case for \AgdaFunction{⁇} separates the main branch from the alternative.
Using \AgdaFunction{go} the \AgdaDatatype{Cut} syntax is removed from both
alternatives, but the results are handled asymmetrically.
The left option is directly passed to the recursive call of
\AgdaFunction{go}.
The handled right option is the new alternative for the left one and therefore
could be pruned if left contains a \AgdaFunction{cutfail} call.

\begin{code}
    ... | just (⁇ˢ     , κ′)  = go (go q (κ′ false)) (κ′ true)
\end{code}
When encountering a \AgdaFunction{fail} we continue with the earlier accumulated
alternatives.

\begin{code}
    ... | just (failˢ  , _ )  = q
\end{code}
Syntax of other effects is handled as usual.

\begin{code}
    ... | nothing             = impure (s , go q ∘ κ)
\end{code}
\end{AgdaAlign}
With the handler for \AgdaDatatype{Cut} in place we can define the handler for the
scope delimiters.
The implementation is again similar to the one presented by
\textcite{DBLP:conf/haskell/WuSH14}, but to prove termination we again add
\AgdaDatatype{Size} annotations to the functions.

The \AgdaFunction{bcall} and \AgdaFunction{ecall} handlers remove the scope
delimiter syntax from the program and run \AgdaFunction{call} (the handler
for \AgdaDatatype{cut}) at the beginning of each scope.
Whenever a \AgdaFunction{BCall} is found the handler \AgdaFunction{ecall} is
used to handle the rest of the program.
\AgdaFunction{ecall} searches for the end of the scope and returns the program
up to that point.
The rest of the program is the result of the returned program.

A valid upper bound for the size of the rest of the program is \AgdaArgument{i},
the size of the program before separating the syntax after the closing delimiter.
This fact is crucial to prove that the recursive calls to \AgdaFunction{bcall} and
\AgdaFunction{ecall} using \AgdaFunction{>>=} terminate.
Remember that bind discards the size of its argument.
For handlers following this pattern this is not a problem, because the returned
program (i.e. the inner \AgdaDatatype{Prog} layer) is size annotated.

Calling the handler on the extracted program guaranties that the handler does
not interact with syntax outside the intended scope and the handlers state, in
this case the separated branches, is isolated.
Nested scopes are handled using recursive calls to \AgdaFunction{ecall} if
\AgdaFunction{BCall} operations are encountered while searching a closing
delimiter.

Since the delimiters can be placed freely it is possible to mismatch them.
If we encounter a closing before an opening delimiter, we know that they are
mismatched.
\textcite{DBLP:conf/haskell/WuSH14} use Haskell's \texttt{error} function to
terminate the program.
In Agda we are not allowed to define partial functions, therefore we have to
handle the error.
We could either correct the error and just continue or short circuit the
calculation using some form of exceptions, for example the \AgdaDatatype{Maybe}
monad.
For simplicity, we use the former approach.
In a real application it would be advisable to inform the programmer about the
error, either using exceptions or at least trace the error.

\begin{code}
bcall  : ⦃ Nondet ∈ ops ⦄ → Free (Call ∷ Cut ∷ ops) A {i} → Free (Cut ∷ ops) A
ecall  : ⦃ Nondet ∈ ops ⦄ → Free (Call ∷ Cut ∷ ops) A {i}
  → Free (Cut ∷ ops) (Free (Call ∷ Cut ∷ ops) A {i})

bcall (pure x)     = pure x
bcall (BCall κ)    = upcast (call (ecall (κ tt))) >>= bcall
bcall (ECall κ)    = bcall (κ tt) -- Unexpected ECall! We just fix the error.
bcall (Other s κ)  = impure (s , bcall ∘ κ)

ecall (pure x)     = pure (pure x)
ecall (BCall κ)    = upcast (call (ecall (κ tt))) >>= ecall
ecall (ECall κ)    = pure (κ tt)
ecall (Other s κ)  = impure (s , ecall ∘ κ)
\end{code}
Using the handlers defined above we can define a handler for scoped
\AgdaDatatype{Cut} syntax, which removes \AgdaDatatype{Cut} and
\AgdaDatatype{Call} syntax simultaneously.
The delimiters and correctly scoped \AgdaDatatype{Cut} syntax is removed using
\AgdaFunction{bcall} and potential unscoped \AgdaDatatype{Cut} syntax is
removed with a last use of \AgdaFunction{call}.
The function \AgdaFunction{call′} is a smart constructor for the scope
delimiters.
Semantically it is identically to the earlier \AgdaFunction{call} handler, but
this version of the function can be moved freely, because it is not a handler.

\begin{code}
runCut : ⦃ Nondet ∈ ops ⦄ → Free (Call ∷ Cut ∷ ops) A → Free ops A
runCut = call ∘ bcall

call′ : ⦃ Call ∈ ops ⦄ → Free ops A → Free ops A
call′ p = do op bcallˢ ; x ← p ; op ecallˢ ; pure x
\end{code}

\section{Call-Time Choice as Effect}

Bunkenburg presented an approach to model call-time choice as a stack of
scoped algebraic effects~\cite{bunkenburg2019modeling}.
In this section we extend the nondeterminism effect from section
\ref{nondeterminism} to one modelling call-time choice.

As explained in section \ref{call-time-choice}, in Curry call-time choice
semantics are realized using sharing of nondeterministic choices.
The current implementation of \AgdaDatatype{Nondet} does not support sharing,
i.e. it is not possible for two choice to be linked.
Based on Bunkenburg's implementation we make two changes to the
nondeterminism effect from Section \ref{nondeterminism}.
In the following, the new effect and all its associated functions have names
ending in \AgdaDatatype{′}.
Each choice is augmented with an optional identifier consisting of a triple of
natural numbers, called \textit{choice id}.
The first two are used to identify the current scope and will be refereed to as
\textit{scope id}.
The third number identifies the choice inside its scope.
Furthermore, instead of producing a list the handler will now produce a tree of
values.
The modified handler is identical to the handler in Section
\ref{nondeterminism}, except that it stores values using the
\AgdaInductiveConstructor{leaf} constructor and concatenates results using
\AgdaInductiveConstructor{branch}.
This change allows to choose the evaluation strategy, e.g. depth first or breath
first search, independent of the handler.

\begin{code}
SID CID : Set
SID = ℕ × ℕ
CID = SID × ℕ

data Tree (A : Set) : Set where
  branch  : Maybe CID → (l r : Tree A) → Tree A
  leaf    : A → Tree A
  failed  : Tree A
\end{code}

\subsection{Deep Effects}
\label{first-order:deep-effects}

In Haskell and Curry, ambient effects (e.g. partiality, tracing and
nondeterminism) can occur in components of data structures.
Each argument of a constructor could be an effectful computation.
For example, in Curry the tail of a list could be a nondeterministic choice
between two possible tails or in Haskell the list's tail could be
\mintinline[breaklines]{haskell}{undefined}.
These effects inside data structures are sometimes called \textit{deep effects}.
Because Haskell and Curry are evaluated lazily, it is possible to never demand
the effectful data.
In this case the effect should not occur.
For example, in Haskell it is possible to calculate the length of a list, that
stores \mintinline[breaklines]{haskell}{undefined}s.

We want to simulate this behaviour with algebraic effects.
The effects are modelled explicitly using the \AgdaDatatype{Free} type.
We lift data types using a standard construction, which is commonly used
to simulate ambient deep
effects~\cite{DBLP:conf/haskell/AbelBBHN05, DBLP:journals/programming/DylusCT19,
DBLP:conf/haskell/ChristiansenDB19}.
The following example of an effectful \AgdaDatatype{List} demonstrates
the general construction\footnote{In the following code effectful data
  structures and lifted versions of functions are marked with a suffix
  \textsuperscript{M}}.

\begin{code}
data Listᴹ (ops : List Container) (A : Set) : {Size} → Set where
  nil   : Listᴹ ops A {i}
  cons  : Free ops A → Free ops (Listᴹ ops A {i}) → Listᴹ ops A {↑ i}
\end{code}
\AgdaDatatype{Listᴹ}\AgdaSpace{}\AgdaArgument{ops}\AgdaSpace{}\AgdaArgument{A}
represents a \AgdaDatatype{List}\AgdaSpace{}\AgdaArgument{A} in whose components
effects from the given effect stack \AgdaArgument{ops} can occur.
Notice that the lifted list directly stores programs, i.e. values of type
\AgdaDatatype{Free}\AgdaSpace{}\AgdaArgument{ops}\AgdaSpace{}\AgdaArgument{A}.
This makes it possible to ignore parts of the data structure and their
associated effects.
This is not possible with simple lifted lists, i.e. values of type
\AgdaDatatype{Free}\AgdaSpace{}\AgdaArgument{ops}\AgdaSpace{}$($\AgdaDatatype{List}\AgdaSpace{}\AgdaArgument{A}$)$.
Furthermore, this construction allows us evaluate the effects of the different
components at different points in time, by calling \AgdaFunction{>>=} on them
separately. 
To easily construct and work with lifted values we introduce smart constructors
in the form of pattern synonyms.

\begin{code}[hide]
infixr 5 _∷ᴹ_ _++ᴹ_
\end{code}
\begin{code}
pattern []ᴹ          = pure nil
pattern _∷ᴹ_ mx mxs  = pure (cons mx mxs)
\end{code}
The size annotations on the lifted data structures are needed to prove
that structural recursive functions terminate.
To pattern match on a lifted value we have to use \AgdaFunction{>>=}.
Therefore, the structural recursion is obscured.
Due to the size annotation it is still possible to prove termination.

\begin{code}
_++ᴹ_ : Free ops (Listᴹ ops A {i}) → Free ops (Listᴹ ops A) → Free ops (Listᴹ ops A)
mxs ++ᴹ mys = mxs >>= λ where
  nil             → mys
  (cons mx mxs′)  → mx ∷ᴹ mxs′ ++ᴹ mys
\end{code}
By calling \AgdaFunction{>>=} we extend the given computation tree at its leafs
with the binds continuation.
This corresponds to demeaning the value in a lazily evaluated language.
The operations in the continuation are placed explicitly after the operations in
the bound program.
For example, in the above program, we bind the effects in the first lists
constructors from head to tail.
The values stored by each \AgdaInductiveConstructor{∷ᴹ} and therefore their
effects are ignored.


\paragraph{Normalization of Effectful Data}

Based on the code by \textcite{bunkenburg2019modeling} we introduce a type
class for normalizing effectful data structures, i.e. moving interleaved
\AgdaDatatype{Free} layers to the outside using \AgdaFunction{>>=}.

\begin{code}
record Normalform (ops : List Container) (A B : Set) : Set where
  field nf : A → Free ops B
open Normalform ⦃...⦄ public

!_ : ⦃ Normalform ops A B ⦄ → Free ops A → Free ops B
! mx = mx >>= nf
\end{code}
The type class allows normalizing elements of type \AgdaArgument{A} (intuitively
containing effectful calculations) to computations producing of elements of type
\AgdaArgument{B} (intuitively a version of \AgdaArgument{A} without the effects).
Instead of the arbitrary types \AgdaArgument{A} and \AgdaArgument{B} we could
have parameterized the type class over a type family of an effect stack, with
\AgdaFunction{nf}
producing an element of the type family applied to an empty stack.
This implementation would allow us to restrict the normalizable types, but
prohibit us from producing elements of standard data types.

In contrast to Bunkenburg's implementation we do not expect a lifted argument.
Simplifying the type and introducing the helper function \AgdaFunction{!\_}
removes the need for auxiliary normalization lemmas for
\AgdaInductiveConstructor{pure} and \AgdaInductiveConstructor{impure} values in
proofs.
The extra degree of freedom, introduced by a monadic argument, is not used in
the original implementation.

\begin{code}
instance
  ℕ-normalform : Normalform ops ℕ ℕ
  Normalform.nf ℕ-normalform = pure

  Listᴹ-Normalform : ⦃ Normalform ops A B ⦄ →
    Normalform ops (Listᴹ ops A {i}) (List B)
  Normalform.nf Listᴹ-Normalform nil            = pure []
  Normalform.nf Listᴹ-Normalform (cons mx mxs)  = ⦇ ! mx ∷ ! mxs ⦈
\end{code}
The data stored in an effectful list could also be effectful and therefore has
to be normalized.
We simply require a \AgdaDatatype{Normalform} instance for the stored type.
To allow normalization of general types and effectful data structures containing
them, we have to implement dummy instances for simple data types like natural
numbers and booleans.

\subsection{Sharing Handler}

In this section we implement the sharing effect by
\textcite{bunkenburg2019modeling}.
The effect provides the \AgdaFunction{share} operation, which can be used to
share nondeterministic choices in a program.
As explained in Section \ref{preliminaries:curry}, sharing of nondeterminism is
the basis for call-time choice semantics in Curry.
Because only the choices in scope of the \AgdaFunction{share} operation are
shared, it should be obvious that this is a scoped effect.

The basic structure of the following sharing handler is identical to the one
presented by \textcite{bunkenburg2019modeling}.
Due to the more flexible infrastructure described in the earlier sections we
are able to define a more modular handler and avoid some inlining, necessary to
prove termination in Coq.
Similar to \AgdaDatatype{Cut} the sharing handler is non-orthogonal, because it
interacts with existing \AgdaDatatype{Nondet′} syntax.

The scoping operation \AgdaFunction{share} takes an additional argument, the
unique identifier for the created scope.
Similar to \AgdaFunction{put}, the parameter is part of the container's shape.

\begin{code}
data Shareˢ : Set where bshareˢ eshareˢ : SID → Shareˢ
pattern BShare  n κ = impure (inj₁ (bshareˢ n)  , κ)
pattern EShare  n κ = impure (inj₁ (eshareˢ n)  , κ)

Share : Container
Share = Shareˢ ▷ λ _ → ⊤
\end{code}
\begin{code}[hide]
-- ID in earlier definition (Nondet is the first example without parameters) or
-- redefine here (maybe hidden)?
data NonDetˢ : Set where
  ⁇ˢ     : Maybe ((ℕ × ℕ) × ℕ) → NonDetˢ
  failˢ  : NonDetˢ

pattern Choice′ cid κ = impure (inj₁ (⁇ˢ cid) , κ)
pattern Fail′ = impure (inj₁ failˢ , _)

Nondet′ : Container
Nondet′ = NonDetˢ ▷ λ where
  (⁇ˢ _) → Bool
  failˢ  → ⊥

fail′ : ⦃ Nondet′ ∈ ops ⦄ → Free ops A
fail′ = inj (failˢ , λ())

_⁇′_ : ⦃ Nondet′ ∈ ops ⦄ → Free ops A → Free ops A → Free ops A
p ⁇′ q = inj (⁇ˢ nothing , (if_then p else q))

runNondet′ : Free (Nondet′ ∷ ops) A → Free ops (Tree A)
runNondet′ (pure x)         = pure (leaf x)
runNondet′ (Choice′ cid κ)  = branch cid <$> runNondet′ (κ true) <*> runNondet′ (κ false)
runNondet′ Fail′            = pure failed
runNondet′ (Other s κ)      = impure (s , runNondet′ ∘ κ)
\end{code}
The handler has the same structure as other handlers for scoped effects like
\AgdaDatatype{Cut}.
The \AgdaFunction{bshare} handler searches for opening delimiters, which are
subsequently handled by \AgdaFunction{eshare}.
\AgdaFunction{ehsare} handles the part of the program in scope and returns the
unhandled continuations, which are again handled using \AgdaFunction{bshare}.
Nested scopes are handled using recursive \AgdaFunction{eshare} calls.
To implement sharing the handler modifies the program in scope.
Using \AgdaFunction{prj}, \AgdaFunction{Nondet′} syntax is extracted, modified and
reinjected.
Choice operations are modified to include the unique choice id.
The id is generated from the scope id of the current sharing scope and a
counter, that is managed by the handler.
When ever a choice is tagged with an id, the counter is incremented.
The uniqueness of the scope identifiers is not managed by the handler, but the
share operator.

\begin{code}
bshare  : ⦃ Nondet′ ∈ ops ⦄ → Free (Share ∷ ops) A {i} → Free ops A
eshare  : ⦃ Nondet′ ∈ ops ⦄ → ℕ → SID → Free (Share ∷ ops) A {i}
  → Free ops (Free (Share ∷ ops) A {i})

bshare (pure x)        = pure x
bshare (BShare sid κ)  = eshare 0 sid (κ tt) >>= bshare
bshare (EShare sid κ)  = bshare (κ tt) -- mismatched scopes, we just continue!
bshare (Other  s   κ)  = impure (s , bshare ∘ κ)

eshare next sid (pure x)         = pure (pure x)
eshare next sid (BShare sid′ κ)  = eshare 0 sid′ (κ tt) >>= eshare next sid
eshare next sid (EShare sid′ κ)  = pure (κ tt) -- usually test that sid′ = sid
eshare next sid p@(Other s κ) with prj {Nondet′} p
... | just (⁇ˢ _  , κ′)  = inj $ ⁇ˢ (just $ sid , next) , eshare (1 + next) sid ∘ κ′
... | just (failˢ , κ′)  = inj $ failˢ , λ()
... | nothing            = impure (s , eshare next sid ∘ κ)
\end{code}
Due to the size annotations, termination is proven on the type level.
To implement the sharing handler it is not necessary to combine the two cases,
as done by \textcite{bunkenburg2019modeling} in Coq.


\subsection{Share Operator}

Next we define the \AgdaFunction{share} operator as described by
\textcite{bunkenburg2019modeling}.
The operator generates new unique scope identifiers using a \AgdaDatatype{State}
effect.
Furthermore, it shares all choices in the components of effectful data
structures.

To map the operator over arbitrary structures the \AgdaDatatype{Shareable} type
class is introduced.
The \AgdaFunction{shareArgs} function calls \AgdaFunction{share} recursively on
the components of the shared data structure.
Similar to \AgdaDatatype{Normalform}, trivial instances for simple data types
are introduced.

\begin{code}
record Shareable (ops : List Container) (A : Set) : Set where
  field shareArgs : A → Free ops A
open Shareable ⦃...⦄

instance
  shareable-ℕ : Shareable ops ℕ
  Shareable.shareArgs shareable-ℕ = pure
\end{code}
Using the instances for data we can implement Bunkenburg's version of the
operator.
The operator itself relies on a \AgdaDatatype{State} effect to generate the
unique ids.
\AgdaDatatype{State} is later executed as first effect in the stack, to generate
concrete identifier values for the sharing handler.
Given a computation producing values of type \AgdaArgument{A} the operator
returns a computation of computations of type \AgdaArgument{A}, i.e. the result
has two \AgdaDatatype{Free}\AgdaSpace{}\AgdaArgument{ops} layers.
The outer layer is usually executed immediately (i.e. injected into the larger
program at the current position) using \AgdaFunction{>>=}.
The outer computation generates a new identifier.
The inner computation actually evaluates the shared program and manages its
sharing scope.
The inner computation captures the identifier.
Therefore, binding the inner computation multiple times yields multiple scopes
with the same id.
An in depth explanation can be found in
\citetitle{bunkenburg2019modeling}~\cite{bunkenburg2019modeling}.

\begin{code}
share : ⦃ Shareable ops A ⦄ → ⦃ Share ∈ ops ⦄ → ⦃ State SID ∈ ops ⦄ →
  Free ops A → Free ops (Free ops A)
share p = do (i , j) ← get
             put (1 + i , j)
             pure do op $ bshareˢ (i , j)
                     put (i , 1 + j)
                     x   ← p
                     x′  ← shareArgs x
                     put (1 + i , j)
                     op $ eshareˢ (i , j)
                     pure x′
\end{code}
Using \AgdaFunction{share} we can implement a \AgdaDatatype{Shareable} instance
for effectful lists.
In the original Haskell implementation of \AgdaFunction{shareArgs} is a higher
order function, that takes the used sharing operator as an additional
argument.
For simplicity and to avoid termination problems this is not the case in the
Agda implementation.
Note that we implement \AgdaDatatype{Shareable} for lists of size
\AgdaArgument{i} to guaranty termination of \AgdaFunction{shareArgs}.

\begin{code}
instance
  Listᴹ-shareable : ⦃ Shareable ops A ⦄ → ⦃ Share ∈ ops ⦄ → ⦃ State SID ∈ ops ⦄
      → Shareable ops (Listᴹ ops A {i})
  Shareable.shareArgs Listᴹ-shareable nil            = []ᴹ
  Shareable.shareArgs Listᴹ-shareable (cons mx mxs)  = cons <$> share mx <*> share mxs
\end{code}


\subsection{Examples}

Using the handler we can simulate call-time choice semantics using effects in
Agda.
Call-time choice can be simulated with the following effect stack.

\begin{code}
CTC : List Container
CTC = State (ℕ × ℕ) ∷ Share ∷ Nondet′ ∷ []
\end{code}
Before calling any handlers the data is normalized, such that not only surface,
but also deep effects are evaluated.
State is evaluated first to generate the identifiers for the sharing scopes.
Sharing is evaluated next to tag all choices with their scopes identifier.
At last nondeterminism is evaluated to collect the results of all possible
branches into a tree.
The tree is traversed using depth first search.
When ever a choice with a choice id is encountered its decision is remembered.

\begin{code}
dfs : {A : Set} → Map Bool → Tree A → List A
dfs mem failed                   = []
dfs mem (leaf x)                 = x ∷ []
dfs mem (branch nothing    l r)  = dfs mem l ++ dfs mem r
dfs mem (branch (just id)  l r) with lookup id mem
... | nothing  = dfs (insert id true mem) l ++ dfs (insert id false mem) r
... | just d   = if d then dfs mem l else dfs mem r

runCTC : ⦃ Normalform CTC A B ⦄ → Free CTC A → List B
runCTC p = dfs empty $ run $ runNondet′ $ bshare $ evalState (0 , 0) (! p)
\end{code}
Now we can implement the \AgdaFunction{doubleCoin} example from section
\ref{preliminaries:curry}.

\begin{code}
coin : ⦃ Nondet′ ∈ ops ⦄ → Free ops ℕ
coin = pure 0 ⁇′ pure 1

doubleCoin : ⦃ Share ∈ ops ⦄ → ⦃ State (ℕ × ℕ) ∈ ops ⦄ → ⦃ Nondet′ ∈ ops ⦄ →
  Free ops ℕ
doubleCoin = share coin >>= λ c → ⦇ c + c ⦈
\end{code} % TODO image shared coins
By calling \AgdaFunction{share} the choice in \AgdaFunction{coin} is shared.
By binding the result of \AgdaFunction{share} the computation tree generating
the ids (i.e. the outer layer) is expanded.
The argument of the continuation \AgdaArgument{c} is itself a program.
It is the original \AgdaFunction{coin} function inside a sharing scope, that
captures the generated id of the outer scope. % TODO ?
By binding \AgdaArgument{c} this computation is injected into the whole
computation.
Binding \AgdaArgument{c} multiple times yields the same scope, because the scope
identifier is captured.
Equal scope identifier yield equal decisions during the evaluation of
\AgdaDatatype{Nondet′}.

\begin{center}
\begin{code}[inline,hide]
runDoubleCoin :
\end{code}
\begin{code}[inline]
 runCTC doubleCoin ≡ 0 ∷ 2 ∷ []
\end{code}
\begin{code}[inline,hide]
runDoubleCoin = refl
\end{code}
\end{center}
Due to the \AgdaDatatype{Shareable} type class it is also possible to share
choices, which are embedded into data structures.
The following simple example demonstrates this possibility.

\begin{code}
headᴹ : ⦃ Nondet′ ∈ ops ⦄ → Free ops (Listᴹ ops A) → Free ops A
headᴹ mxs = mxs >>= λ where
  nil         → fail′
  (cons mx _) → mx

doubleHead : ⦃ Share ∈ ops ⦄ → ⦃ State (ℕ × ℕ) ∈ ops ⦄ → ⦃ Nondet′ ∈ ops ⦄ →
  Free ops ℕ
doubleHead = share (coin ∷ᴹ []ᴹ) >>= λ mxs → ⦇ headᴹ mxs + headᴹ mxs ⦈
\end{code}
As expected, observing the value in the head twice yields the same value,
because the choice was shared.

\begin{center}
\begin{code}[inline,hide]
runDoubleHead :
\end{code}
\begin{code}[inline]
 runCTC doubleHead ≡ 0 ∷ 2 ∷ []
\end{code}
\begin{code}[inline,hide]
runDoubleHead = refl
\end{code}
\end{center}
Using the \AgdaDatatype{Normalform} type class it is possible to embed effects
deep into data structures.
This allow to write programs operating on recursive data structures, which
closely resemble their Curry version.
Consider the example of nondeterministic insertion into a list.

\begin{code}
insertND : ⦃ Nondet′ ∈ ops ⦄ →
  Free ops A → Free ops (Listᴹ ops A {i}) → Free ops (Listᴹ ops A {↑ i})
insertND mx mxs = mxs >>= λ where
  nil            → mx ∷ᴹ []ᴹ
  (cons my mxs)  → (mx ∷ᴹ my ∷ᴹ mxs) ⁇′ (my ∷ᴹ insertND mx mxs)
\end{code}
When evaluating the result of \AgdaFunction{insertND} the \AgdaDatatype{Listᴹ}
is normalized using the type class.
As expected, insert \AgdaNumber{1} deterministically in the list with
\AgdaNumber{2} and \AgdaNumber{3} yields three possible results.

\begin{center}
\begin{code}[inline,hide]
runInsertND :
\end{code}
\begin{code}[inline]
 runCTC (insertND (pure 1) (pure 2 ∷ᴹ pure 3 ∷ᴹ []ᴹ)) ≡
   (1 ∷ 2 ∷ 3 ∷ []) ∷ (2 ∷ 1 ∷ 3 ∷ []) ∷ (2 ∷ 3 ∷ 1 ∷ []) ∷ []
\end{code}
\begin{code}[inline,hide]
runInsertND = refl
\end{code}
\end{center}


\subsection{Laws of Sharing}

\begin{figure}
  \begin{align*}
    \tag{ident-left}
    \mathrm{pure} x\bind k &= k\; x \\
    \tag{ident-right}
    mx \bind \mathrm{pure} &= mx \\
    \tag{assoc}
    mx \bind f \bind g &= mx \bind \lambda x\rightarrow f x \bind g \\\\
    \tag{fail-absorb}
    \mathrm{fail} \bind  k &= \mathrm{fail} \\
    \tag{⁇-algebraic}
    (p\; ⁇\; q) \bind k &= (p \bind k)\; ⁇\; (q \bind k) \\\\
    \tag{share-fail}
    \mathrm{share}\;\mathrm{fail} &= \mathrm{pure}\;\mathrm{fail}\\
    \tag{share-$\bot$}
    \mathrm{share}\;\bot &= \mathrm{pure}\;\bot\\
    \tag{share-⁇}
    \mathrm{share}\;(p\; ⁇\; q) &= \mathrm{share}\;p\; ⁇\; \mathrm{share}\;q \\
    \tag{HNF}
    \mathrm{share}\;(\mathrm{c}\;x_1\dots x_n) &= \mathrm{share}\; x_1 \bind \lambda y_1 \dots \mathrm{share}\; x_n \bind\lambda y_n \rightarrow \mathrm{pure}\;(\mathrm{pure}\;(c\;y_1\dots y_n))
  \end{align*}
  \caption{Laws for a monad with sharing by \textcite{DBLP:conf/icfp/FischerKS09}}
  \label{first-order:sharing:properties:laws}
\end{figure}

\textcite{DBLP:conf/icfp/FischerKS09} introduce a set of equations
characterizing call-time choice semantics.
The equations can be found in figure \ref{first-order:sharing:properties:laws}.
The first three laws are just the monad laws, which were proven in section
\ref{first-order:free-monad:properties}.
Section \ref{first-order:nondet:properties} contains a proof for the fourth law.
The fifth law is the algebraicity of \AgdaFunction{⁇}, which follows for any operation
directly from the definition of \AgdaFunction{>>=}.

\begin{code}
⁇-algebraic : ⦃ _ : Normalform CTC B C ⦄ → ⦃ _ : Shareable CTC B ⦄ →
  (p q : Free CTC A) (k : A → Free CTC B) →
  runCTC ((p ⁇′ q) >>= k) ≡ runCTC ((p >>= k) ⁇′ (q >>= k))
⁇-algebraic p q k = refl
\end{code}
In addition to the monad laws and equations for \AgdaFunction{⁇} they introduced
equations involving \AgdaFunction{share}.

\begin{code}
share-fail : ⦃ _ : Normalform CTC A B ⦄ → ⦃ _ : Shareable CTC A ⦄ →
  runCTC {A} {B} (share fail′ >>= id) ≡ runCTC {A} {B} (pure fail′ >>= id)
share-fail = refl
\end{code}
The second law involving \AgdaFunction{share} does not apply to our effect
stack, because we have no notion of \mintinline{Haskell}{undefined}.
Partiality can be implemented identical to \AgdaFunction{fail} with carrier
\AgdaDatatype{Maybe}.
The effect would be placed last in the stack to allow canceling all running
calculations.
The law can be proven analogous to the one for \AgdaFunction{fail}.

The third law involving \AgdaFunction{share} states that \AgdaFunction{share}
distributes over \AgdaFunction{⁇}.
This law does not hold for this implementation, because there is no guarantee
that \AgdaFunction{get} or \AgdaFunction{put} are not called outside the sharing
operator.
Developing another implementation satisfying the laws in all cases is outside
the scope of this thesis.

The last law states that \AgdaFunction{share} distributes over the components of
effectful data structures.
Since our representation for effectful data is not uniform this law has to be
proven on a case by case basis.
One could try to automate this proves using tactics, find an equivalent
formulation which does not refer to constructors directly or use a different
representation for effectful data (e.g. fixed points of polynomial functors,
since they can be made effectful generically).


\section{Results}
\label{first-order:results}

In this chapter we implemented usual notion of algebraic effects and handlers.
Based on the work by \textcite{DBLP:conf/icfp/Brady13}, we introduced our
general infrastructure for working with modular effects in Agda.
In addition to the implementation of effects and the handlers, we used Agda's
theorem proving capabilities to reason about effectful programs.
Furthermore, we used \textcite{DBLP:conf/haskell/WuSH14} method of explicit
scope delimiters to provide modular versions of operations with scopes.
Our sized annotated version of the free monad allowed us to implement the more
complex, recursive handlers for scope delimiters, without changing the general
structure of the implementation by \textcite{DBLP:conf/haskell/WuSH14}.
Following \textcite{bunkenburg2019modeling} we were able to implement a general
infrastructure for deep effects as well as a handler for sharing, allowing us to
simulate call-time choice semantics in Agda.

Because we simply implemented the Haskell version of this approach in Agda, the
problems from the Haskell implementation also carry over.
The problem noted by \textcite{DBLP:conf/haskell/WuSH14} is malformed syntax.
Because the beginning and end of each scope are marked using different
operations, the handler has to deal with potentially mismatched scope delimiters.
This problem is amplified in Agda, because mismatched scope delimiters could
potentially also be encountered in proofs.
Furthermore, when handling operations with scopes the handlers has no direct
access to the continuation of the operation.
This prevents potentially optimizations.
For example, direct evaluation of the continuation with memorized result of a
shared computation.
