\begin{code}[hide]
module FirstOrder where

open import Level using (Level; suc; zero; _⊔_)
open import Function using (_∘_; id; _$_)
open import Size using (Size; ↑_)

open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Empty using (⊥)
open import Data.List using (List; []; _∷_; _++_)
open import Data.Nat using (ℕ; _+_)
open import Data.Product using (Σ-syntax; _×_; _,_)
open import Data.Sum using (_⊎_; [_,_])
open import Data.Unit using (⊤; tt)

open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong)

postulate
  extensionality : ∀ {ℓ ℓ′ : Level} {A : Set ℓ} {B : A → Set ℓ′} {f g : (x : A) → B x}
      → (∀ (x : A) → f x ≡ g x) → f ≡ g
\end{code}

Algebraic effects are computational effects, which can be described using an
algebraic theory.

Section \ref{fo-definition} gives a concrete definition for algebraic effects.
Section \ref{fo-free-monads} describes the implementation using free monads in
Agda.

\section{Definition}
\label{fo-definition}

Needed? A la Bauer? Adapts nicely to containers, but I'm not sure how well it
works wth scoped syntax and the HO approach

\section{Free Monads}
\label{fo-free-monads}

The syntax of an algebraic effect is described using the free monad.

\begin{code}
record Container : Set₁ where
  constructor _▷_
  field
    Shape : Set
    Pos : Shape → Set

⟦_⟧ : {ℓ : Level} → Container → Set ℓ → Set ℓ
⟦ S ▷ P ⟧ A = Σ[ s ∈ S ] (P s → A)
\end{code}
In the approach described by Wu et la. the functor coproduct is modelled
as the data type \texttt{data (f :+: g) a = Inl (f a) | Inr (g a)}, which is a
\texttt{Functor} in \texttt{a}.

In Agda functors are represented as containers, a concrete data type not a type
class.
The coproduct of two containers $F$ and $G$ is the container whose
\AgdaFunction{shape} is the disjoint union of $F$ and $G$s shapes and whose
position function \AgdaFunction{pos} is the coproduct mediator of $F$ and $G$s
position functions.
The functor represented by the coproduct of two containers is isomorphic to the
functor coproduct of their representations.

\begin{code}[hide]
infixr 1 _⊕_
\end{code}
\begin{code}
_⊕_ : Container → Container → Container
(Shape₁ ▷ Pos₁) ⊕ (Shape₂ ▷ Pos₂) = (Shape₁ ⊎ Shape₂) ▷ [ Pos₁ , Pos₂ ]
-- ⟦ F ⊕ G ⟧ A ≅ (⟦ F ⟧ + ⟦ G ⟧) A         Should i proof this?
\end{code}
Later each container will represent the syntax (the operations) of an effect.
To combine syntax of effects Wu et al. use a ``Data types {\`{a}} la
carte''\cite{DBLP:journals/jfp/Swierstra08} approach.
The type class \texttt{:<:} marks a functor as an option in a coproduct.
\texttt{:<:} can be used to inject values into or maybe extract values from a
coproduct.
The two instances for \texttt{:<:} overlap and use \texttt{:+:}.
Since the result of \AgdaFunction{\_⊕\_} is another container, not just a
value of a simple data type, instance resolution using \AgdaFunction{\_⊕\_} is
not as straight forward as in Haskell and in some cases extremely slow.

Therefore this implementation of the free monad uses an approach similar to the
Idris effect library \cite{DBLP:conf/icfp/Brady13}.
The free monad is not parameterised over a single container, but a list
\AgdaArgument{ops} of containers representing an $n$-ary coproduct.
Whenever the functor would be  used, an arbitrary container \AgdaArgument{op}
together with a proof
\AgdaArgument{op}\AgdaSpace{}\AgdaDatatype{∈}\AgdaSpace{}\AgdaArgument{ops} is
used.

\begin{code}
infix 4 _∈_
data _∈_ {ℓ : Level} {A : Set ℓ} (x : A) : List A → Set ℓ where
  instance
    here : ∀ {xs} → x ∈ x ∷ xs
    there : ∀ {y xs} → ⦃ x ∈ xs ⦄ → x ∈ y ∷ xs
\end{code}
The type
\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{∈}\AgdaSpace{}\AgdaArgument{xs}
represents the proposition that \AgdaArgument{x} is an element of
\AgdaArgument{xs}.
The two constructors can be read as rules of inference.
One can always construct a proof that \AgdaArgument{x} is in a list with
\AgdaArgument{x} in its head and given a proof that
\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{∈}\AgdaSpace{}\AgdaArgument{xs}
one can construct a proof that \AgdaArgument{x} is also in the extended list
\AgdaArgument{y}\AgdaSpace{}\AgdaInductiveConstructor{∷}\AgdaSpace{}\AgdaArgument{xs}.

The two instances still overlap resulting in $\mathcal{O}(c^n)$ instance
resolution.
Using Agdas internal instance resolution can be avoided by using a tactic to
infer \AgdaDatatype{\_∈\_} arguments.
For simplicity the following code will still use instance arguments.
This version can easily be adapted to one using macros, by replacing the
instance arguments with correctly annotated hidden ones.

\begin{code}
data Free {ℓ : Level} (ops : List Container) (A : Set ℓ) : {Size} → Set (ℓ ⊔ suc zero) where
  pure : ∀ {i} → A → Free ops A {i}
  impure : ∀ {i op} → ⦃ op ∈ ops ⦄ → ⟦ op ⟧ (Free ops A {i}) → Free ops A {↑ i}
\end{code}
[GENERAL EXPLANATION]

[EXPLANATION FOR LEVEL]

The free monad is indexed over an argument of Type \AgdaDatatype{Size}.
\AgdaInductiveConstructor{pure} values have an arbitrary size.
When constructing an \AgdaInductiveConstructor{impure} value the new value is
strictly larger than the ones produced by the containers position function.
The size annotation therefore corresponds to the height of the tree described by
the free monad.
Using the annotation it's possible to proof that functions preserve the size of
a value or that complex recursive functions terminate.
Consider the following definition of \AgdaFunction{fmap} for the free
monad\footnote{in the following code $A$, $B$ and $C$ are arbitrary types from
  arbitrary type universes}.

\begin{code}[hide]
variable
  ℓᵃ ℓᵇ ℓᶜ : Level
  A : Set ℓᵃ
  B : Set ℓᵇ
  C : Set ℓᶜ

infixl 1 _>>=_ _>>_
infixl 4 _<$>_ _⊛_
\end{code}
\begin{code}
fmap _<$>_ : {F : List Container} {i : Size} → (A → B) → Free F A {i} → Free F B {i}
f <$> pure x           = pure (f x)
f <$> impure (s , pf)  = impure (s , (f <$>_) ∘ pf)

fmap = _<$>_
\end{code}
\AgdaFunction{fmap} applies the given function \AgdaArgument{f} to the values
stored in the \AgdaInductiveConstructor{pure} leafs.
The height of the tree is left unchanged.
This fact is wittnessed by the same index \AgdaArgument{i} on the argument and
return type.

In contrast to \AgdaFunction{fmap}, \AgdaFunction{bind} does not preserve the
size.
\AgdaFunction{bind} replaces every \AgdaInductiveConstructor{pure} leaf with a
subtree, which is generated from the stored value.
The resulting tree is therefore at least as high as the given one.
Because there is no $+$ for sized types the only correct size estimate for the
returned value is ``unbounded''.
The return type is not explicitly indexed, because the compiler correctly
inferes \AgdaInductiveConstructor{∞}.

\begin{code}
_>>=_ : ∀ {ops} → Free ops A → (A → Free ops B) → Free ops B
pure x           >>= k = k x
impure (s , pf)  >>= k = impure (s , (_>>= k) ∘ pf)

_>>_ : ∀ {ops} → Free ops A → Free ops B → Free ops B
ma >> mb = ma >>= λ _ → mb
\end{code}
To complete our basic set of monadic functions we also define \AgdaFunction{ap}.

\begin{code}
_⊛_ : ∀ {ops} → Free ops (A → B) → Free ops A → Free ops B
pure f          ⊛ ma = f <$> ma
impure (s , pf) ⊛ ma = impure (s , (_⊛ ma) ∘ pf)
\end{code}

\subsection{Properties}

This definition of the free monad is a functor because it satisfies the two
functor laws.
Both properties are proven by structural induction over the free monad.
Notice that to proof the equality of the position functions, in the induction
step, the axiom of extensionality is invoked.

\begin{code}[number=fmap-id]
fmap-id : ∀ {ops} → (p : Free ops A) → fmap id p ≡ p
fmap-id (pure x)           = refl
fmap-id (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (fmap-id ∘ pf))
\end{code}
\begin{code}[number=fmap-comp]
fmap-∘ : ∀ {ops} (f : B → C) (g : A → B) (p : Free ops A) →
         fmap (f ∘ g) p ≡ (fmap f ∘ fmap g) p
fmap-∘ f g (pure x)           = refl
fmap-∘ f g (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (fmap-∘ f g ∘ pf))
\end{code}
This definition of the free monad also satisfies the three monad laws.

\begin{code}[number=bind-ident-left]
bind-identˡ : ∀ {ops} (f : A → Free ops B) (x : A) → (pure x >>= f) ≡ f x
bind-identˡ f x = refl
\end{code}
\begin{code}[number=bind-ident-right]
bind-identʳ : ∀ {ops} (x : Free ops A) → (x >>= pure) ≡ x
bind-identʳ (pure x)           = refl
bind-identʳ (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (bind-identʳ ∘ pf))
\end{code}
\begin{code}[number=bind-assoc]
bind-assoc : ∀ {ops} (f : A → Free ops B) (g : B → Free ops C) (p : Free ops A) →
             ((p >>= f) >>= g) ≡ (p >>= (λ x → f x >>= g))
bind-assoc f g (pure x)           = refl
bind-assoc f g (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (bind-assoc f g ∘ pf))
\end{code}

\section{Handler}

\begin{code}
run : Free [] A → A
run (pure x) = x

\end{code}

\subsection{Nondet}

The nondeterminism effect has two operations \AgdaFunction{\_⁇\_} and
\AgdaFunction{fail}.
\AgdaFunction{\_⁇\_} introduces a nondeterministic choice between two execution
paths and \AgdaFunction{fail} discards the current path.
We therefore have a nullary and a binary operation, both without additional
parameters.

$$
\Sigma_{\text{Nondet}} = \{ ?\!? : \mathbf{1} \rightsquigarrow \mathbf{2}, \mathrm{fail} : \mathbf{1} \rightsquigarrow \mathbf{0} \}
$$
Expressed as a container we have a shape with two constructors, one for each
operation and both without parameters.

\begin{code}
data Nondetˢ : Set where ⁇ˢ failˢ : Nondetˢ
\end{code}
When constructing the container we assign the correct arities to each shape.

\begin{code}
Nondet : Container
Nondet = Nondetˢ ▷ λ where
  ⁇ˢ     → Bool
  failˢ  → ⊥
\end{code}
We can now define smart constructors for each operation.
These are not the generic operations, but helper functions based on them.
The generic operations take no parameters an alaways use
\AgdaInductiveConstructor{pure} as continutation.
These versions of the operations already process the continuations parameter.

\begin{code}
_⁇_ : ∀ {ops} → ⦃ Nondet ∈ ops ⦄ → Free ops A → Free ops A → Free ops A
p ⁇ q = impure (⁇ˢ , (if_then p else q))

fail : ∀ {ops} → ⦃ Nondet ∈ ops ⦄ → Free ops A
fail = impure (failˢ , λ())
\end{code}
With the syntax in place we can now move on to semantics and define a handler
for the effect.
By introducing \AgdaKeyword{pattern} declarations for each operations the
handler can be simplified.
Furthermore we introduce a \AgdaKeyword{pattern} for other operations, i.e.
those who are not part of the currently handled signature.

\begin{code}
pattern Other s κ  = impure ⦃ there ⦄ (s , κ)
pattern Fail κ  = impure ⦃ here ⦄ (failˢ , κ)
pattern Choice κ  = impure ⦃ here ⦄ (⁇ˢ , κ)
\end{code}
\begin{AgdaAlign}
  The handler interprets \AgdaDatatype{Nondet} syntax and removes it from the
  program.
  Therefore \AgdaDatatype{Nondet} is removed from the front of the effect stack
  and the result is wrapped in a \AgdaDatatype{List}.
  The \AgdaDatatype{List} contains the results of all successful execution
  paths.
  \begin{code}
solutions : ∀ {ops} → Free (Nondet ∷ ops) A → Free ops (List A)
  \end{code}
  The \AgdaInductiveConstructor{pure} constructor represents a program without
  effects.
  The singleton list is returned, because no nondeterminism is used in a
  \AgdaInductiveConstructor{pure} calculation.
  \begin{code}
solutions (pure x)     = pure (x ∷ [])
  \end{code}
  The \AgdaInductiveConstructor{fail} constructor represents an unsuccessful
  calculation.
  No result is returned.
  \begin{code}
solutions (Fail κ)     = pure []
  \end{code}
  In case of a \AgdaInductiveConstructor{Choice} both paths can produce an
  arbitrary number of results.
  We execute both programs recursively using \AgdaFunction{solutions} and
  collect the results in a single \AgdaDatatype{List}.
  \begin{code}
solutions (Choice κ)   = _++_ <$> solutions (κ true) ⊛ solutions (κ false)
  \end{code}
  In case of syntax from another effect we just execute \AgdaFunction{solutions}
  on every subtree by mapping the function over the container.
  Note that the newly constructed value has a different type.
  Since \AgdaDatatype{Nondet} syntax was removed from the tree the proof for
  \AgdaDatatype{\_∈\_}, which is passed to \AgdaInductiveConstructor{impure}
  changes.
  \begin{code}
solutions (Other s κ)  = impure (s , solutions ∘ κ)
  \end{code}
\end{AgdaAlign}


\subsection{State}

The state effect has two operations \AgdaFunction{get} and \AgdaFunction{put}.
The whole effect is parameterized over the state type \AgdaArgument{s}.

\AgdaFunction{get} simply returns the current state.
The operation takes no additional parameters and has \AgdaArgument{s} positions.
This can either be interpreted as \AgdaFunction{get} being an
\AgdaArgument{s}-ary operation (one child for each possible state) or simply the
parameter of the continuation being a value of type \AgdaArgument{s}.

\AgdaFunction{put} updates the current state.
The operation takes an additional parameter, the new state.
The operation itself is unary i.e. there is no return value, therefore
\AgdaInductiveConstructor{tt} is passed to the rest of the program.

$$
\Sigma_{State} = \{ \mathrm{get} : \mathbf{1} \rightsquigarrow s, \mathrm{put} :
s \rightsquigarrow \mathbf{1} \}
$$
As before we will translate this definition in a corresponding container.

\begin{code}
data Stateˢ (S : Set) : Set where
  getˢ : Stateˢ S
  putˢ : S → Stateˢ S

State : Set → Container
State S = Stateˢ S ▷ λ where
  getˢ      → S
  (putˢ _)  → ⊤

pattern Get κ  = impure ⦃ here ⦄ (getˢ , κ)
pattern Put s κ  = impure ⦃ here ⦄ ((putˢ s) , κ)
\end{code}
To simplify working with the \AgdaDatatype{State} effect we add smart
constructors.
These correspond to the generic operations.

\begin{code}
get : ∀ {ops S} → ⦃ State S ∈ ops ⦄ → Free ops S
get = impure (getˢ , pure)

put : ∀ {ops S} → ⦃ State S ∈ ops ⦄ → S → Free ops ⊤
put s = impure (putˢ s , pure)
\end{code}
Using these defintions for the syntax we can define the handler for
\AgdaDatatype{State}.

\begin{AgdaAlign}
The effect handler for \AgdaDatatype{State} takes an initial state together
with a program containing the effect syntax.
The final state is returend in addition to the result.

\begin{code}
runState : ∀ {ops S} → S → Free (State S ∷ ops) A → Free ops (S × A)
\end{code}
A \AgdaInductiveConstructor{pure} calculation doesn't change the current state.
Therefore, the initial is also the final state and returned in addition to the
result of the caluclation.
\begin{code}
runState s₀ (pure x)     = pure (s₀ , x)
\end{code}
The continuation/position function for \AgdaFunction{get} takes the current
state to the rest of the calculation.
By applying \AgdaArgument{s₀} to \AgdaArgument{κ} we obtain the rest of the
computation, which we can evaluate recursively.
\begin{code}
runState s₀ (Get κ)      = runState s₀ (κ s₀)
\end{code}
\AgdaFunction{put} updates the current state, therefore we pass the new state
\AgdaArgument{s₁} to the recursive call of \AgdaFunction{runState}.
\begin{code}
runState _  (Put s₁ κ)   = runState s₁ (κ tt)
\end{code}
Similar to the handler for \AgdaDatatype{Nondet} we apply the handler to every
subterm of non \AgdaFunction{State} operations.
\begin{code}
runState s₀ (Other s κ)  = impure (s , runState s₀ ∘ κ)
\end{code}
\end{AgdaAlign}

\subsubsection{Example}

Here is a simple example for a function using the \AgdaDatatype{State}
effect.
The function \AgdaFunction{tick} returns \AgdaInductiveConstructor{tt} and
as side effect increases the state.

\begin{code}
tick : ∀ {ops} → ⦃ State ℕ ∈ ops ⦄ → Free ops ⊤
tick = do i ← get ; put (1 + i)
\end{code}
Using the \AgdaFunction{runState} handler we can evaluate programs, which use
the \AgdaDatatype{State} effect.

\begin{center}
\begin{code}[inline,hide]
example₁ :
\end{code}
\begin{code}[inline]
 (run $ runState 0 $ tick >> tick) ≡ (2 , tt)
\end{code}
\begin{code}[inline,hide]
example₁ = refl
\end{code}
\end{center}

\subsubsection{Properties}

\section{Scoped Effects}
\subsection{Cut}

\section{Call-Time-Choice as Effect}
