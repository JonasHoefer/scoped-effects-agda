\begin{code}[hide]
{-# OPTIONS --overlapping-instances #-}
module FirstOrder where

open import Level using (Level; suc; zero; _⊔_)
open import Function
open import Size using (Size; ↑_)

open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Empty using (⊥)
open import Data.List using (List; []; _∷_; _++_; foldr)
open import Data.Nat using (ℕ; _+_)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.Product using (Σ-syntax; _×_; _,_)
open import Data.Sum using (_⊎_; [_,_]; inj₁; inj₂)
open import Data.Unit using (⊤; tt)

open import Relation.Binary.PropositionalEquality using (_≡_; refl; cong)

postulate
  extensionality : ∀ {ℓ ℓ′ : Level} {A : Set ℓ} {B : A → Set ℓ′} {f g : (x : A) → B x}
      → (∀ (x : A) → f x ≡ g x) → f ≡ g
\end{code}


Algebraic effects are computational effects, which can be described using an
algebraic theory.
Examples of effects include I/O, exceptions, nondeterminism, state, delimited
continuations and more~\cite{DBLP:journals/corr/abs-1807-05923}.
Handlers for algebraic effects were first presented by Gordon and Plotkin
as a generalization of exception handlers \cite{}. % \cite{DBLP:conf/esop/PlotkinP09} <- handler? definitely not first one, see Wu
Handlers can be used to describe non-algebraic operations, which include
operations with scopes such as \texttt{catch} and \texttt{once}.
Wu et al. describe a problem with this approach when multiple handlers
interact.
The ordering of handlers induces a semantic for the program, but simultaneously
the handlers also delimit scopes.
The correct ordering for scoping and semantics maybe not coincide.
Wu et al. fix this problem by introducing new syntactic constructs to delimit
scopes, removing the responsibility from the
handler~\cite{DBLP:conf/haskell/WuSH14,DBLP:conf/lics/PirogSWJ18}.

Section \ref{fo-definition} gives a concrete definition for algebraic effects.
Section \ref{fo-free-monads} describes the implementation using free monads in
Agda.
The following sections describe the implementation of unscoped and scoped
effects in the fist order setting. They focus on implementation details specific
to Agda like termination checks.
The scoped effects are implemented using explicit scope delimiters as described
by Wu et al. \cite{DBLP:conf/haskell/WuSH14}.

\section{Definition}
\label{fo-definition}

The following definition is similar to the one given by Bauer
\cite{DBLP:journals/corr/abs-1807-05923}.

An algebraic theory consists of a signature describing the syntax of the
operations together with a set of equations.
A signature is a set of operation symbols together with an arity set and an
additional parameter.
Operations of this form are usually denoted with a colon and $\rightsquigarrow$
between the three sets, suggesting that they describe special functions.
\[
  \Sigma = \{ \mathrm{op}_i : P_i \rightsquigarrow A_i  \}_{i\in \mathbf{N}}
\]
Given a signature $\Sigma$ we can build terms over a set of variables $\mathbb{X}$.
\[
  x \in \mathrm{Term}_\Sigma(\mathbb{X}) \quad\text{for}\quad x\in\mathbb{X} \qquad
  \mathrm{op}_i(p, \kappa) \in \mathrm{Term}_\Sigma(\mathbb{X}) \quad\text{for}\quad
  p\in P_i, \kappa : A_i \rightarrow \mathrm{Term}_\Sigma(\mathbb{X})
\]
Terms can be used to form a equations of the form $x | l=r$.
Each equation consists of two terms $l$ and $r$ over a set of variables $x$.
A signature $\Sigma_T$ together with a set of equations $\mathcal{E}_T$ forms an
algebraic theory $T$.
\[
  T = (\Sigma_T, \mathcal{E}_T)
\]
An interpretation $I$ of a signature is given by a carrier set $|I|$ and an
interpretation for each operation $\lBrack\cdot\rBrack_I$.
An interpretation of an operation $\mathrm{op}_i$ is given by a functions to the
carrier set $|I|$, that takes an additional parameter from $P_i$ an $|A_i|$
parameters as a function from the arity set to the carrier set $|I|$.
\[
  \lBrack \mathrm{op}_i \rBrack_I : P_i \times |I|^{A_i} \rightarrow |I|
\]
Given a function $\iota : \mathbb{X} \rightarrow |I|$, assigning each variable
a value, we can give an interpretation for terms $\lBrack\cdot\rBrack_{(I,\iota)}$.
\begin{align*}
  \lBrack x \rBrack_{(I,\iota)} &= \iota(x) \\
  \lBrack \mathrm{op}_i(p, \kappa)\rBrack_{(I,\iota)} &= \lBrack op_i \rBrack_I (p, \kappa \circ \lBrack\cdot\rBrack_{(I, \iota)})
\end{align*}
An interpretation for $T$ is called $T$-model if it validates all equations in $\mathcal{E}_T$.

\subsection{Free Model}

For each algebraic theory $T$ we can generate a so called free model
$\mathrm{Free}_T(\mathbb{X})$, which validates all equations.


\section{Free Monads}
\label{fo-free-monads}

The syntax of an algebraic effect is described using the free monad.
The usual definition of the free monad in Haskell is the following.

\begin{minted}{haskell}
data Free f a = Pure a | Impure (f (Free f a))

instance (Functor f) => Monad (Free f) where
  return = Pure

  Pura x    >>= k = k x
  Impure fa >>= k = Impure (fmap (>>= k) fa)
\end{minted}
As the name suggests, the free monad is the free object in the category of
monads, therefore the following holds.

\begin{enumerate}
  \item For every (endo)functor $F$ the functor $\mathrm{Free}\;F$ is a monad
  \item For every natural transformation from an (endo)functor $F$ to a monad $G$
    exists a monad homomorphism from $\mathrm{Free}\;F$ to $G$
  \item As a consequence of (2) taking the natural transformation to be the
    identity on $F$, for every monad exists a monad homomorphism from a
    Free monad.
  \item The $\mathrm{Free}$ functor is left adjoint and therefore preserves
    coproducts i.e. $\mathrm{Free}\;F \oplus \mathrm{Free}\; G \cong \mathrm{Free}\;
    (F \oplus G)$
\end{enumerate}
When defining the free monad in Agda we cannot use an arbitrary functor as in
Haskell, because it would violate the strict positivity requirement.
Instead we will represent the functor as the extension of a container as
described in section \ref{container}.

\begin{code}[hide]
record Container : Set₁ where
  constructor _▷_
  field
    Shape : Set
    Pos : Shape → Set
open Container public

⟦_⟧ : {ℓ : Level} → Container → Set ℓ → Set ℓ
⟦ S ▷ P ⟧ A = Σ[ s ∈ S ] (P s → A)
\end{code}
\begin{code}
data Free′ (C : Container) (A : Set) : Set where
  pure : A → Free′ C A
  impure : ⟦ C ⟧ (Free′ C A) → Free′ C A
\end{code}
The free monad represents an arbitrary branching tree with values of type
\AgdaArgument{A} in its leafs.
The \AgdaInductiveConstructor{pure} constructor builds leafs containing just
a value of type \AgdaArgument{A}.
The \AgdaInductiveConstructor{impure} constructor takes a value of the
\AgdaDatatype{Free} monad lifted by the container functor of \AgdaArgument{C}.
Based on the choice of container the actual value could contain an arbitrary
number of values i.e. \AgdaDatatype{Free} monads or subtrees.
Furthermore for each shape from the \AgdaFunction{Shape} type the number of
subtrees can differ or contain additional arbitrary values.
The container has no access to the type parameter of the free monad.

The \AgdaFunction{>>=} operator for free monads traverses the trees and applies
the continuation to the values stored in the leafs, replacing them.
\AgdaFunction{>>=} therefore substitutes leafs with new subtrees generated from
the values stored in each leaf.

\subsection{Functors {\`{a}} la carte}

When modelling effects each functor represents the syntax i.e. the operations of
an effect.
For containers each shape corresponds to an operation symbol and the
type of position for a shape corresponds to the arity set for the operation.
The additional parameter of an operation is embedded in the shape.
The free monad over a container describes a program using the effects syntax
i.e. its the free model for the algebra without the equations.
To combine the syntax of multiple effects we can combine the underlying
functors, because the free monad preserves coproducts.


The approach described by Wu et al. is based on ``Data types {\`{a}} la
carte''\cite{DBLP:journals/jfp/Swierstra08}.
The functor coproduct is modelled as the data type \texttt{data (f :+: g) a =
  Inl (f a) | Inr (g a)}, which is again a \texttt{Functor} in \texttt{a}.

In Agda functors are represented as containers, a concrete data type not a type
class.
Containers are closed under multiple operations, coproducts being one of
them~\cite{DBLP:conf/fossacs/AbbottAG03}.
The coproduct of two containers $F$ and $G$ is the container whose
\AgdaFunction{shape} is the disjoint union of $F$s and $G$s shapes and whose
position function \AgdaFunction{pos} is the coproduct mediator of $F$s and $G$s
position functions.

\begin{code}[hide]
infixr 1 _⊕_
\end{code}
\begin{code}
_⊕_ : Container → Container → Container
(Shape₁ ▷ Pos₁) ⊕ (Shape₂ ▷ Pos₂) = (Shape₁ ⊎ Shape₂) ▷ [ Pos₁ , Pos₂ ]
\end{code}
The functor represented by the coproduct of two containers is isomorphic to the
functor coproduct of their representations.
The container without shapes is neutral element for the coproduct of containers.
This allows us to define $n$-ary coproducts for containers.

\begin{code}
sum : List Container → Container
sum  = foldr (_⊕_) (⊥ ▷ λ())
\end{code}
To generically work with arbitrary coproducts of functors we will define two
utility functions.
Given a value $x:A$ we want to be able to inject it into any coproduct
mentioning $A$.
Given any coproduct mentioning $A$ we want to be able to project a value of
type $A$ from the coproduct, if $A$ is the currently held alternative.

In the ``Data types {\`{a}} la carte''\cite{DBLP:journals/jfp/Swierstra08}
approach the type class \texttt{:<:} is introduced.
\texttt{:<:} relates a functor to a coproduct of functors, marking it as an
option in the coproduct.
\texttt{:<:}s functions can be used to inject values into or maybe extract
values from a coproduct.
The two instances for \texttt{:<:} mark $F$ as an element of the coproduct if
it's an on the left-hand side of the coproduct (in the head) or if it's already
in the right-hand side (in the tail).

\begin{minted}{haskell}
     class (Syntax sub, Syntax sup) => sub :<: sup where
       inj :: sub m a -> sup m a
       prj :: sup m a -> Maybe (sub m a)

     instance {-# OVERLAPPABLE #-} (Syntax f, Syntax g) => f :<: (f :+: g) where
       inj = Inl
       prj (Inl a) = Just a
       prj _ = Nothing

     instance {-# OVERLAPPABLE #-} (Syntax h, f :<: g) => f :<: (h :+: g) where
       inj = Inr . inj
       prj (Inr ga) = prj ga
       prj _ = Nothing
\end{minted}
The two instances overlap resulting in possible slower instance resolution.
Furthermore, \texttt{:+:} is assumed to be right associative and only to be
used in a right associative way to avoid backtracking.

Because in Agda the result of \AgdaFunction{\_⊕\_} is another container, not
just a value of a simple data type, instance resolution using
\AgdaFunction{\_⊕\_} is not as straight forward as in Haskell and in some cases
extremely slow\footnote{I encountered cases where type checking of overlapping
instances involving \AgdaFunction{\_⊕\_} did not seem to terminate.}.

This implementation of the free monad uses an approach similar to the Idris
effect library \cite{DBLP:conf/icfp/Brady13}.
The free monad is not parameterised over a single container, but a list
\AgdaArgument{ops} of containers.
This has the benefit that we cannot associate coproducts to the left by
accident.
The elements of the list are combined later using \AgdaFunction{sum}.
To track which functors are part of the coproduct we introduce the new type
\AgdaDatatype{\_∈\_}.

\begin{code}[hide]
infix 4 _∈_
\end{code}
\begin{code}
data _∈_ {ℓ : Level} {A : Set ℓ} (x : A) : List A → Set ℓ where
  instance
    here : ∀ {xs} → x ∈ x ∷ xs
    there : ∀ {y xs} → ⦃ x ∈ xs ⦄ → x ∈ y ∷ xs
\end{code}
The type
\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{∈}\AgdaSpace{}\AgdaArgument{xs}
represents the proposition that \AgdaArgument{x} is an element of
\AgdaArgument{xs}.
The two constructors can be read as rules of inference.
One can always construct a proof that \AgdaArgument{x} is in a list with
\AgdaArgument{x} in its head and given a proof that
\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{∈}\AgdaSpace{}\AgdaArgument{xs}
one can construct a proof that \AgdaArgument{x} is also in the extended list
\AgdaArgument{y}\AgdaSpace{}\AgdaInductiveConstructor{∷}\AgdaSpace{}\AgdaArgument{xs}.

The two instances still overlap resulting in $\mathcal{O}(c^n)$ instance
resolution.
Using Agdas internal instance resolution can be avoided by using a tactic to
infer \AgdaDatatype{\_∈\_} arguments.
For simplicity the following code will still use instance arguments.
This version can easily be adapted to one using macros, by replacing the
instance arguments with correctly annotated hidden ones.

Using this proposition we can define functions for injection into and maybe projection
out of coproducts.

\begin{code}
inject : ∀ {C ops ℓ} {A : Set ℓ} → C ∈ ops → ⟦ C ⟧ A → ⟦ sum ops ⟧ A
inject here           (s , pf)  = (inj₁ s) , pf
inject (there ⦃ p ⦄)  prog      with inject p prog
... | s , pf = (inj₂ s) , pf

project : ∀ {C ops ℓ} {A : Set ℓ} → C ∈ ops → ⟦ sum ops ⟧ A → Maybe (⟦ C ⟧ A)
project here           (inj₁ s , pf)  = just (s , pf)
project here           (inj₂ _ , _ )  = nothing
project there          (inj₁ _ , _ )  = nothing
project (there ⦃ p ⦄)  (inj₂ s , pf)  = project p (s , pf)
\end{code}
Both \AgdaFunction{inject} and \AgdaFunction{project} require a proof/evidence
that specific container is an element of the list used to construct the
coproduct.

Let us consider \AgdaFunction{inject} first.
By pattern matching on the evidence we acquire more information about type 
\AgdaFunction{sum}\AgdaSpace{}\AgdaArgument{ops}.
In case of \AgdaInductiveConstructor{here} we know that \AgdaArgument{op} is in
the head of the list i.e. that the given value \AgdaArgument{C}
is the same as the one in the head of the list.
Therefore the \AgdaField{Shape} types are the same and we can use our given
\AgdaArgument{s} and \AgdaArgument{pf} to construct the coproduct.
In case of \AgdaInductiveConstructor{there} we obtain a proof that the container
is in the tail of the list, which we can use to make a recursive call.
By pattern matching on and repackaging the result we obtain a value of the right
type.

\AgdaFunction{project} functions similarly.
By pattern matching on the proof we either know that the value we found has
the correct type or we obtain a proof for the tail of the list allowing us to
make a recursive call.

\subsection{The Free Monad for Effect Handling}

Using the coproduct machinery we can now define a version of the free monad,
suitable for working with effects.
In contrast to the first definition, this free monad is parameterized over a
list of containers.
In the \AgdaInductiveConstructor{impure} constructor the containers are combined
using \AgdaFunction{sum}.
The parameterization over a list ensures that the containers are not combined
prematurely.

\begin{code}
data Free (ops : List Container) (A : Set) : {Size} → Set where
  pure : ∀ {i} → A → Free ops A {i}
  impure : ∀ {i} → ⟦ sum ops ⟧ (Free ops A {i}) → Free ops A {↑ i}
\end{code}
% switch names for inj and inject / prj and project?
Next we define utility functions for working with the free monad.
\AgdaFunction{inj} and \AgdaFunction{prj} provide the same functionality as the
ones used by Wu el al.
\AgdaFunction{inj} allows to inject syntax into a program whose signature allows
the operation.
\AgdaFunction{prj} allows to inspect the next operation of a
program, restricted to a specific signature.
Furthermore we add the functions \AgdaFunction{op} and \AgdaFunction{upcast}.
\AgdaFunction{op} generates the generic operation for any operation symbol.
\AgdaFunction{upcast} transformes a program using any signature to one using a
larger signature.
Notice that upcast prserves the size of its input, because it just traverses the
tree and repackages the contents.

\begin{code}
inj : ∀ {C ops A} → ⦃ C ∈ ops ⦄ → ⟦ C ⟧ (Free ops A) → Free ops A
inj ⦃ p ⦄ = impure ∘ inject p

prj : ∀ {C ops A i} → ⦃ C ∈ ops ⦄ → Free ops A {↑ i} → Maybe (⟦ C ⟧ (Free ops A {i}))
prj ⦃ p ⦄ (pure x)    = nothing
prj ⦃ p ⦄ (impure x)  = project p x

op : ∀ {C ops} → ⦃ C ∈ ops ⦄ → (s : Shape C) → Free ops (Pos C s)
op s = inj (s , pure)

upcast : ∀ {C ops A i} → Free ops A {i} → Free (C ∷ ops) A {i}
upcast (pure x) = pure x
upcast (impure (s , κ)) = impure (inj₂ s , upcast ∘ κ)
\end{code}
The free monad is indexed over an argument of Type \AgdaDatatype{Size}.
\AgdaInductiveConstructor{pure} values have an arbitrary size.
When constructing an \AgdaInductiveConstructor{impure} value the new value is
strictly larger than the ones produced by the containers position function.
The size annotation therefore corresponds to the height of the tree described by
the free monad.
Using the annotation it's possible to proof that functions preserve the size of
a value or that complex recursive functions terminate.

Consider the following definition of \AgdaFunction{fmap} for the free
monad\footnote{in the following code $A$, $B$ and $C$ are arbitrary types}.

\begin{code}[hide]
variable
  ℓᵃ ℓᵇ ℓᶜ : Level
  A : Set ℓᵃ
  B : Set ℓᵇ
  C : Set ℓᶜ

infixl 1 _>>=_ _>>_
infixl 4 _<$>_ _⊛_
\end{code}
\begin{code}
fmap _<$>_ : {F : List Container} {i : Size} → (A → B) → Free F A {i} → Free F B {i}
f <$> pure x           = pure (f x)
f <$> impure (s , pf)  = impure (s , (f <$>_) ∘ pf)

fmap = _<$>_
\end{code}
\AgdaFunction{fmap} applies the given function \AgdaArgument{f} to the values
stored in the \AgdaInductiveConstructor{pure} leafs.
The height of the tree is left unchanged.
This fact is wittnessed by the same index \AgdaArgument{i} on the argument and
return type.

In contrast to \AgdaFunction{fmap}, \AgdaFunction{bind} does not preserve the
size.
\AgdaFunction{bind} replaces every \AgdaInductiveConstructor{pure} leaf with a
subtree, which is generated from the stored value.
The resulting tree is therefore at least as high as the given one.
Because there is no $+$ for sized types the only correct size estimate for the
returned value is ``unbounded''.
The return type is not explicitly indexed, because the compiler correctly
inferes \AgdaInductiveConstructor{∞}.

\begin{code}
_>>=_ : ∀ {ops} → Free ops A → (A → Free ops B) → Free ops B
pure x           >>= k = k x
impure (s , pf)  >>= k = impure (s , (_>>= k) ∘ pf)

_>>_ : ∀ {ops} → Free ops A → Free ops B → Free ops B
ma >> mb = ma >>= λ _ → mb
\end{code}
To complete our basic set of monadic functions we also define \AgdaFunction{ap}.

\begin{code}
_⊛_ _<*>_ : ∀ {ops} → Free ops (A → B) → Free ops A → Free ops B
pure f          ⊛ ma = f <$> ma
impure (s , pf) ⊛ ma = impure (s , (_⊛ ma) ∘ pf)

_<*>_ = _⊛_
\end{code}

\subsection{Properties}

This definition of the free monad is a functor because it satisfies the two
functor laws.
Both properties are proven by structural induction over the free monad.
Notice that to proof the equality of the position functions, in the induction
step, the axiom of extensionality is invoked.

\begin{code}[number=fmap-id]
fmap-id : ∀ {ops} → (p : Free ops A) → fmap id p ≡ p
fmap-id (pure x)           = refl
fmap-id (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (fmap-id ∘ pf))
\end{code}
\begin{code}[number=fmap-comp]
fmap-∘ : ∀ {ops} (f : B → C) (g : A → B) (p : Free ops A) →
         fmap (f ∘ g) p ≡ (fmap f ∘ fmap g) p
fmap-∘ f g (pure x)           = refl
fmap-∘ f g (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (fmap-∘ f g ∘ pf))
\end{code}
This definition of the free monad also satisfies the three monad laws.

\begin{code}[number=bind-ident-left]
bind-identˡ : ∀ {ops} (f : A → Free ops B) (x : A) → (pure x >>= f) ≡ f x
bind-identˡ f x = refl
\end{code}
\begin{code}[number=bind-ident-right]
bind-identʳ : ∀ {ops} (x : Free ops A) → (x >>= pure) ≡ x
bind-identʳ (pure x)           = refl
bind-identʳ (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (bind-identʳ ∘ pf))
\end{code}
\begin{code}[number=bind-assoc]
bind-assoc : ∀ {ops} (f : A → Free ops B) (g : B → Free ops C) (p : Free ops A) →
             ((p >>= f) >>= g) ≡ (p >>= (λ x → f x >>= g))
bind-assoc f g (pure x)           = refl
bind-assoc f g (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (bind-assoc f g ∘ pf))
\end{code}

\section{Handler}

An effect handler interprets and removes the syntax of an effect and injects
corresponding code into the program.
Some handlers manipulate syntax of other effects or the structure of the program
itself.
The handler for an algebraic effect defines it's semantics.

All handlers will have the same basic structure.
They will take a program i.e. a variable of type
\AgdaDatatype{Free}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A}
, where the head of \AgdaArgument{C} is the effect interpreted by the handler.
Each handler produces a program without the interpreted syntax i.e. just the
tail of \AgdaArgument{C} in it's effect stack and potentially modify the type
\AgdaArgument{A} to one modelling the result of the effect.
For example a handler for exceptions would remove exception syntax and transform
a program producing a value of type \AgdaArgument{A} to one producing a value of
type \AgdaArgument{E}\AgdaSpace{}\AgdaFunction{⊎}\AgdaSpace{}\AgdaArgument{A},
either an exception or a result.

A simple but important handler is the one handling the empty effect stack and
therefore the \AgdaDatatype{Void} effect.
A program containing just \AgdaDatatype{Void} syntax contains no impure
constructors, because \AgdaDatatype{Void} has no operations.
Therefore, we can always produce a value of type \AgdaArgument{A}.
This handler is important, because it can be used to escape the
\AgdaDatatype{Free} context after all other effects are handled.

\begin{code}
run : Free [] A → A
run (pure x) = x
\end{code}

\subsection{Nondeterministic Choice}
\label{nondeterminism}

The nondeterminism effect has two operations \AgdaFunction{\_⁇\_} and
\AgdaFunction{fail}.
\AgdaFunction{\_⁇\_} introduces a nondeterministic choice between two execution
paths and \AgdaFunction{fail} discards the current path.
We therefore have a nullary and a binary operation, both without additional
parameters.

$$
\Sigma_{\text{Nondet}} = \{ ?\!? : \mathbf{1} \rightsquigarrow \mathbf{2}, \mathrm{fail} : \mathbf{1} \rightsquigarrow \mathbf{0} \}
$$
Expressed as a container we have a shape with two constructors, one for each
operation and both without parameters.

\begin{code}
data Nondetˢ : Set where ⁇ˢ failˢ : Nondetˢ
\end{code}
When constructing the container we assign the correct arities to each shape.

\begin{code}
Nondet : Container
Nondet = Nondetˢ ▷ λ where
  ⁇ˢ     → Bool
  failˢ  → ⊥
\end{code}
We can now define smart constructors for each operation.
These are not the generic operations, but helper functions based on them.
The generic operations take no parameters an alaways use % no params?!?
\AgdaInductiveConstructor{pure} as continutation.
These versions of the operations already process the continuations parameter.

\begin{code}
_⁇_ : ∀ {ops} → ⦃ Nondet ∈ ops ⦄ → Free ops A → Free ops A → Free ops A
p ⁇ q = inj (⁇ˢ , (if_then p else q))

fail : ∀ {ops} → ⦃ Nondet ∈ ops ⦄ → Free ops A
fail = inj (failˢ , λ())
\end{code}
With the syntax in place we can now move on to semantics and define a handler
for the effect.
By introducing \AgdaKeyword{pattern} declarations for each operations the
handler can be simplified.
Furthermore we introduce a \AgdaKeyword{pattern} for other operations, i.e.
those who are not part of the currently handled signature.

\begin{code}
pattern Other s κ  = impure (inj₂ s , κ)
pattern Fail κ  = impure (inj₁ failˢ , κ)
pattern Choice κ  = impure (inj₁ ⁇ˢ , κ)
\end{code}
\begin{AgdaAlign}
  The handler interprets \AgdaDatatype{Nondet} syntax and removes it from the
  program.
  Therefore \AgdaDatatype{Nondet} is removed from the front of the effect stack
  and the result is wrapped in a \AgdaDatatype{List}.
  The \AgdaDatatype{List} contains the results of all successful execution
  paths.
  \begin{code}
solutions : ∀ {ops} → Free (Nondet ∷ ops) A → Free ops (List A)
  \end{code}
  The \AgdaInductiveConstructor{pure} constructor represents a program without
  effects.
  The singleton list is returned, because no nondeterminism is used in a
  \AgdaInductiveConstructor{pure} calculation.
  \begin{code}
solutions (pure x)     = pure (x ∷ [])
  \end{code}
  The \AgdaInductiveConstructor{fail} constructor represents an unsuccessful
  calculation.
  No result is returned.
  \begin{code}
solutions (Fail κ)     = pure []
  \end{code}
  In case of a \AgdaInductiveConstructor{Choice} both paths can produce an
  arbitrary number of results.
  We execute both programs recursively using \AgdaFunction{solutions} and
  collect the results in a single \AgdaDatatype{List}.
  \begin{code}
solutions (Choice κ)   = _++_ <$> solutions (κ true) ⊛ solutions (κ false)
  \end{code}
  In case of syntax from another effect we just execute \AgdaFunction{solutions}
  on every subtree by mapping the function over the container.
  Note that the newly constructed value has a different type.
  Since \AgdaDatatype{Nondet} syntax was removed from the tree the proof for
  \AgdaDatatype{\_∈\_}, which is passed to \AgdaInductiveConstructor{impure}
  changes.
  \begin{code}
solutions (Other s κ)  = impure (s , solutions ∘ κ)
  \end{code}
\end{AgdaAlign}


\subsection{State}

The state effect has two operations \AgdaFunction{get} and \AgdaFunction{put}.
The whole effect is parameterized over the state type \AgdaArgument{s}.

\AgdaFunction{get} simply returns the current state.
The operation takes no additional parameters and has \AgdaArgument{s} positions.
This can either be interpreted as \AgdaFunction{get} being an
\AgdaArgument{s}-ary operation (one child for each possible state) or simply the
parameter of the continuation being a value of type \AgdaArgument{s}.

\AgdaFunction{put} updates the current state.
The operation takes an additional parameter, the new state.
The operation itself is unary i.e. there is no return value, therefore % maybe
                                % better: that handler chooses no continuation
                                % (no return value would imply bottom)
\AgdaInductiveConstructor{tt} is passed to the rest of the program.

$$
\Sigma_{State} = \{ \mathrm{get} : \mathbf{1} \rightsquigarrow s, \mathrm{put} :
s \rightsquigarrow \mathbf{1} \}
$$
As before we will translate this definition in a corresponding container.

\begin{code}
data Stateˢ (S : Set) : Set where
  getˢ : Stateˢ S
  putˢ : S → Stateˢ S

State : Set → Container
State S = Stateˢ S ▷ λ where
  getˢ      → S
  (putˢ _)  → ⊤

pattern Get κ  = impure (inj₁ getˢ , κ)
pattern Put s κ  = impure (inj₁ (putˢ s) , κ)
\end{code}
To simplify working with the \AgdaDatatype{State} effect we add smart
constructors.
These correspond to the generic operations.

\begin{code}
get : ∀ {ops S} → ⦃ State S ∈ ops ⦄ → Free ops S
get = inj (getˢ , pure)

put : ∀ {ops S} → ⦃ State S ∈ ops ⦄ → S → Free ops ⊤
put s = inj (putˢ s , pure)
\end{code}
Using these defintions for the syntax we can define the handler for
\AgdaDatatype{State}.

\begin{AgdaAlign}
The effect handler for \AgdaDatatype{State} takes an initial state together
with a program containing the effect syntax.
The final state is returend in addition to the result.

\begin{code}
runState : ∀ {ops S} → S → Free (State S ∷ ops) A → Free ops (S × A)
\end{code}
A \AgdaInductiveConstructor{pure} calculation doesn't change the current state.
Therefore, the initial is also the final state and returned in addition to the
result of the calculation.
\begin{code}
runState s₀ (pure x)     = pure (s₀ , x)
\end{code}
The continuation/position function for \AgdaFunction{get} takes the current
state to the rest of the calculation.
By applying \AgdaArgument{s₀} to \AgdaArgument{κ} we obtain the rest of the
computation, which we can evaluate recursively.
\begin{code}
runState s₀ (Get κ)      = runState s₀ (κ s₀)
\end{code}
\AgdaFunction{put} updates the current state, therefore we pass the new state
\AgdaArgument{s₁} to the recursive call of \AgdaFunction{runState}.
\begin{code}
runState _  (Put s₁ κ)   = runState s₁ (κ tt)
\end{code}
Similar to the handler for \AgdaDatatype{Nondet} we apply the handler to every
subterm of non \AgdaFunction{State} operations.
\begin{code}
runState s₀ (Other s κ)  = impure (s , runState s₀ ∘ κ)
\end{code}
\end{AgdaAlign}

\subsubsection{Example}

Here is a simple example for a function using the \AgdaDatatype{State}
effect.
The function \AgdaFunction{tick} returns \AgdaInductiveConstructor{tt} and
as side effect increases the state.

\begin{code}
tick : ∀ {ops} → ⦃ State ℕ ∈ ops ⦄ → Free ops ⊤
tick = do i ← get ; put (1 + i)
\end{code}
Using the \AgdaFunction{runState} handler we can evaluate programs, which use
the \AgdaDatatype{State} effect.

\begin{center}
\begin{code}[inline,hide]
example₁ :
\end{code}
\begin{code}[inline]
 (run $ runState 0 $ tick >> tick) ≡ (2 , tt)
\end{code}
\begin{code}[inline,hide]
example₁ = refl
\end{code}
\end{center}

\subsubsection{Properties}

\begin{code}
module StateLaws (S : Set) (ops : List Container) (s₀ : S) where
  go : Free (State S ∷ ops) A → Free ops (S × A)
  go = runState {_} {ops} s₀

  put-put : {s₁ s₂ : S} → (go $ put s₁ >> put s₂) ≡ (go $ put s₂)
  put-put = refl

  put-get : {s : S} → (go $ put s >> get) ≡ (go $ put s >> pure s)
  put-get = refl

  get-get : {k : S → S → Free (State S ∷ ops) A}
    → (go $ get >>= λ s → get >>= k s) ≡ (go $ get >>= λ s → k s s)
  get-get = refl

  get-put : (go $ get >>= put) ≡ (go $ pure tt)
  get-put = refl
\end{code}


\section{Scoped Effects}

- Modularity
- Combination of Effects
- Semantics choosen by order of handlers
- problem with scoping operations and syntax of different effects

To correctly handle operations with local scopes Wu et al. introduced scoped
effects \cite{DBLP:conf/haskell/WuSH14}.
They presented two solutions to explicitly declare how far an operations scopes
over a program using arbitrary syntax.
In the following section we will implement the scoped effect
\AgdaDatatype{Cut} using the first order approach in Agda.
The central idea is to add new effect syntax, representing explicit scope
delimiters.
Whenever an opening delimiter is encountered the handler can be run again on the
scoped program.


\subsection{Cut and Call}

First we will define the syntax for the new effect and its delimiters.

\begin{code}
data Cutˢ : Set where cutfailˢ : Cutˢ
data Callˢ : Set where bcallˢ ecallˢ : Callˢ

pattern Cutfail = impure (inj₁ cutfailˢ , _)
pattern BCall κ = impure (inj₁ bcallˢ , κ)
pattern ECall κ = impure (inj₁ ecallˢ , κ)

Cut Call : Container
Cut   = Cutˢ    ▷ λ _ → ⊥
Call  = Callˢ   ▷ λ _ → ⊤
\end{code}
The \AgdaDatatype{Cut} effect has just a single operation, \AgdaFunction{cutfail}.
\AgdaFunction{cutfail} can only be used in a context with nondeterminism.
When \AgdaFunction{cutfail} is called it will prunes all unexplored branches and
call \AgdaFunction{fail}.
The Agda implementation of the handlers is identical to the one by Wu et al.

\begin{code}[hide] % TODO: introduce earlier
private
  variable
    ops : List Container
    i : Size
\end{code}

\begin{AgdaAlign}
The handler itself calls the function \AgdaFunction{go}, which accumulates the
unexplored alternatives in its second argument.
\AgdaFunction{fail} is the neutral element for \AgdaFunction{⁇} and therefore
the default argument.
Since this handler is not orthogonal (i.e it interacts with another effect)
\AgdaDatatype{Nondet} is required to be in scope, but its position is irrelevant.

To prove termination we mark the second argument with an arbitrary but fixed size
\AgdaArgument{i}.
The position functions for each case return subterms indexed with a smaller size.
Recursive calls to \AgdaFunction{go} with these terms as argument therefore
terminate.

\begin{code}
call : ⦃ Nondet ∈ ops ⦄ → Free (Cut ∷ ops) A → Free ops A
call = go fail
  where
    go : ⦃ Nondet ∈ ops ⦄ → Free ops A → Free (Cut ∷ ops) A {i} → Free ops A
\end{code}
In case of a \AgdaInductiveConstructor{pure} value no \AgdaFunction{cutfail}
happened.
We therefore return a calculation choosing between the value and the earlier
separated alternatives.

\begin{code}
    go q (pure a)       = (pure a) ⁇ q
\end{code}
In case of a cutfail we terminate the current computation by calling
\AgdaFunction{fail} and prune the alternatives by ignoring \AgdaArgument{q}.

\begin{code}
    go _ Cutfail        = fail
\end{code}
To interact with \AgdaDatatype{Nondet} syntax we have to find it.
We have a proof that the \AgdaDatatype{Nondet} effect is an element of the effect
list.
Whenever we find syntax from another effect we can therefore try to project the
\AgdaDatatype{Nondet} option from the coproduct.
Notice that \AgdaFunction{prj} hides the structural recursion but decreases the
\AgdaDatatype{Size} index.
We can therefore still proof that the function terminates.

\begin{code}
    go q p@(Other s κ)  with prj {Nondet} p
\end{code}
The case for \AgdaFunction{⁇} separates the main branch from the alternative.
Using \AgdaFunction{go} the \AgdaDatatype{Cut} syntax is removed from both
alternatives, but the results are handled asymmetrically.
The left option is direclty passed to the recursive call of
\AgdaFunction{go}.
The handeled right option is the new alternative for the left one and therefore
could be pruned if left contains a \AgdaFunction{cutfail} call.

\begin{code}
    ... | just (⁇ˢ     , κ′)  = go (go q (κ′ false)) (κ′ true)
\end{code}
When encountering a \AgdaFunction{fail} we continue with the accumulated
alternatives.

\begin{code}
    ... | just (failˢ  , _ )  = q
\end{code}
Syntax from other effects is handled as usual.

\begin{code}
    ... | nothing             = impure (s , go q ∘ κ)
\end{code}
\end{AgdaAlign}
With the handler for \AgdaDatatype{Cut} in place we can define the handler for the
scope delimiters.
The implementation is again similar to the one presented by Wu et al., but to
proof termination we again have to add \AgdaDatatype{Size} annotations to the
functions.

The \AgdaFunction{bcall} and \AgdaFunction{ecall} handler remove the scope
delimiter syntax from the program and run \AgdaFunction{call} (the handler
for \AgdaDatatype{cut}) at the begining of each scope.
Whenever a \AgdaFunction{BCall} is found the handler \AgdaFunction{ecall} is
used to handle the rest of the program.
\AgdaFunction{ecall} searches for the end of the scope and returns the program
up to that point.
The rest of the program is the result of the returned program.

A valid upper bound for the size of the rest of the program is \AgdaArgument{i},
the size of the program before separating the syntax after the closing delimiter.
This fact is curcial to proof that the recursive calls to \AgdaFunction{bcall} and
\AgdaFunction{ecall} using \AgdaFunction{>>=} terminate.

Calling the handler on the extracted program guaranties that the handler does
not interact with syntax outside the intended scope.
Nested scopes are handled using recursive calls to \AgdaFunction{ecall} if
\AgdaFunction{BCall} operations are encountered while searching a closing
delimiter.

Since the delimiters could be placed freely it is possible to mismatch them.
If we encounter a closing before and operening delimiter, we know that they are
mismatched.
Wu et al. use Haskells \texttt{error} function to terminate the program.
In Agda we are not allowed to define partial functions, therefore we have to
handle the error.
We could either correct the error and just continue or short circuit the
calculation using exceptions in form of e.g. a \AgdaDatatype{Maybe} monad.
For simplicity we will use the former approach.
In a real application it would be advisable to inform the programmer about the
error, either using exceptions or at least trace the error.

\begin{code}
bcall : ⦃ Nondet ∈ ops ⦄ → Free (Call ∷ Cut ∷ ops) A {i} → Free (Cut ∷ ops) A
ecall : ⦃ Nondet ∈ ops ⦄ → Free (Call ∷ Cut ∷ ops) A {i}
  → Free (Cut ∷ ops) (Free (Call ∷ Cut ∷ ops) A {i})

bcall (pure x)     = pure x
bcall (BCall κ)    = upcast (call (ecall (κ tt))) >>= bcall
bcall (ECall κ)    = bcall (κ tt) -- Unexpected ECall! We just fix the error.
bcall (Other s κ)  = impure (s , bcall ∘ κ)

ecall (pure x)     = pure (pure x)
ecall (BCall κ)    = upcast (call (ecall (κ tt))) >>= ecall
ecall (ECall κ)    = pure (κ tt)
ecall (Other s κ)  = impure (s , ecall ∘ κ)
\end{code}
Using the handlers defined above we can define a handler for scoped
\AgdaDatatype{Cut} syntax, which removes \AgdaDatatype{Cut} and
\AgdaDatatype{Call} syntax simultaneously.
The delimiters and correctly scoped \AgdaDatatype{Cut} syntax is removed using
\AgdaFunction{bcall} and potential unscoped \AgdaDatatype{Cut} syntax is
removed with a last use of \AgdaFunction{call}.
The function \AgdaFunction{call′} is a smart constructor for the scope
delimiters.

\begin{code}
runCut : ⦃ Nondet ∈ ops ⦄ → Free (Call ∷ Cut ∷ ops) A → Free ops A
runCut = call ∘ bcall

call′ : ⦃ Call ∈ ops ⦄ → Free ops A → Free ops A
call′ p = do op bcallˢ ; x ← p ; op ecallˢ ; pure x
\end{code}

\section{Call-Time Choice as Effect}

Bunkenburg presented an approach to model call-time choice as a stack of
scoped algebraic effects \cite{bunkenburg2019modeling}.
In this section we will extend the nondeterminism effect from section
\ref{nondeterminism} to one modelling call-time choice.

As explained in section \ref{call-time-choice}, call-time choice semantics
describe the interaction between sharing and nondeterminism.
The current implementation of \AgdaDatatype{Nondet} does not support sharing
i.e. it is not possible for two choice to be linked.
Based on Bunkenburgs implementation we will make two changes to the
nondeterminism effect.
Each choice is augmented with an an identifier consisting of a triple of natural
numbers, called \textit{choice id}.
The first two are used to identity the current scope and will be refereed to as
\textit{scope id}.
The third numbers identifies the choice inside it's scope.
Furthermore, instead of producing a list the handler will now produce a tree of
choices.
This change allows to choose the evaluation strategy, e.g. depth first or breath
first search, independent of the handler.
