\begin{code}[hide]
{-# OPTIONS --overlapping-instances #-}
module FirstOrder where

open import Level using (Level; suc; zero; _⊔_)
open import Function
open import Size using (Size; ↑_)

open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Empty using (⊥)
open import Data.List using (List; []; _∷_; _++_; foldr)
open import Data.List.Properties using (++-identityʳ)
open import Data.Nat using (ℕ; _+_)
open import Data.Nat.Properties using (<-strictTotalOrder)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.Product using (Σ-syntax; _×_; _,_; proj₂)
open import Data.Product.Relation.Binary.Lex.Strict using (×-strictTotalOrder)
open import Data.Sum using (_⊎_; [_,_]; inj₁; inj₂)
open import Data.Unit using (⊤; tt)

order = ×-strictTotalOrder (×-strictTotalOrder <-strictTotalOrder <-strictTotalOrder) <-strictTotalOrder
open import Data.Tree.AVL.Map order using (Map; empty; insert; lookup)

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl; cong; sym)
open Eq.≡-Reasoning using (begin_; _≡⟨⟩_; step-≡; _∎)

postulate
  extensionality : ∀ {ℓ ℓ′ : Level} {A : Set ℓ} {B : A → Set ℓ′} {f g : (x : A) → B x}
      → (∀ (x : A) → f x ≡ g x) → f ≡ g

record Container : Set₁ where
  constructor _▷_
  field
    Shape : Set
    Pos : Shape → Set
open Container public

⟦_⟧ : {ℓ : Level} → Container → Set ℓ → Set ℓ
⟦ S ▷ P ⟧ A = Σ[ s ∈ S ] (P s → A)
\end{code}

The following sections describe the implementation of algebraic and scoped
effects in the first order setting.
We focus on implementation details specific to Agda like termination and
positivity checks.
The scoped effects are implemented using explicit scope delimiters as described
by \textcite{DBLP:conf/haskell/WuSH14}.


\section{Functors {\`{a}} la carte}
\label{first-order:functor}

When modelling effects each functor represents the syntax i.e. the operations of
an effect.
For containers each shape constructor corresponds to an operation symbol and the
type of position for a shape corresponds to the arity set for the operation.
The additional parameter of an operation is embedded in the shape.
The free monad over a container describes a program using the effect's syntax
i.e. it is the free model for the algebra without the equations.
To combine the syntax of multiple effects we can combine the underlying
functors, because the free monad preserves coproducts\footnote{This follows from
the facts that \texttt{Free} is the left half of a free-forgetful adjunction and
that all left-adjoints preserve colimits.}.

The approach described by \textcite{DBLP:conf/haskell/WuSH14} is based on
\citetitle{DBLP:journals/jfp/Swierstra08} by
\textcite{DBLP:journals/jfp/Swierstra08}.
The functor coproduct is modelled as the data type \mintinline{haskell}{data (f
:+: g) a = Inl (f a) | Inr (g a)}, which is again a \texttt{Functor} in
\texttt{a}.
In section \ref{chapter:preliminaries:free-monad} we defined the free monad over
a strictly positive functor, which was represented by a \AgdaDatatype{Container}.
We could use a similar data type to combine the extensions of two containers,
but we would lose the advantages of containers i.e. that container extension is
a strictly positive functor.
Containers are closed under multiple operations, coproducts being one of
them~\cite{DBLP:conf/fossacs/AbbottAG03}.
Therefore, we can combine two container functors by combining the underlying
containers.
The coproduct of two containers $F$ and $G$ is the container whose
\AgdaFunction{shape} is the disjoint union of $F$'s and $G$'s shapes and whose
position function \AgdaFunction{pos} is the coproduct mediator of $F$'s and
$G$'s position functions\footnote{The function \AgdaFunction{[\_,\_]}
corresponds to the Haskell function \mintinline{haskell}{either :: (a -> c) ->
(b -> c) -> Either a b -> c}.}.

\begin{code}[hide]
infixr 1 _⊕_
\end{code}
\begin{code}
_⊕_ : Container → Container → Container
(Shape₁ ▷ Pos₁) ⊕ (Shape₂ ▷ Pos₂) = (Shape₁ ⊎ Shape₂) ▷ [ Pos₁ , Pos₂ ]
\end{code}
The functor represented by the coproduct of two containers is isomorphic to the
functor coproduct of their representations.
The container without shapes is the neutral element for the coproduct of
containers\footnote{It is the initial element in the category of containers
  over set, because $\mathbb{0}$ is initial in set.}.
This allows us to define $n$-ary coproducts for containers.

\begin{code}
sum : List Container → Container
sum  = foldr (_⊕_) (⊥ ▷ λ())
\end{code}
To generically work with arbitrary coproducts of functors we define two utility
functions.
Given a value $x:A$ we want to be able to inject it into any coproduct
mentioning $A$.
Given any coproduct mentioning $A$ we want to be able to project a value of
type $A$ from the coproduct, if the coproduct was constructed using a value of
type $A$.
Therefore, we produce a value of type
\AgdaDatatype{Maybe}\AgdaSpace{}\AgdaArgument{A} and return
\AgdaInductiveConstructor{nothing} in case the coproduct was constructed
differently.

In the
\citetitle{DBLP:journals/jfp/Swierstra08}~\cite{DBLP:journals/jfp/Swierstra08}
approach the type class \texttt{:<:} is introduced.
\texttt{:<:} relates a functor to a coproduct of functors, marking it as an
option in the coproduct.
\texttt{:<:}'s functions can be used to inject or potentially extract values
from a coproduct.
The two instances for \texttt{:<:} mark $F$ as an element of the coproduct if
it's on the left-hand side of the coproduct (in the head) or if it's already
in the right-hand side (in the tail).
Usually one would add a third instances \texttt{f :<: f}, relating \texttt{f} to
itself, but this instance is not needed if the last functor is always
\texttt{Void}.

\begin{minted}{haskell}
     class (Syntax sub, Syntax sup) => sub :<: sup where
       inj :: sub m a -> sup m a
       prj :: sup m a -> Maybe (sub m a)

     instance {-# OVERLAPPABLE #-} (Syntax f, Syntax g) => f :<: (f :+: g) where
       inj = Inl
       prj (Inl a) = Just a
       prj _       = Nothing

     instance {-# OVERLAPPABLE #-} (Syntax h, f :<: g) => f :<: (h :+: g) where
       inj = Inr . inj
       prj (Inr ga) = prj ga
       prj _        = Nothing
\end{minted}
The two instances overlap, resulting in possible slower instance resolution.
Furthermore, \texttt{:+:} is assumed to be right associative and only to be
used in a right associative way to avoid backtracking.
Because in Agda the result of \AgdaFunction{\_⊕\_} is another container, not
just a value of a simple data type, instance resolution using
\AgdaFunction{\_⊕\_} is not as straight forward as in Haskell and in some cases
extremely slow\footnote{We encountered cases where type checking of overlapping
instances involving \AgdaFunction{\_⊕\_} did not seem to terminate.}.

This implementation of the free monad uses an approach similar to the Idris
effect library \cite{DBLP:conf/icfp/Brady13}.
The free monad is not parameterised over a single container, but a list
\AgdaArgument{ops} of containers.
This has the benefit that we cannot associate coproducts to the left by
accident.
The elements of the list are combined later using \AgdaFunction{sum}.
To track which functors are part of the coproduct we introduce the new type
\AgdaDatatype{\_∈\_}.

\begin{code}[hide]
infix 4 _∈_
\end{code}
\begin{code}
data _∈_ {ℓ : Level} {A : Set ℓ} (x : A) : List A → Set ℓ where
  instance
    here   : ∀ {xs} → x ∈ x ∷ xs
    there  : ∀ {y xs} → ⦃ x ∈ xs ⦄ → x ∈ y ∷ xs
\end{code}
The type
\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{∈}\AgdaSpace{}\AgdaArgument{xs}
represents the proposition that \AgdaArgument{x} is an element of
\AgdaArgument{xs}.
The two constructors can be read as inference rules.
One can always construct a proof that \AgdaArgument{x} is in a list with
\AgdaArgument{x} in its head and given a proof that
\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{∈}\AgdaSpace{}\AgdaArgument{xs}
one can construct a proof that \AgdaArgument{x} is also in the extended list
\AgdaArgument{y}\AgdaSpace{}\AgdaInductiveConstructor{∷}\AgdaSpace{}\AgdaArgument{xs}.

The two instances still overlap resulting in an exponential slowdown in instance
resolution\footnote{\url{https://agda.readthedocs.io/en/v2.6.1.1/language/instance-arguments.html\#overlapping-instances}}.
Using Agdas internal instance resolution can be avoided by using a tactic to
infer \AgdaDatatype{\_∈\_} arguments.
For simplicity the following code will still use instance arguments.
This version can easily be adapted to one using macros, by replacing the
instance arguments with hidden ones with \AgdaKeyword{tactic} annotations.

Using this proposition we can define functions for injection into and projection
out of coproducts.

\begin{code}
inject : ∀ {C ops ℓ} {A : Set ℓ} → C ∈ ops → ⟦ C ⟧ A → ⟦ sum ops ⟧ A
inject here           (s , pf)  = (inj₁ s) , pf
inject (there ⦃ p ⦄)  prog      with inject p prog
... | s , pf = (inj₂ s) , pf

project : ∀ {C ops ℓ} {A : Set ℓ} → C ∈ ops → ⟦ sum ops ⟧ A → Maybe (⟦ C ⟧ A)
project here           (inj₁ s , pf)  = just (s , pf)
project here           (inj₂ _ , _ )  = nothing
project there          (inj₁ _ , _ )  = nothing
project (there ⦃ p ⦄)  (inj₂ s , pf)  = project p (s , pf)
\end{code}
Both \AgdaFunction{inject} and \AgdaFunction{project} require a proof that
specific container is an element of the list used to construct the coproduct.

Let us consider \AgdaFunction{inject} first.
By pattern matching on the evidence we acquire more information about the type
\AgdaFunction{sum}\AgdaSpace{}\AgdaArgument{ops}.
In case of \AgdaInductiveConstructor{here} we know that \AgdaArgument{op} is in
the head of the list i.e. that the given value \AgdaArgument{C}
is the same as the one in the head of the list.
Therefore the \AgdaField{Shape} types are the same and we can use our given
\AgdaArgument{s} and \AgdaArgument{pf} to construct the coproduct.
In case of \AgdaInductiveConstructor{there} we obtain a proof that the container
is in the tail of the list, which we can use to make a recursive call.
By pattern matching on and repackaging the result we obtain a value of the right
type.

\AgdaFunction{project} functions similarly.
By pattern matching on the proof we either know that the value we found has
the correct type or we obtain a proof for the tail of the list allowing us to
either make a recursive call or stop the search.


\subsection{The Free Monad for Effect Handling}
\label{first-order:free-monad}

Using the coproduct machinery we can now define a version of the free monad,
suitable for working with effects.
In contrast to the first definition, this free monad is parameterized over a
list of containers.
In the \AgdaInductiveConstructor{impure} constructor the containers are combined
using \AgdaFunction{sum}.
The parameterization over a list ensures that the containers are not combined
prematurely.

\begin{code}
data Free (ops : List Container) (A : Set) : {Size} → Set where
  pure    : ∀ {i} → A → Free ops A {i}
  impure  : ∀ {i} → ⟦ sum ops ⟧ (Free ops A {i}) → Free ops A {↑ i}
\end{code}
The free monad is indexed over an argument of Type \AgdaDatatype{Size}.
We follow the pattern described in section \ref{preliminaries:sized-types}, to
annotate the data type.
\AgdaInductiveConstructor{pure} values have an arbitrary size.
When constructing an \AgdaInductiveConstructor{impure} value the new value is
strictly larger than the ones produced by the container's position function.
The size annotation therefore corresponds to the height of the tree described by
the free monad.
Using the annotation it is possible to prove that functions preserve the size of
a value or that complex recursive functions terminate.

Next we define utility functions for working with the free monad.
\AgdaFunction{inj} and \AgdaFunction{prj} provide the same functionality as the
ones used by \textcite{DBLP:conf/haskell/WuSH14}.
\AgdaFunction{inj} allows to inject syntax into a program whose signature allows
the operation.
\AgdaFunction{prj} allows to inspect the next operation of a
program, restricted to a specific signature.
Furthermore we add the functions \AgdaFunction{op} and \AgdaFunction{upcast}.
\AgdaFunction{op} generates the generic operation for any operation symbol.
\AgdaFunction{upcast} transformes a program using any signature to one using a
larger signature.
Notice that \AgdaFunction{upcast} preserves the size of its input, because it
just traverses the tree and repackages the contents.
\AgdaFunction{prj} decreases the input of its argument by one, because it
deconstructs the root of the given tree.
These size preserving functions are essential when we later define handlers.

\begin{code}
inj : ∀ {C ops A} → ⦃ C ∈ ops ⦄ → ⟦ C ⟧ (Free ops A) → Free ops A
inj ⦃ p ⦄ = impure ∘ inject p

prj : ∀ {C ops A i} → ⦃ C ∈ ops ⦄ → Free ops A {↑ i} → Maybe (⟦ C ⟧ (Free ops A {i}))
prj ⦃ p ⦄ (pure x)    = nothing
prj ⦃ p ⦄ (impure x)  = project p x

op : ∀ {C ops} → ⦃ C ∈ ops ⦄ → (s : Shape C) → Free ops (Pos C s)
op s = inj (s , pure)

upcast : ∀ {C ops A i} → Free ops A {i} → Free (C ∷ ops) A {i}
upcast (pure x) = pure x
upcast (impure (s , κ)) = impure (inj₂ s , upcast ∘ κ)
\end{code}
Next we define the basic monadic operations for the above monad.
Usually \AgdaFunction{>>=} and \AgdaFunction{return} would be enough to define
all the other functions, but \AgdaFunction{>>=} is not size preserving, while
some other functions can be defined such that they are.
For example, later we will rely on the fact that \AgdaFunction{<\$>} preserves
the size of its argument.
Consider the following definition of \AgdaFunction{fmap} for the free
monad\footnote{in the following code $A$, $B$ and $C$ are arbitrary types}.

\begin{code}[hide]
variable
  ℓᵃ ℓᵇ ℓᶜ : Level
  i : Size
  A : Set ℓᵃ
  B : Set ℓᵇ
  C : Set ℓᶜ
  ops : List Container

infixl 1 _>>=_ _>>_
infixl 4 _<$>_ _<*>_
\end{code}
\begin{code}
fmap _<$>_ : {F : List Container} {i : Size} → (A → B) → Free F A {i} → Free F B {i}
f <$> pure x           = pure (f x)
f <$> impure (s , pf)  = impure (s , (f <$>_) ∘ pf)

fmap = _<$>_
\end{code}
\AgdaFunction{fmap} applies the given function \AgdaArgument{f} to the values
stored in the \AgdaInductiveConstructor{pure} leafs.
The height of the tree is left unchanged.
This fact is wittnessed by the same index \AgdaArgument{i} on the argument and
return type.

In contrast to \AgdaFunction{fmap}, \AgdaFunction{bind} does not preserve the
size.
\AgdaFunction{bind} replaces every \AgdaInductiveConstructor{pure} leaf with a
subtree, which is generated from the stored value.
The resulting tree is therefore at least as high as the given one.
Because there is no addition for sized types the only correct size estimate for
the returned value is unbounded (\AgdaInductiveConstructor{∞}).
This means that by using \AgdaFunction{>>=} on a value we lose our size
esstimate.
This is a problem in recursive functions, because in terms of termination
checking it renders the annotation useless.
For later programs using effects this is not a problem, because should not rely
on the size annotation of the free monad, because they should not recurse on a
value of type \AgdaDatatype{Free}.
The return type is not explicitly indexed, because the compiler correctly
infers \AgdaInductiveConstructor{∞}.

\begin{code}
_>>=_ : ∀ {ops} → Free ops A → (A → Free ops B) → Free ops B
pure x           >>= k = k x
impure (s , pf)  >>= k = impure (s , (_>>= k) ∘ pf)

_>>_ : ∀ {ops} → Free ops A → Free ops B → Free ops B
ma >> mb = ma >>= λ _ → mb
\end{code}
To complete our basic set of monadic functions we also define \AgdaFunction{ap}.

\begin{code}
_<*>_ : ∀ {ops} → Free ops (A → B) → Free ops A → Free ops B
pure f           <*> ma = f <$> ma
impure (s , pf)  <*> ma = impure (s , (_<*> ma) ∘ pf)
\end{code}

\subsection{Properties}
\label{first-order:free-monad:properties}

The definition of the free monad from section \ref{first-order:free-monad} is a
functor because it satisfies the two functor laws.
The two laws state that the lifting of morphisms via \AgdaFunction{fmap}
preserves identity and the composition of morphisms.

Both properties are proven by structural induction over the free monad.
Let us consider the first proof.
It is written using chain reasoning operators to display the general structure
of the later proofs
In the definition of \AgdaFunction{<\$>}, in the case for
\AgdaInductiveConstructor{pure} the given function is simply applied to the
stored value.
Therefore, the base case is proven by \AgdaInductiveConstructor{refl}.
In the induction step we reach a point were we have to show the equivalence of
the two continuations.
Using \AgdaFunction{cong} we reduce the equality on the whole terms to the
equality on the continuations.
Next we invoke \AgdaFunction{extensionality} to show point-wise equivalence.
This equivalence is exactly the induction hypothesis, which we obtain using a
recursive call.

Because all steps using \AgdaFunction{≡⟨⟩} are proven by
\AgdaInductiveConstructor{refl} they can be omitted.
The other proofs follow the same pattern and can therefore are written more
concise.

\begin{code}[number=fmap-id]
fmap-id : (p : Free ops A) → fmap id p ≡ p
fmap-id (pure x)           = refl
fmap-id (impure (s , pf))  = begin
  fmap id (impure (s , pf))          ≡⟨⟩ -- definition of fmap
  impure (s , fmap id ∘ pf)          ≡⟨⟩ -- definition of ∘
  impure (s , λ p → fmap id (pf p))  ≡⟨ cong (λ t → impure (s , t))
                                         (extensionality λ p → fmap-id (pf p)) ⟩
  impure (s , λ p → pf p)            ≡⟨⟩ -- η-conversion
  impure (s , pf)                    ∎
\end{code}
\begin{code}[number=fmap-comp]
fmap-∘ : ∀ (f : B → C) (g : A → B) (p : Free ops A) →
  fmap (f ∘ g) p ≡ (fmap f ∘ fmap g) p
fmap-∘ f g (pure x)           = refl
fmap-∘ f g (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (fmap-∘ f g ∘ pf))
\end{code}
Later we will need the interchange law for applicative functors.
Based on the definition of \AgdaFunction{<*>} it allows us to reduce a call to
\AgdaFunction{<*>} with a \AgdaInductiveConstructor{pure} second argument to one
to \AgdaFunction{<\$>}.

\begin{code}[number=ap-interchange]
interchange : ∀ a (f : Free ops (A → B)) →
  (f <*> pure a) ≡ (pure (_$ a) <*> f)
interchange a (pure f)          = refl
interchange a (impure (s , κ))  = cong (impure ∘ (s ,_)) (extensionality (interchange a ∘ κ))
\end{code}
\begin{code}[hide]
-- composition : (f : Free ops (B → C)) (g : Free ops (A → B)) (a : Free ops A) →
--    (f <*> (g <*> a)) ≡ (pure _∘′_ <*> f <*> g <*> a)
-- composition f g (pure x) = {!!}
-- composition f g (impure x) = {!!}
\end{code}
This definition of the free monad also satisfies the three monad laws.
Written using the kleisli composition (\AgdaFunction{>=>}) they reduce to the
laws for morphism composition in a category i.e.
\AgdaInductiveConstructor{pure} is the left and right identity for the
associtative composition.
We are more interessted in this formulation, because it is the one occuring more
directly in programs.

\begin{code}[number=bind-ident-left]
bind-identˡ : ∀ {ops} (f : A → Free ops B) (x : A) → (pure x >>= f) ≡ f x
bind-identˡ f x = refl
\end{code}
\begin{code}[number=bind-ident-right]
bind-identʳ : ∀ {ops} (x : Free ops A) → (x >>= pure) ≡ x
bind-identʳ (pure x)           = refl
bind-identʳ (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (bind-identʳ ∘ pf))
\end{code}
\begin{code}[number=bind-assoc]
bind-assoc : ∀ {ops} (f : A → Free ops B) (g : B → Free ops C) (p : Free ops A) →
  ((p >>= f) >>= g) ≡ (p >>= (λ x → f x >>= g)) -- inner parens can be omitted
bind-assoc f g (pure x)           = refl
bind-assoc f g (impure (s , pf))  = cong (impure ∘ (s ,_)) (extensionality (bind-assoc f g ∘ pf))
\end{code}

\section{Handler}

Usually, an effect handler removes and interprets the syntax of an effect.
In the simplest case the handler replaces the effect syntax with a corresponding
implementation in the host language.
It maps from the free model to a model in the language i.e. it transforms an
impure to a pure computation.
Therefore, the handler induced semantics for the effects.
Some handlers manipulate syntax of other effects or the structure of the program
itself.
These handlers are usually called \textit{non-orthogonal handlers}.

All handlers in the following sections will have the same basic structure.
They will take a program i.e. a variable of type
\AgdaDatatype{Free}\AgdaSpace{}\AgdaArgument{C}\AgdaSpace{}\AgdaArgument{A},
where the head of \AgdaArgument{C} is the effect interpreted by the handler.
Each handler produces a program without the interpreted syntax i.e. just the
tail of \AgdaArgument{C} in it's effect stack and potentially modify the type
\AgdaArgument{A} to one modelling the result of the effect.
For example a handler for exceptions would remove exception syntax and transform
a program producing a value of type \AgdaArgument{A} to one producing a value of
type \AgdaArgument{E}\AgdaSpace{}\AgdaFunction{⊎}\AgdaSpace{}\AgdaArgument{A},
either an exception or a result.

A simple but important handler is the one handling the empty effect stack and
therefore the \AgdaDatatype{Void} effect.
A program containing just \AgdaDatatype{Void} syntax contains no
\AgdaInductiveConstructor{impure} constructors, because \AgdaDatatype{Void} has
no operations i.e. its \AgdaField{Shape} type has no constructors.
Pattern matching on the impure constructor yields $()$.

Therefore, we can always produce a value of type \AgdaArgument{A}.
The handler for \AgdaDatatype{Void} is important, because it can be used to
escape the \AgdaDatatype{Free} context after all other effects have been
handled.

\begin{code}
run : Free [] A → A
run (pure x) = x
\end{code}

The following two sections describe the implementation of handlers for
\AgdaDatatype{State} and \AgdaDatatype{Nondeterminism}.
By means of examples, they explain the construction of handlers as well as
lay ground work for more complex handlers.


\subsection{Nondeterministic Choice}
\label{nondeterminism}

The nondeterminism effect has two operations \AgdaFunction{\_⁇\_} and
\AgdaFunction{fail}.
\AgdaFunction{\_⁇\_} introduces a nondeterministic choice between two execution
paths and \AgdaFunction{fail} discards the current path.
We therefore have a nullary and a binary operation, both without additional
parameters.

$$
\Sigma_{\text{Nondet}} = \{ ?\!? : \mathbf{1} \leadsto \mathbf{2}, \mathrm{fail}
: \mathbf{1} \leadsto \mathbf{0} \}
$$
Expressed as a container we have a shape with two constructors, one for each
operation and both without parameters.

\begin{code}
data Nondetˢ : Set where ⁇ˢ failˢ : Nondetˢ
\end{code}
When constructing the container we assign the correct arities to each shape.

\begin{code}
Nondet : Container
Nondet = Nondetˢ ▷ λ where
  ⁇ˢ     → Bool
  failˢ  → ⊥
\end{code}
We can now define smart constructors for each operation.
These are not the generic operations, but helper functions based on them.
The generic operations take no additional parameters and always use
\AgdaInductiveConstructor{pure} as continuation.
These versions of the operations already process the continuations parameter.
The generic \AgdaFunction{⁇} operation nondeterministicly produces a boolean,
but usually we want to use it analogous to Curry's \texttt{?} operator,
therefore we implement this refined version.
\AgdaFunction{op}\AgdaSpace{}\AgdaInductiveConstructor{failˢ} produces a
computation with result type \AgdaDatatype{⊥} i.e. the operation has no
continuations.
To avoid continuing with $λ()$ after every call of \AgdaFunction{fail} (to
produce a computation of the correct type) we add the continuation to the smart
constructor.

\begin{code}
_⁇_ : ∀ {ops} → ⦃ Nondet ∈ ops ⦄ → Free ops A → Free ops A → Free ops A
p ⁇ q = op ⁇ˢ >>= λ b → if b then p else q

fail : ∀ {ops} → ⦃ Nondet ∈ ops ⦄ → Free ops A
fail = op failˢ >>= λ()
\end{code}
With the syntax in place we can now move on to semantics and define a handler
for the effect.
By introducing \AgdaKeyword{pattern} declarations for each operations the
handler can be simplified.
Furthermore we introduce a \AgdaKeyword{pattern} for other operations, i.e.
those who are not part of the currently handled signature.

\begin{code}
pattern Other s κ  = impure (inj₂ s , κ)
pattern Fail κ     = impure (inj₁ failˢ , κ)
pattern Choice κ   = impure (inj₁ ⁇ˢ , κ)
\end{code}
\begin{AgdaAlign}
  The handler interprets \AgdaDatatype{Nondet} syntax and removes it from the
  program.
  Therefore \AgdaDatatype{Nondet} is removed from the front of the effect stack
  and the result is wrapped in a \AgdaDatatype{List}.
  The \AgdaDatatype{List} contains the results of all successful execution
  paths.
  \begin{code}
solutions : ∀ {ops} → Free (Nondet ∷ ops) A → Free ops (List A)
  \end{code}
  The \AgdaInductiveConstructor{pure} constructor represents a program without
  effects.
  The singleton list is returned, because no nondeterminism is used in a
  \AgdaInductiveConstructor{pure} calculation.
  \begin{code}
solutions (pure x)     = pure (x ∷ [])
  \end{code}
  The \AgdaInductiveConstructor{fail} constructor represents an unsuccessful
  calculation.
  No result is returned.
  \begin{code}
solutions (Fail κ)     = pure []
  \end{code}
  In case of a \AgdaInductiveConstructor{Choice} both paths can produce an
  arbitrary number of results.
  We execute both programs recursively using \AgdaFunction{solutions} and
  collect the results in a single \AgdaDatatype{List}.

  $\llparenthesis$ and $\rrparenthesis$ are \textit{idiom brackets} and denote
  applicative functor style function application i.e.
  \AgdaInductiveConstructor{pure}\AgdaSpace{}\AgdaArgument{f}\AgdaSpace{}\AgdaFunction{<*>}$\dots$\AgdaFunction{<*>}$\dots$\AgdaFunction{<*>}$\dots$.
  In this case the function \AgdaArgument{f} is the mixfix operator
  \AgdaFunction{\_++\_} which can still be written in infix notation.
  \begin{code}
solutions (Choice κ)   = ⦇ solutions (κ true) ++ solutions (κ false) ⦈
  \end{code}
  In case of syntax from another effect we just execute \AgdaFunction{solutions}
  on every subtree by mapping the function over the container.
  Note that the newly constructed value has a different type.
  \AgdaInductiveConstructor{Other} hides the \AgdaInductiveConstructor{inj₂}
  constructor, therefore the newly constructed \AgdaInductiveConstructor{impure}
  value is of type
  \AgdaDatatype{Free}\AgdaSpace{}\AgdaArgument{ops}\AgdaSpace{}$($\AgdaDatatype{List}\AgdaSpace{}\AgdaArgument{A}$)$.
  \begin{code}
solutions (Other s κ)  = impure (s , solutions ∘ κ)
  \end{code}
\end{AgdaAlign}


\subsubsection{Properties}
\label{first-order:nondet:properties}

As explained in section \ref{preliminaries:free-monad}, the free monad
represents the free model for the theory without equations i.e. some terms
should be equal but are not.
The handler for an algebraic effect defines its semantics by removing and
interpreting its syntax.
The result of a handler should again be a model for the effect i.e. the
equations characterizing the effect should hold.
We can proof that our handler produces a valid (but not necessarily free) model
for our equations by verifying that the laws holds after interpreting the terms.
The ability to rigorously proof these laws about the program is one of the main
advantages of Agda.

We have four laws governing our \AgdaDatatype{Nondet} effect.
The first law states that \AgdaFunction{const}\AgdaSpace{}\AgdaFunction{fail}
should be an absorbing element for the Kleisli composition.

\begin{code}[number=fail-annihilating]
bind-fail : {k : A → Free (Nondet ∷ ops) B} → 
  solutions (fail >>= k) ≡ solutions fail
bind-fail = refl
\end{code}
The proof is trivial, because \AgdaFunction{fail} has no continuations.
Simplifying both sides yields \AgdaFunction{fail}.

The other three laws state that \AgdaFunction{⁇} and \AgdaFunction{fail} form a
monoid.
The proofs for all three are similar.
By using functor, applicative and monad laws one can reduce the proof to one for
pure lists and simply use the corresponding equality from the standard library.

\begin{code}
⁇-identˡ : (q : Free (Nondet ∷ ops) A) → solutions (fail ⁇ q) ≡ solutions q
⁇-identˡ q = begin
  solutions (fail ⁇ q)                      ≡⟨⟩ -- definition of handler for ⁇
  _++_ <$> solutions fail  <*> solutions q  ≡⟨⟩ -- definition of handler for fail
  _++_ <$> pure []         <*> solutions q  ≡⟨⟩ -- definition of <$>
  pure ([] ++_)            <*> solutions q  ≡⟨⟩ -- definition of <*> / ap-ident-left
  [] ++_                   <$> solutions q  ≡⟨⟩ -- definition of ++ / ++-ident-left
  id                       <$> solutions q  ≡⟨ fmap-id (solutions q) ⟩
  solutions q                               ∎
\end{code}
The proof for the left identity is straight forward.
No standard library equality is needed, because \AgdaFunction{++} is recursive
in its first argument.
To eliminate \AgdaFunction{<\$>} a functor law is needed.

\begin{code}
⁇-identʳ : (p : Free (Nondet ∷ ops) A) → solutions (p ⁇ fail) ≡ solutions p
⁇-identʳ p = begin
  solutions (p ⁇ fail)                          ≡⟨⟩ -- definition of handler
  _++_ <$> solutions p        <*> pure []       ≡⟨ interchange [] (_++_ <$> solutions p) ⟩
  pure (_$ [])    <*>  (_++_  <$> solutions p)  ≡⟨⟩ -- definition of <*> / ap-ident-left
  (_$ [])         <$>  (_++_  <$> solutions p)  ≡⟨ sym (fmap-∘ (_$ []) _++_ (solutions p)) ⟩
  (_$ [])         ∘    _++_   <$> solutions p   ≡⟨⟩ -- definition of ∘ and $
  (_++ [])                    <$> solutions p   ≡⟨ cong  (_<$> solutions p)
                                                         (extensionality ++-identityʳ) ⟩
  id                          <$> solutions p   ≡⟨ fmap-id (solutions p) ⟩
  solutions p                                   ∎
\end{code}
Proving the right identity is more complicated, because \AgdaFunction{fail} is
on the right-hand side of \AgdaFunction{⁇}.
All monad functions from section \ref{first-order:free-monad} are recursive in
their left argument, therefore most propositions involving right arguments do
not follow trivially from the definition and need own proofs.

This is a common pattern.
Because \AgdaFunction{++} is recursive in its first argument, the left
identity is given by definitional equality, while the right one is not, but
follows from the definition.
Notice that partially applying \AgdaFunction{++} with
\AgdaInductiveConstructor{[]} is only equal to \AgdaFunction{id} on the left
without invoking \AgdaFunction{extensionality}.

Using the proofs from section \ref{first-order:free-monad:properties} we
can simplify the equations and reduce them to a problem for normal
\AgdaDatatype{List}.
The proof for associativity is longer, but follows the same patterns.

\begin{code}[hide]
-- ⁇-assoc : (p q r : Free (Nondet ∷ ops) A) →
--   solutions ((p ⁇ q) ⁇ r) ≡ solutions (p ⁇ (q ⁇ r))
-- ⁇-assoc p q r = begin
--     solutions ((p ⁇ q) ⁇ r)
--   ≡⟨⟩
--     _++_ <$> (_++_ <$> solutions p <*> solutions q) <*> solutions r
--   ≡⟨ cong (_<*> solutions r) (composition (pure _++_) (_++_ <$> solutions p) (solutions q)) ⟩
--     (_++_ ∘′_) <$> (_++_ <$> solutions p) <*> solutions q <*> solutions r
--   ≡⟨ cong (λ t → t <*> solutions q <*> solutions r) (sym (fmap-∘ (_++_ ∘′_) _++_ (solutions p))) ⟩
--     (λ x y z → (x ++ y) ++ z) <$> (solutions p) <*> solutions q <*> solutions r
--   ≡⟨ {!!} ⟩
--     (λ x y z → x ++ (y ++ z)) <$> (solutions p) <*> solutions q <*> solutions r
--   ≡⟨ cong (_<*> solutions r) (sym (composition ({!(_∘′_ ∘ _++_) <$> solutions p!}) (pure _++_) (solutions q))) ⟩
--     (_∘′_ ∘ _++_) <$> solutions p <*> (_++_ <$> solutions q) <*> solutions r
--   ≡⟨ cong (λ t → t <*> (_++_ <$> solutions q) <*> solutions r) (fmap-∘ _∘′_ _++_ (solutions p)) ⟩
--     _∘′_ <$> (_++_ <$> solutions p) <*> (_++_ <$> solutions q) <*> solutions r
--   ≡⟨ sym (composition (_++_ <$> solutions p) (_++_ <$> solutions q) (solutions r)) ⟩
--     _++_ <$> solutions p <*> (_++_ <$> solutions q <*> solutions r)
--   ≡⟨⟩
--     solutions (p ⁇ (q ⁇ r)) ∎
\end{code}


\subsection{State}

The state effect has two operations \AgdaFunction{get} and \AgdaFunction{put}.
The whole effect is parameterized over the state type \AgdaArgument{s}.

\AgdaFunction{get} simply returns the current state.
The operation takes no additional parameters and has \AgdaArgument{s} positions.
This can either be interpreted as \AgdaFunction{get} being an
\AgdaArgument{s}-ary operation (one child for each possible state) or simply the
parameter of the continuation being a value of type \AgdaArgument{s}.

\AgdaFunction{put} updates the current state.
The operation takes an additional parameter, the new state.
The operation itself is unary i.e. the continuation is called with
\AgdaInductiveConstructor{tt} to start the rest of the program.

$$
\Sigma_{State} = \{ \mathrm{get} : \mathbf{1} \rightsquigarrow s, \mathrm{put} :
s \rightsquigarrow \mathbf{1} \}
$$
As before we will translate this definition in a corresponding container and
define \AgdaKeyword{pattern}s to simplify the handler.

\begin{code}
data Stateˢ (S : Set) : Set where
  getˢ : Stateˢ S
  putˢ : S → Stateˢ S

State : Set → Container
State S = Stateˢ S ▷ λ where
  getˢ      → S
  (putˢ _)  → ⊤

pattern Get κ    = impure (inj₁ getˢ , κ)
pattern Put s κ  = impure (inj₁ (putˢ s) , κ)
\end{code}
To simplify working with the \AgdaDatatype{State} effect we add smart
constructors.
These correspond to the generic operations, which we can implement using
\AgdaFunction{op}.

\begin{code}
get : ∀ {ops S} → ⦃ State S ∈ ops ⦄ → Free ops S
get = op getˢ

put : ∀ {ops S} → ⦃ State S ∈ ops ⦄ → S → Free ops ⊤
put s = op (putˢ s)
\end{code}
Using these defintions for the syntax we can define the handler for
\AgdaDatatype{State}.

\begin{AgdaAlign}
The effect handler for \AgdaDatatype{State} takes an initial state together
with a program containing the effect syntax.
The final state is returend in addition to the result.

\begin{code}
runState : ∀ {ops S} → S → Free (State S ∷ ops) A → Free ops (S × A)
\end{code}
A \AgdaInductiveConstructor{pure} calculation doesn't change the current state.
Therefore, the initial is also the final state and returned in addition to the
result of the calculation.
\begin{code}
runState s₀ (pure x)     = pure (s₀ , x)
\end{code}
The continuation/position function for \AgdaFunction{get} takes the current
state to the rest of the calculation.
By applying \AgdaArgument{s₀} to \AgdaArgument{κ} we obtain the rest of the
computation, which we can evaluate recursively.
\begin{code}
runState s₀ (Get κ)      = runState s₀ (κ s₀)
\end{code}
\AgdaFunction{put} updates the current state, therefore we pass the new state
\AgdaArgument{s₁} to the recursive call of \AgdaFunction{runState}.
\begin{code}
runState _  (Put s₁ κ)   = runState s₁ (κ tt)
\end{code}
Similar to the handler for \AgdaDatatype{Nondet} we apply the handler to every
subterm of non \AgdaFunction{State} operations.
\begin{code}
runState s₀ (Other s κ)  = impure (s , runState s₀ ∘ κ)
\end{code}
\end{AgdaAlign}

\begin{code}[hide]
evalState : ∀ {ops S} → S → Free (State S ∷ ops) A → Free ops A
evalState s₀ p = proj₂ <$> runState s₀ p
\end{code}


\subsubsection{Example}

Here is a simple example for a function using the \AgdaDatatype{State}
effect.
The function \AgdaFunction{tick} returns \AgdaInductiveConstructor{tt} and
as side effect increases the state.

\begin{code}
tick : ∀ {ops} → ⦃ State ℕ ∈ ops ⦄ → Free ops ⊤
tick = do i ← get ; put (1 + i)
\end{code}
Using the \AgdaFunction{runState} handler we can evaluate programs, which use
the \AgdaDatatype{State} effect.

\begin{center}
\begin{code}[inline,hide]
example₁ :
\end{code}
\begin{code}[inline]
 (run $ runState 0 $ tick >> tick) ≡ (2 , tt)
\end{code}
\begin{code}[inline,hide]
example₁ = refl
\end{code}
\end{center}

\subsubsection{Properties}

\begin{code}
module StateLaws (S : Set) (ops : List Container) (s₀ : S) where
  go : Free (State S ∷ ops) A → Free ops (S × A)
  go = runState {_} {ops} s₀

  put-put : {s₁ s₂ : S} → (go $ put s₁ >> put s₂) ≡ (go $ put s₂)
  put-put = refl

  put-get : {s : S} → (go $ put s >> get) ≡ (go $ put s >> pure s)
  put-get = refl

  get-get : {k : S → S → Free (State S ∷ ops) A}
    → (go $ get >>= λ s → get >>= k s) ≡ (go $ get >>= λ s → k s s)
  get-get = refl

  get-put : (go $ get >>= put) ≡ (go $ pure tt)
  get-put = refl
\end{code}


\subsection{Handling Combined Effects}

As described in section \ref{first-order:functor}, signatures can be combined by
combining the underlying functors.
Handlers can be used to partially evaluate programs over a combined signature.
Consider the following program using nondeterminism and state.

\begin{code}[hide]
variable
  S : Set
\end{code}
\begin{code}
chooseTick : ⦃ Nondet ∈ ops ⦄ → ⦃ State ℕ ∈ ops ⦄ → Free ops ℕ
chooseTick = tick >> ((tick >> get) ⁇ (tick >> tick >> get))
\end{code}
For the interaction of \AgdaDatatype{State} and \AgdaDatatype{Nondet} two
semantics are conceivable.
\paragraph{Local State}
Each branch in the nondeterministic calculation has its own state.
When \AgdaFunction{⁇} is used to choose between two reuslts both branches
continue with own states, which initialy have the same value.
\paragraph{Global State}
All branches share a single, global state.
Based on the evaluation strategy for the nondeterminism (first result/all
results; depth first search/breath first search/fair search) an ordering for all
operations in the tree is induced.
The state operations are executed in this order an all act on the same state.

The handlers for the two effects define semantics for their operations.
Operations of the other siganture are just traversed.
The interaction smeantics are induced by the ordering of the handlers.
We obtain two combined handlers, each corresponding to one of the two cases
above.

\begin{code}
localState : S → Free (State S ∷ Nondet ∷ []) A → List (S × A)
localState s₀ = run ∘ solutions ∘ runState s₀

globalState : S → Free (Nondet ∷ State S ∷ []) A → S × List A
globalState s₀ = run ∘ runState s₀ ∘ solutions
\end{code}
Let us consider the above example under both combined handlers with initial
state \AgdaNumber{0}.

\paragraph{Local State}
The first \AgdaFunction{tick} increases the state to \AgdaNumber{1}.
Both branches are executed independently with initial state \AgdaNumber{1}.
The first ticks once, therefore the \AgdaFunction{get} yields \AgdaNumber{2}.
The second ticks twice, therefore the \AgdaFunction{get} yields \AgdaNumber{3}.

\begin{center}
\begin{code}[inline,hide]
runChooseTickLocal :
\end{code}
\begin{code}[inline]
 localState 0 chooseTick ≡ (2 , 2) ∷ (3 , 3) ∷ []
\end{code}
\begin{code}[inline,hide]
runChooseTickLocal = refl
\end{code}
\end{center}

\paragraph{Global State}
The nondet handler executes the banches from left to right.
The final state of one branch is the inital one for the next branch.
Therefore, the second branch continues with state \AgdaNumber{2} increasing it
twice.

\begin{center}
\begin{code}[inline,hide]
runChooseTickGlobal :
\end{code}
\begin{code}[inline]
 globalState 0 chooseTick ≡ (4 , 2 ∷ 4 ∷ [])
\end{code}
\begin{code}[inline,hide]
runChooseTickGlobal = refl
\end{code}
\end{center}


\section{Effects with Scopes using Brackets}

To correctly handle operations with local scopes Wu et al. introduced scoped
effects \cite{DBLP:conf/haskell/WuSH14}.
They presented two solutions to explicitly declare how far an operations scopes
over a program using arbitrary syntax.
In the following section we will implement the scoped effect
\AgdaDatatype{Cut} using the first order approach in Agda.
The central idea is to add new effect syntax, representing explicit scope
delimiters.
Whenever an opening delimiter is encountered the handler can be run again on the
scoped program.
Thanks to a closing delimiters the end of a scope can be found.
Therefore, calling \AgdaFunction{>>=} on a scoped operation to extend the
continuation isn't a problem, because the continuation can be separated in the
part inside and outside the scope.

\subsection{Cut and Call}

First we will define the syntax for the new effect and its delimiters.

\begin{code}
data Cutˢ : Set where cutfailˢ : Cutˢ
data Callˢ : Set where bcallˢ ecallˢ : Callˢ

pattern Cutfail = impure (inj₁ cutfailˢ , _)
pattern BCall κ = impure (inj₁ bcallˢ , κ)
pattern ECall κ = impure (inj₁ ecallˢ , κ)

Cut Call : Container
Cut   = Cutˢ    ▷ λ _ → ⊥
Call  = Callˢ   ▷ λ _ → ⊤
\end{code}
The \AgdaDatatype{Cut} effect has just a single operation, \AgdaFunction{cutfail}.
\AgdaFunction{cutfail} can only be used in a context with nondeterminism.
When \AgdaFunction{cutfail} is called it will prunes all unexplored branches and
calls \AgdaFunction{fail}.
The Agda implementation of the handlers is identical to the one by Wu et al.

\begin{AgdaAlign}
The handler itself calls the function \AgdaFunction{go}, which accumulates the
unexplored alternatives in its second argument.
\AgdaFunction{fail} is the neutral element for \AgdaFunction{⁇} and therefore
the default argument.
Since this handler is not orthogonal (i.e it interacts with another effect)
\AgdaDatatype{Nondet} is required to be in scope, but its position is irrelevant.

To prove termination we mark the second argument with an arbitrary but fixed size
\AgdaArgument{i}.
The position functions for each case return subterms indexed with a smaller size.
Recursive calls to \AgdaFunction{go} with these terms as argument therefore
terminate.

\begin{code}
call : ⦃ Nondet ∈ ops ⦄ → Free (Cut ∷ ops) A → Free ops A
call = go fail
  where
    go : ⦃ Nondet ∈ ops ⦄ → Free ops A → Free (Cut ∷ ops) A {i} → Free ops A
\end{code}
In case of a \AgdaInductiveConstructor{pure} value no \AgdaFunction{cutfail}
happened.
We therefore return a calculation choosing between the value and the earlier
separated alternatives.

\begin{code}
    go q (pure a)       = (pure a) ⁇ q
\end{code}
In case of a cutfail we terminate the current computation by calling
\AgdaFunction{fail} and prune the alternatives by ignoring \AgdaArgument{q}.

\begin{code}
    go _ Cutfail        = fail
\end{code}
To interact with \AgdaDatatype{Nondet} syntax we have to find it.
We have a proof that the \AgdaDatatype{Nondet} effect is an element of the effect
list.
Whenever we find syntax from another effect we can therefore try to project the
\AgdaDatatype{Nondet} option from the coproduct.
Notice that \AgdaFunction{prj} hides the structural recursion but decreases the
\AgdaDatatype{Size} index.
We can therefore still proof that the function terminates.

\begin{code}
    go q p@(Other s κ)  with prj {Nondet} p
\end{code}
The case for \AgdaFunction{⁇} separates the main branch from the alternative.
Using \AgdaFunction{go} the \AgdaDatatype{Cut} syntax is removed from both
alternatives, but the results are handled asymmetrically.
The left option is direclty passed to the recursive call of
\AgdaFunction{go}.
The handeled right option is the new alternative for the left one and therefore
could be pruned if left contains a \AgdaFunction{cutfail} call.

\begin{code}
    ... | just (⁇ˢ     , κ′)  = go (go q (κ′ false)) (κ′ true)
\end{code}
When encountering a \AgdaFunction{fail} we continue with the accumulated
alternatives.

\begin{code}
    ... | just (failˢ  , _ )  = q
\end{code}
Syntax from other effects is handled as usual.

\begin{code}
    ... | nothing             = impure (s , go q ∘ κ)
\end{code}
\end{AgdaAlign}
With the handler for \AgdaDatatype{Cut} in place we can define the handler for the
scope delimiters.
The implementation is again similar to the one presented by Wu et al., but to
proof termination we again have to add \AgdaDatatype{Size} annotations to the
functions.

The \AgdaFunction{bcall} and \AgdaFunction{ecall} handler remove the scope
delimiter syntax from the program and run \AgdaFunction{call} (the handler
for \AgdaDatatype{cut}) at the begining of each scope.
Whenever a \AgdaFunction{BCall} is found the handler \AgdaFunction{ecall} is
used to handle the rest of the program.
\AgdaFunction{ecall} searches for the end of the scope and returns the program
up to that point.
The rest of the program is the result of the returned program.

A valid upper bound for the size of the rest of the program is \AgdaArgument{i},
the size of the program before separating the syntax after the closing delimiter.
This fact is curcial to proof that the recursive calls to \AgdaFunction{bcall} and
\AgdaFunction{ecall} using \AgdaFunction{>>=} terminate.

Calling the handler on the extracted program guaranties that the handler does
not interact with syntax outside the intended scope.
Nested scopes are handled using recursive calls to \AgdaFunction{ecall} if
\AgdaFunction{BCall} operations are encountered while searching a closing
delimiter.

Since the delimiters could be placed freely it is possible to mismatch them.
If we encounter a closing before and operening delimiter, we know that they are
mismatched.
Wu et al. use Haskells \texttt{error} function to terminate the program.
In Agda we are not allowed to define partial functions, therefore we have to
handle the error.
We could either correct the error and just continue or short circuit the
calculation using exceptions in form of e.g. a \AgdaDatatype{Maybe} monad.
For simplicity we will use the former approach.
In a real application it would be advisable to inform the programmer about the
error, either using exceptions or at least trace the error.

\begin{code}
bcall : ⦃ Nondet ∈ ops ⦄ → Free (Call ∷ Cut ∷ ops) A {i} → Free (Cut ∷ ops) A
ecall : ⦃ Nondet ∈ ops ⦄ → Free (Call ∷ Cut ∷ ops) A {i}
  → Free (Cut ∷ ops) (Free (Call ∷ Cut ∷ ops) A {i})

bcall (pure x)     = pure x
bcall (BCall κ)    = upcast (call (ecall (κ tt))) >>= bcall
bcall (ECall κ)    = bcall (κ tt) -- Unexpected ECall! We just fix the error.
bcall (Other s κ)  = impure (s , bcall ∘ κ)

ecall (pure x)     = pure (pure x)
ecall (BCall κ)    = upcast (call (ecall (κ tt))) >>= ecall
ecall (ECall κ)    = pure (κ tt)
ecall (Other s κ)  = impure (s , ecall ∘ κ)
\end{code}
Using the handlers defined above we can define a handler for scoped
\AgdaDatatype{Cut} syntax, which removes \AgdaDatatype{Cut} and
\AgdaDatatype{Call} syntax simultaneously.
The delimiters and correctly scoped \AgdaDatatype{Cut} syntax is removed using
\AgdaFunction{bcall} and potential unscoped \AgdaDatatype{Cut} syntax is
removed with a last use of \AgdaFunction{call}.
The function \AgdaFunction{call′} is a smart constructor for the scope
delimiters.

\begin{code}
runCut : ⦃ Nondet ∈ ops ⦄ → Free (Call ∷ Cut ∷ ops) A → Free ops A
runCut = call ∘ bcall

call′ : ⦃ Call ∈ ops ⦄ → Free ops A → Free ops A
call′ p = do op bcallˢ ; x ← p ; op ecallˢ ; pure x
\end{code}

\section{Call-Time Choice as Effect}

Bunkenburg presented an approach to model call-time choice as a stack of
scoped algebraic effects \cite{bunkenburg2019modeling}.
In this section we will extend the nondeterminism effect from section
\ref{nondeterminism} to one modelling call-time choice.

As explained in section \ref{call-time-choice}, call-time choice semantics
describe the interaction between sharing and nondeterminism.
The current implementation of \AgdaDatatype{Nondet} does not support sharing
i.e. it is not possible for two choice to be linked.
Based on Bunkenburg's implementation we will make two changes to the
nondeterminism effect.
Each choice is augmented with an optional identifier consisting of a triple of
natural numbers, called \textit{choice id}.
The first two are used to identity the current scope and will be refereed to as
\textit{scope id}.
The third number identifies the choice inside its scope.
Furthermore, instead of producing a list the handler will now produce a tree of
choices.
This change allows to choose the evaluation strategy, e.g. depth first or breath
first search, independent of the handler.


\subsection{Deep Effects}

In Haskell and Curry ambient effects, like partiality, tracing and
nondeterminism, can occur in components of data structures.
Each argument of a constructor could be an effectful computation.
For example, in Curry the tail of a list could be a nondeterministic choice
between two possible tails.
Such effects are sometimes called \textit{deep effects}.

We want to simulate this behavior with algebraic effects.
The effects have to be modelled explicitly using the \AgdaDatatype{Free} type.
We will lift data types using a standard construction, which is commonly used
to simulate ambient deep
effects~\cite{DBLP:conf/haskell/AbelBBHN05, DBLP:journals/programming/DylusCT19,
DBLP:conf/haskell/ChristiansenDB19}.
The following example of an effectful \AgdaDatatype{List} demonstrates the
the general construction\footnote{In the following code effectful data
  structures and lifted versions of functions are marked with a suffix
  \textsuperscript{M}}.

\begin{code}
data Listᴹ (ops : List Container) (A : Set) : {Size} → Set where
  nil   : Listᴹ ops A {i}
  cons  : Free ops A → Free ops (Listᴹ ops A {i}) → Listᴹ ops A {↑ i}
\end{code}
\AgdaDatatype{Listᴹ}\AgdaSpace{}\AgdaArgument{ops}\AgdaSpace{}\AgdaArgument{A}
represents a \AgdaDatatype{List}\AgdaSpace{}\AgdaArgument{A} in whose components
effects from the given effect stack \AgdaArgument{ops} can occur.
To easily construct and work with lifted values we introduce smart constructors
in the form of pattern synonyms.

\begin{code}[hide]
infixr 5 _∷ᴹ_ _++ᴹ_
\end{code}
\begin{code}
pattern []ᴹ          = pure nil
pattern _∷ᴹ_ mx mxs  = pure (cons mx mxs)
\end{code}
The size annotations on the lifted data structures are needed to proof
termination of structural recursive functions.
To pattern match on a lifted value we have to use \AgdaFunction{>>=}.
Therefore the structural recursion is obscured.

\begin{code}
_++ᴹ_ : Free ops (Listᴹ ops A {i}) → Free ops (Listᴹ ops A) → Free ops (Listᴹ ops A)
mxs ++ᴹ mys = mxs >>= λ where
  nil             → mys
  (cons mx mxs′)  → mx ∷ᴹ mxs′ ++ᴹ mys
\end{code}

\subsubsection{Normalization of Effectful Data}

Based on Bunkenburg's code~\cite{bunkenburg2019modeling} we will introduce a
type class for normalizing effectful data structures i.e. moving interleaved
\AgdaDatatype{Free} layers to the outside using \AgdaFunction{>>=}.

\begin{code}
record Normalform (ops : List Container) (A B : Set) : Set where
  field
    nf : A → Free ops B
open Normalform ⦃...⦄ public

!_ : ⦃ Normalform ops A B ⦄ → Free ops A → Free ops B
! mx = mx >>= nf
\end{code}
The type class allow to normalize elements of type \AgdaArgument{A} (intuitively
containing effectful calculations) to computations producing of elements of type
\AgdaArgument{B} (intuitively a version of \AgdaArgument{A} without the effects).
Instead of \AgdaArgument{A} and \AgdaArgument{B} we could have parameterized the
type class over a type family of an effect stack, with \AgdaFunction{nf}
producing an element of the type family applied to an empty stack.
This implementation would allow us to restrict the normalizable types, but
prohibit us from producing elements of standard data types.

In contrast to Bunkenburg's implementation we do not expect a lifted argument.
Simplifying the type and introducing the helper function \AgdaFunction{!\_}
removes the need for auxiliary normalization lemmas for
\AgdaInductiveConstructor{pure} and \AgdaInductiveConstructor{impure} values in
proofs.
The extra degree of freedom, introduced by a monadic argument, was not used in
the original implementation.

\begin{code}
instance
  ℕ-normalform : Normalform ops ℕ ℕ
  Normalform.nf ℕ-normalform = pure

  Listᴹ-Normalform : ⦃ Normalform ops A B ⦄ →
    Normalform ops (Listᴹ ops A {i}) (List B)
  Normalform.nf Listᴹ-Normalform nil            = pure []
  Normalform.nf Listᴹ-Normalform (cons mx mxs)  = ⦇ ! mx ∷ ! mxs ⦈
\end{code}
The data stored in an effectful list could also be effectful and therefore has
to be normalized.
We simply require a \AgdaDatatype{Normalform} instance for the stored type.
To allow normalization of general types and effectful data structures containing
them, we have to implement dummy instances for data types like builtin natural
numbers or booleans.

\subsection{Sharing Handler}

The idea of the following sharing handler is identical to the one presented by
Bunkenburg.
Thanks to the more flexible infrastructure described in the earlier sections we
are able to define a more modular handler and avoid some inlining, necessary to
prove termination in Coq.
Similar to \AgdaDatatype{Cut} the sharing handler is not orthogonal to other
effects, but interacts with existing \AgdaDatatype{Nondet} syntax.

The scoping operation \AgdaFunction{share} takes an additional argument, the
unique identifier for the created scope.
Similar to \AgdaFunction{put} the parameter is part of the container shape.

\begin{code}
data Shareˢ : Set where bshareˢ eshareˢ : ℕ × ℕ → Shareˢ
pattern BShare  n κ = impure (inj₁ (bshareˢ n) , κ)
pattern EShare  n κ = impure (inj₁ (eshareˢ n) , κ)

Share : Container
Share = Shareˢ ▷ λ _ → ⊤
\end{code}
\begin{code}[hide]
-- ID in earlier definition (Nondet is the first example without parameters) or
-- redefine here (maybe hidden)?
data NonDetˢ : Set where
  ⁇ˢ     : Maybe ((ℕ × ℕ) × ℕ) → NonDetˢ
  failˢ  : NonDetˢ

pattern Choice′ cid κ = impure (inj₁ (⁇ˢ cid) , κ)
pattern Fail′ = impure (inj₁ failˢ , _)

NonDet : Container
NonDet = NonDetˢ ▷ λ where
  (⁇ˢ _) → Bool
  failˢ  → ⊥

fail′ : ⦃ NonDet ∈ ops ⦄ → Free ops A
fail′ = inj (failˢ , λ())

_⁇′_ : ⦃ NonDet ∈ ops ⦄ → Free ops A → Free ops A → Free ops A
p ⁇′ q = inj (⁇ˢ nothing , (if_then p else q))

data Tree (A : Set) : Set where
  branch : Maybe ((ℕ × ℕ) × ℕ) → (l r : Tree A) → Tree A
  leaf   : A → Tree A
  failed : Tree A

dfs : {A : Set} → Map Bool → Tree A → List A
dfs mem failed                   = []
dfs mem (leaf x)                 = x ∷ []
dfs mem (branch nothing    l r)  = dfs mem l ++ dfs mem r
dfs mem (branch (just id)  l r) with lookup id mem
... | nothing  = dfs (insert id true mem) l ++ dfs (insert id false mem) r
... | just d   = if d then dfs mem l else dfs mem r

runNonDet : Free (NonDet ∷ ops) A → Free ops (Tree A)
runNonDet (pure x)         = pure (leaf x)
runNonDet (Choice′ cid κ)  = branch cid <$> runNonDet (κ true) <*> runNonDet (κ false)
runNonDet Fail′            = pure failed
runNonDet (Other s κ)      = impure (s , runNonDet ∘ κ)
\end{code}
The handler has the same structure as other handlers for scoped effects like
\AgdaDatatype{Cut}.
The \AgdaFunction{bshare} handler searches for opening delimiters, which are
subsequently handled by \AgdaFunction{eshare}.
\AgdaFunction{ehsare} handles the part of the program in scope and returns the
unhandled continuations, which is again handled using \AgdaFunction{bshare}.
Nested scopes are handled uisng recursive \AgdaFunction{eshare} calles.
To implement sharing the handler modifies the program in scope.
Using \AgdaFunction{prj}, \AgdaFunction{NonDet} syntax is extracted and
reinjected.
Choice nodes are modified to now include the unique choice id.
The identifier is generated from the scope id of the current shareing scope and a
counter, which is managed by the handler.
When ever a choice is tagged with an id the counter is increased.
The uniquenes of the scope identifiers is not managed by the handler, but the
share operator.

Due to the size annotations termination is proven on the type level.
To implement the sharing handler it's not necessary to combine the two cases,
as done by Bunkeburg in his Coq implementation.

\begin{code}
bshare  : ⦃ NonDet ∈ ops ⦄ → Free (Share ∷ ops) A {i} → Free ops A
eshare  : ⦃ NonDet ∈ ops ⦄ → ℕ → ℕ × ℕ → Free (Share ∷ ops) A {i}
  → Free ops (Free (Share ∷ ops) A {i})

bshare (pure x)        = pure x
bshare (BShare sid κ)  = eshare 0 sid (κ tt) >>= bshare
bshare (EShare sid κ)  = bshare (κ tt) -- missmatched scopes, we just continue!
bshare (Other  s   κ)  = impure (s , bshare ∘ κ)

eshare next sid (pure x)         = pure (pure x)
eshare next sid (BShare sid′ κ)  = eshare 0 sid′ (κ tt) >>= eshare next sid
eshare next sid (EShare sid′ κ)  = pure (κ tt) -- usually test that sid′ = sid
eshare next sid p@(Other s κ) with prj {NonDet} p
... | just (⁇ˢ _  , κ′)  = inj $ ⁇ˢ (just $ sid , next) , eshare (1 + next) sid ∘ κ′
... | just (failˢ , κ′)  = inj $ failˢ , λ()
... | nothing            = impure (s , eshare next sid ∘ κ)
\end{code}


\subsection{Share Operator}

Next we will define the \AgdaFunction{share} operator as described by
Bunkenburg.
The operator generates new unique scope identifiers using a \AgdaDatatype{State}
effect.
Furthermore, it shares all choices in the components of effectful data
structures.

To map the operator over arbitrary structures the \AgdaDatatype{Shareable} type
class is introduced.
The \AgdaFunction{shareArgs} function calls \AgdaFunction{share} recursively on
the components of the shared data structure.
Similar to \AgdaDatatype{Normalform}, trivial instances for simple data types
are introduced.

\begin{code}
record Shareable (ops : List Container) (A : Set) : Set₁ where
  field
    shareArgs : A → Free ops A
open Shareable ⦃...⦄ public

instance
  shareable-ℕ : Shareable ops ℕ
  Shareable.shareArgs shareable-ℕ = pure
\end{code}
Using the instances for data we can implement Bunkenburg's version of the
operator.
The operator itself relies on a \AgdaDatatype{State} effect, which is later
executed as first effect in the stack, to generate the identifiers.
Given a computation producing values of type \AgdaArgument{A} the operator
returns a computation of computations of type \AgdaArgument{A} i.e. the result
has two \AgdaDatatype{Free}\AgdaSpace{}\AgdaArgument{ops} layers.
The outer layer is usually execute (injected at into the larger program at the
current point) immediately using \AgdaFunction{>>=}.
The outer computation generates a new identifier.
The inner computation captures the identifier, therefore binding the inner
computation multiple times yields multiple scopes with the same id.
An in depth explanation can be found in ``Modeling Call-Time Choice as Effect
using Scoped Free Monads''~\cite{bunkenburg2019modeling}.

\begin{code}
share : ⦃ Shareable ops A ⦄ → ⦃ Share ∈ ops ⦄ → ⦃ State (ℕ × ℕ) ∈ ops ⦄ →
  Free ops A → Free ops (Free ops A)
share p = do (i , j) ← get
             put (1 + i , j)
             pure do op $ bshareˢ (i , j)
                     put (i , 1 + j)
                     x   ← p
                     x′  ← shareArgs x
                     put (1 + i , j)
                     op $ eshareˢ (i , j)
                     pure x′
\end{code}
Using \AgdaFunction{share} we can implement a shareable instance for effectful
lists.
In the original Haskell implementation \AgdaFunction{shareArgs} is a higher
order function, which takes \AgdaFunction{share} as an additional argument.
For simplicity and to avoid termination problems this is not the case in the
Agda implementation.

\begin{code}
instance
  Listᴹ-shareable : ⦃ Shareable ops A ⦄ → ⦃ Share ∈ ops ⦄ → ⦃ State (ℕ × ℕ) ∈ ops ⦄
      → Shareable ops (Listᴹ ops A {i})
  Shareable.shareArgs Listᴹ-shareable nil            = []ᴹ
  Shareable.shareArgs Listᴹ-shareable (cons mx mxs)  = cons <$> share mx <*> share mxs
\end{code}


\subsection{Examples}

Using the handler we can simulate call-time choice semantics using effects in
Agda.
Call-time choice can be simulated with the following effect stack

\begin{code}
CTC : List Container
CTC = State (ℕ × ℕ) ∷ Share ∷ NonDet ∷ []
\end{code}
Before calling any handlers the data is normalized, so that not only surface,
but also deep effects are evaluated.
State is evaluated first to generate the identifiers for sharing.
Sharing is evaluated next to tag all choices with their scopes identifiers.
At last nondeterminism is evaluated to collect the results of all possible
branches, taking the scope ids into account.

\begin{code}
runCTC : ⦃ Normalform CTC A B ⦄ → Free CTC A → List B
runCTC p = dfs empty $ run $ runNonDet $ bshare $ evalState (0 , 0) (! p)
\end{code}
Now we can implement the \AgdaFunction{doubleCoin} example from section
\ref{preliminaries:curry}.

\begin{code}
coin : ⦃ NonDet ∈ ops ⦄ → Free ops ℕ
coin = pure 0 ⁇′ pure 1

doubleCoin : ⦃ Share ∈ ops ⦄ → ⦃ State (ℕ × ℕ) ∈ ops ⦄ → ⦃ NonDet ∈ ops ⦄ →
  Free ops ℕ
doubleCoin = share coin >>= λ c → ⦇ c + c ⦈
\end{code}
By calling \AgdaFunction{share} the choice in \AgdaFunction{coin} is shared.
By binding the result of \AgdaFunction{share} the computation tree generating
the ids (i.e. the outer layer) is expanded.
The argument of the continuation \AgdaArgument{c} is itself a program, it's the
original coin function wrapped into a sharing scope, which captures the
generated id of the outer scope.
By binding \AgdaArgument{c} this computation is injected into the whole
computation.
Binding \AgdaArgument{c} multiple times yields the same scope, because the scope
identifier is captured.
Equal scope identifier yield equal decisions during the evaluation of
\AgdaDatatype{NonDet}.

\begin{center}
\begin{code}[inline,hide]
runDoubleCoin :
\end{code}
\begin{code}[inline]
 runCTC doubleCoin ≡ 0 ∷ 2 ∷ []
\end{code}
\begin{code}[inline,hide]
runDoubleCoin = refl
\end{code}
\end{center}
Thanks to the \AgdaDatatype{Shareable} type class it's also possible to share
choice, which are embedded in data structures.
The following simple example demonstrates this possibility.

\begin{code}
headᴹ : ⦃ NonDet ∈ ops ⦄ → Free ops (Listᴹ ops A) → Free ops A
headᴹ mxs = mxs >>= λ where
  nil         → fail′
  (cons mx _) → mx

doubleHead : ⦃ Share ∈ ops ⦄ → ⦃ State (ℕ × ℕ) ∈ ops ⦄ → ⦃ NonDet ∈ ops ⦄ →
  Free ops ℕ
doubleHead = share (coin ∷ᴹ []ᴹ) >>= λ mxs → ⦇ headᴹ mxs + headᴹ mxs ⦈
\end{code}
As expected, observing the value in the head twice yields the same value,
because the choice was shared.

\begin{center}
\begin{code}[inline,hide]
runDoubleHead :
\end{code}
\begin{code}[inline]
 runCTC doubleHead ≡ 0 ∷ 2 ∷ []
\end{code}
\begin{code}[inline,hide]
runDoubleHead = refl
\end{code}
\end{center}
Using the \AgdaDatatype{Normalform} type class it's possible to embed effects
deep into data structures.
This allow to write programs operating on recursive data structures, which
closely resemble their Curry version.
Consider the example of nondeterministic insertion into a list.

\begin{code}
insertND : ⦃ NonDet ∈ ops ⦄ →
  Free ops A → Free ops (Listᴹ ops A {i}) → Free ops (Listᴹ ops A {↑ i})
insertND mx mxs = mxs >>= λ where
  nil            → mx ∷ᴹ []ᴹ
  (cons my mxs)  → (mx ∷ᴹ my ∷ᴹ mxs) ⁇′ (my ∷ᴹ insertND mx mxs)
\end{code}
When evaluating the result of \AgdaFunction{insertND} the \AgdaDatatype{Listᴹ}
is normalized using the type class.
As expected, insert \AgdaNumber{1} deterministically in the list with
\AgdaNumber{2} and \AgdaNumber{3} yields three possible results.

\begin{center}
\begin{code}[inline,hide]
runInsertND :
\end{code}
\begin{code}[inline]
 runCTC (insertND (pure 1) (pure 2 ∷ᴹ pure 3 ∷ᴹ []ᴹ)) ≡
   (1 ∷ 2 ∷ 3 ∷ []) ∷ (2 ∷ 1 ∷ 3 ∷ []) ∷ (2 ∷ 3 ∷ 1 ∷ []) ∷ []
\end{code}
\begin{code}[inline,hide]
runInsertND = refl
\end{code}
\end{center}


\subsection{Laws of Sharing}

\begin{figure}
  \begin{align*}
    \tag{ident-left}
    \mathrm{pure} x\bind k &= k\; x \\
    \tag{ident-right}
    mx \bind \mathrm{pure} &= mx \\
    \tag{assoc}
    mx \bind f \bind g &= mx \bind \lambda x\rightarrow f x \bind g \\\\
    \tag{fail-absorb}
    \mathrm{fail} \bind  k &= \mathrm{fail} \\
    \tag{⁇-algebraic}
    (p\; ⁇\; q) \bind k &= (p \bind k)\; ⁇\; (q \bind k) \\\\
    \tag{share-fail}
    \mathrm{share}\;\mathrm{fail} &= \mathrm{pure}\;\mathrm{fail}\\
    \tag{share-$\bot$}
    \mathrm{share}\;\bot &= \mathrm{pure}\;\bot\\
    \tag{share-⁇}
    \mathrm{share}\;(p\; ⁇\; q) &= \mathrm{share}\;p\; ⁇\; \mathrm{share}\;q \\
    \tag{HNF}
    \mathrm{share}\;(\mathrm{c}\;x_1\dots x_n) &= \mathrm{share}\; x_1 \bind \lambda y_1 \dots \mathrm{share}\; x_n \bind\lambda y_n \rightarrow \mathrm{pure}\;(\mathrm{pure}\;(c\;y_1\dots y_n))
  \end{align*}
  \caption{laws for a monad with sharing by Fischer et al.}
  \label{first-order:sharing:properties:laws}
\end{figure}

Fischer et al. introduced a set of equations characterizing
call-time choice semantics~\cite{DBLP:conf/icfp/FischerKS09}.
The equations can be found in figure \ref{first-order:sharing:properties:laws}.
The first three laws are just the monad laws, which were proven in section
\ref{first-order:free-monad:properties}.
Section \ref{first-order:nondet:properties} contains a proof for the fourth law.
The fifth law is the algebraicity of \AgdaFunction{⁇}, which follows for any operation
directly from the definition of \AgdaFunction{>>=}.

\begin{code}
⁇-algebraic : ⦃ _ : Normalform CTC B C ⦄ → ⦃ _ : Shareable CTC B ⦄ →
  (p q : Free CTC A) (k : A → Free CTC B) →
  runCTC ((p ⁇′ q) >>= k) ≡ runCTC ((p >>= k) ⁇′ (q >>= k))
⁇-algebraic p q k = refl
\end{code}
In addition to the monad laws and equations for \AgdaFunction{⁇} they introduced
equations involving \AgdaFunction{share}.

\begin{code}
share-fail : ⦃ _ : Normalform CTC A B ⦄ → ⦃ _ : Shareable CTC A ⦄ →
  runCTC {A} {B} (share fail′ >>= id) ≡ runCTC {A} {B} (pure fail′ >>= id)
share-fail = refl
\end{code}
The second law involving \AgdaFunction{share} does not apply to our effect
stack, because we have no notion of \mintinline{Haskell}{undefined}.
Partiality can be implemented identical to \AgdaFunction{fail} with carrier
\AgdaDatatype{Maybe}.
The effect would be placed last in the stack to allow canceling all running
calculations.
The law can be proven analogous to the one for \AgdaFunction{fail}.

The third law involving \AgdaFunction{share} states that \AgdaFunction{share}
distributes over \AgdaFunction{⁇}.
This law doesn't hold for this implementation, because there is no guarantee
that \AgdaFunction{get} or \AgdaFunction{put} aren't called outside the sharing
operator.
Developing another implementation satisfying the laws in all cases is outside
the scope of this thesis.

The last law states that share distributes over the components of effectful
data structures.
Since our representation for effectful data isn't uniform this law has to be
proven on a case by case basis.
One could try to automate this proves using tactics, find an equivalent
formulation which doesn't refer to constructors directly or use a different
representation for effectful data (e.g. fixed points of polynomial functors,
since they can be made effectful generically).
