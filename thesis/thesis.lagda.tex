\documentclass[10pt,a4paper,twoside]{report}

\usepackage[english]{babel}
\usepackage[a4paper,width=150mm,top=25mm,bottom=25mm]{geometry}

\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage{wasysym}
\setmathfont{Latin Modern Math}                 % normal math font
\setmathfont[range={\lBrace,\rBrace,\llparenthesis,\rrparenthesis}]{XITSMath}
% fallback for these 4 glyphs
\setsansfont{Latin Modern Sans}
% \setmainfont{Latin Modern Roman}
% \setmonofont{Fira Code}

\usepackage{newunicodechar}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{∷}{\ensuremath{\mathnormal{::}}}
\newunicodechar{⊔}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{∀}{\ensuremath{\mathnormal{\forall}}}
\newunicodechar{ℓ}{\ensuremath{\mathnormal{\ell}}}
\newunicodechar{▷}{\ensuremath{\mathnormal{\rhd}}}
\newunicodechar{∈}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{⦃}{\ensuremath{\mathnormal{\lBrace}}}
\newunicodechar{⦄}{\ensuremath{\mathnormal{\rBrace}}}
\newunicodechar{⦇}{\ensuremath{\mathnormal{\llparenthesis}}}
\newunicodechar{⦈}{\ensuremath{\mathnormal{\rrparenthesis}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{⊕}{\ensuremath{\mathnormal{\oplus}}}
\newunicodechar{⊎}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{λ}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{κ}{\ensuremath{\mathnormal{\kappa}}}
\newunicodechar{⊛}{\ensuremath{\mathnormal{\circledast}}}
\newunicodechar{∘}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{≡}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{⁇}{\ensuremath{\mathnormal{?\!?}}}
% see https://tex.stackexchange.com/questions/511401/newunicodechar-fails-for-prime-only
\AtBeginDocument{\newunicodechar{′}{\makebox[\fontcharwd\font`a]{$\prime$}}}
\newunicodechar{⊥}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{⊤}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{ˢ}{\textsuperscript{s}}
\newunicodechar{ˡ}{\textsuperscript{l}}
\newunicodechar{ʳ}{\textsuperscript{r}}
\newunicodechar{ᴹ}{\textsuperscript{M}}
\newunicodechar{ₙ}{\textsubscript{n}}
\newunicodechar{₀}{\textsubscript{0}}
\newunicodechar{₁}{\textsubscript{1}}
\newunicodechar{₂}{\textsubscript{2}}
\newunicodechar{₃}{\textsubscript{3}}
\newunicodechar{₄}{\textsubscript{4}}
\newunicodechar{₅}{\textsubscript{5}}

\usepackage{hyperref}
\usepackage[links]{agda}
\usepackage{mathtools}

% nicer monadic operators
\newcommand{\fmap}[0]{\ensuremath{<\hspace{.4pt}\mathclap{\raisebox{-0.85pt}{\scalebox{0.95}{$\$$}}}\hspace{.4pt}>}}
\newcommand{\ap}[0]{\ensuremath{<\hspace{.4pt}\mathclap{*}\hspace{.4pt}>}}
\newcommand{\bind}[0]{\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}

\DeclareRobustCommand{\AgdaFormat}[2]{%
  \ifthenelse{\equal{#1}{>>=}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{>>=\AgdaUnderscore{}}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{>>}}
  {\ensuremath{\mathbin{>\!\!\!>}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ensuremath{\mathbin{>\!\!\!>}}\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{<\$>}}
  {\fmap}
  {\ifthenelse{\equal{#1}{\$}}
  {\ensuremath{\$}}
  {\ifthenelse{\equal{#1}{<\$>\AgdaUnderscore{}}}
  {\fmap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<\$>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\fmap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<*>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ap\AgdaUnderscore{}}
  {#2}}}}}}}}}}}}

\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}%
\fancyhead[LO,RE]{\thepage}
\fancyhead[RO]{\rightmark}
\fancyhead[LE]{\leftmark}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.0pt}

% Chapter pages
\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyhead[LO,RE]{\thepage}
  \renewcommand{\headrulewidth}{0.0pt}%
  \renewcommand{\footrulewidth}{0.0pt}%
}

\usepackage{minted}

\usepackage[style=alphabetic,backend=biber]{biblatex}
\addbibresource{thesis.bib}
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}

\title{
  {\huge\textbf{Implementing a library for scoped algebraic effects in Agda}}\\
  {\large HTWK Leipzig}
}
\author{
  {Jonas Höfer}\\
  {Informatik}\\
  {69555}
}
\date{2020}

\begin{document}
Notiz: Der Code für alle 3 Ansätze ist quasi fertig.
Aktuell schreibe ich also fast ausschließlich an der Arbeit an sich.
Dieses PDF ist eine unfertige Arbeitsversion.
Einige bereits geschriebene Abschnitte sind noch unfertig oder an der falschen
Position in der Arbeit.
Kaptiel 4 und 5 enthalten Stichpunkte mit wichtigsten Ergebnissen.

\maketitle
\begin{abstract}
\end{abstract}

\tableofcontents

\chapter{Introduction}
\section{Goals}
\chapter{Preliminaries}
\section{Agda}

Agda is a dependently typed functional programming language.
The current version\footnote{\url{https://github.com/agda/agda}} was originally
developed by Ulf Norell under the name Agda2 \cite{norell:thesis}.
Due to its type system Agda can be used as a programming language and as a proof
assistant.

This section contains a short introduction to Agda, dependent types and the idea
of ``Propositions as types'' under which Agda can be used for theorem proving.

\subsection{Basic Syntax}

Agdas syntax is similar to Haskells.
Data types are declared with syntax similar to Haskells GADTs.
Functions declarations and definitions are also similar to Haskell, except that
Agda uses a single colon for the typing relation.
In the following definition of \AgdaDatatype{ℕ}, \AgdaDatatype{Set} is the type
of all (small) types.

\begin{code}
data ℕ : Set where
  zero  : ℕ
  suc   : ℕ → ℕ
\end{code}
Ordinary function definition are syntactically similar to Haskell.
Agda allows the definition of mixfix operators.
A mixfix operator is an nearly arbitrary list of symbols (builtin symbols like
colons are not allowed as part of operators).
Underscores in the operator name are placeholders for future parameters.
A mixfix operator can be applied partially by writing underscores for the
omitted parameters.

In the following definition of plus for natural numbers \AgdaFunction{+} is a
binary operator and therefore containers two underscores.

\begin{code}
_+_ : ℕ → ℕ → ℕ
zero   + m = m
suc n  + m = suc (n + m)
\end{code}
\begin{code}[hide]
{-# BUILTIN NATURAL ℕ #-}
\end{code}

\subsection{Dependent Types}
The following type theoretic definitions are taken from the homotopy type theory
book \cite{hottbook}.
In type theory a type of types is called a universe.
Universes are usually denoted $\mathcal{U}$.
A function whose codomain is a universe is called a type family or dependent
type.
$$
F : A \rightarrow \mathcal{U} \quad\text{where}\quad B(a) : \mathcal{U}
\quad\text{for}\quad a : A
$$
To avoid Russell's paradox, a hierarchy of universes $\mathcal{U}_1 :
\mathcal{U}_2 : \dots$ is introduced.
Usually the universes are cumulative i.e. if $\tau : \mathcal{U}_n$ then
$\tau : \mathcal{U}_k$ for $k>n$.
by default this is not the case in Agda.
Each type is member of a unique universe, forcing us to do additional
bookkeeping.
Since Agda 2.6.1 an experimental \texttt{--cumulativity} flag exists.

\paragraph{Dependent Function Types ($\Pi$-Types)} are a generalization of
function types.
The codomain of a $\Pi$ type is not fixed, but values with the argument the
function is applied to.
The codomain is defined using a type family of the domain, which specifies the
type of the result for each given argument.

$$
\prod_{a : A} B(a) \quad \text{with}\quad B : A \rightarrow\mathcal{U}
$$
An element of the above type is a function which maps every $a : A$ to a $b :
B(a)$.
In Agda the builtin function type $\Rightarrow$ is a $\Pi$-type.
An argument can be named by replacing the type $\tau$ with $x : \tau$, allowing
us to use the value as part of later types.

\paragraph{Dependent Sum Types ($\Sigma$-Types)} are a generalization of product
types.
The type of the second component of the product is not fixed, but varies with
the value of the first.
$$
\sum_{a : A} B(a) \quad \text{with}\quad B : A \rightarrow\mathcal{U}
$$
An element of the above type is a pair consisting of an $a : A$ and a $b : B(a)$.
In Agda \AgdaKeyword{record}s represent $n$-ary $\Sigma$-types.
Each field can be used in the type of the following fields.

\paragraph{Programming with Dependent Types}

A common example for dependent types are fixed length vectors.
The data type depends on a type \AgdaDatatype{A} and a value of type
\AgdaDatatype{ℕ}.

\begin{code}
data Vec (A : Set) : ℕ → Set where
  _∷_  : {n : ℕ} → A → Vec A n → Vec A (suc n)
  []   : Vec A 0
\end{code}
Arguments on the left-hand side of the colon are called parameters and are the
same for all constructors.
Arguments on the right-hand side of the colon are called indices and can differ
for each constructor.
Therefore \AgdaDatatype{Vec}\AgdaSpace{}\AgdaArgument{A} is a family of types
indexed by \AgdaDatatype{ℕ}.

The \AgdaInductiveConstructor{[]} constructor allows us to create an empty
vector of any type, but forces the index to be zero.
The \AgdaInductiveConstructor{\_∷\_} constructor appends an element to the front
of a vector of the same element type and increases the index by $1$.
Only these two constructors can be used to construct vectors.
Therefore the index is always equal to the amount of elements stored in the
vector.

By encoding more information about data in its type we can add extra constraints
to functions working with it.
The following definition of \AgdaFunction{head} avoids error handling or
partiality by excluding the empty vector as a valid argument.

\begin{code}
head : ∀ {A n} → Vec A (suc n) → A
head (x ∷ _) = x
\end{code}
When pattern matching on the argument of \AgdaFunction{head} there is no case
for \AgdaInductiveConstructor{[]}.
The argument has type \AgdaDatatype{Vec A (suc n)} and
\AgdaInductiveConstructor{[]} has type \AgdaDatatype{Vec A 0}.
Those to types cannot be unified, because \AgdaInductiveConstructor{suc} and
\AgdaInductiveConstructor{zero} are different constructors of \AgdaDatatype{ℕ}.
Therefore, the \AgdaInductiveConstructor{[]} case does not apply.
By constraining the type of the function we were able to avoid the case, which
usually requires error handling or introduces partiality.

We can extend this idea to type safe indexing.
A vector of length \AgdaArgument{n} is indexed by the first \AgdaArgument{n}
natural numbers.
The type \AgdaDatatype{Fin}\AgdaSpace{}\AgdaArgument{n} represents the subset of
natural numbers smaller than $n$.

\begin{code}
data Fin : ℕ → Set where
  zero  : {n : ℕ} → Fin (suc n)
  suc   : {n : ℕ} → Fin n → Fin (suc n)
\end{code}
Because $0$ is smaller than every positive natural number,
\AgdaInductiveConstructor{zero} can only be used to construct an element of
\AgdaDatatype{Fin}\AgdaSpace{}$($\AgdaInductiveConstructor{suc}
\AgdaArgument{n}$)$ i.e. for every type except
\AgdaDatatype{Fin}\AgdaSpace{}\AgdaArgument{0}.

If any number is smaller than $n$, then its successor is smaller than $n+1$.
Therefore, if any number is an element of
\AgdaDatatype{Fin}\AgdaSpace{}\AgdaArgument{n}
then its successor is an element of
\AgdaDatatype{Fin}\AgdaSpace{}$($\AgdaInductiveConstructor{suc}\AgdaSpace{}\AgdaArgument{n}$)$.

So we can construct a $k<n$ of type
\AgdaDatatype{Fin}\AgdaSpace{}\AgdaArgument{n} by starting with
\AgdaInductiveConstructor{zero} of type
\AgdaDatatype{Fin}\AgdaSpace{}$($\AgdaArgument{n - k}$)$ and applying
\AgdaInductiveConstructor{suc} $k$ times.
Using this definition of the bounded subsets of natural numbers we can define
\AgdaFunction{\_!\_} for vectors.

\begin{AgdaAlign}
\begin{code}
_!_ : ∀ {A n} → Vec A n → Fin n → A
(x  ∷ _ )  ! zero   = x
(_  ∷ xs)  ! suc i  = xs ! i
\end{code}
Notice that similar to \AgdaFunction{head} there is no case for
\AgdaInductiveConstructor{[]}.
\AgdaArgument{n} is used as index for
\AgdaDatatype{Vec}\AgdaSpace{}\AgdaArgument{A} and \AgdaDatatype{Fin}.
The constructors for \AgdaDatatype{Fin} only use \AgdaInductiveConstructor{suc},
therefore the type \AgdaDatatype{Fin}\AgdaSpace{}\AgdaInductiveConstructor{zero}
is not inhabited and the cases for \AgdaInductiveConstructor{[]} do not apply.

By case splitting on the vector first we could have obtained the term
\AgdaInductiveConstructor{[]}\AgdaSpace{}\AgdaFunction{!}\AgdaArgument{i}.
By case splitting on \AgdaArgument{i} we notice that no constructor for
\AgdaDatatype{Fin zero} exists.
Therefore, this case cannot occur, because the type of the argument is
uninhabited.
It's impossible to call the function, because we cannot construct an argument of
the correct type.
In this example we can either omit the case or explicitly state that the
argument is impossible to construct, by replacing it with $()$, allowing us to
omit the definition of the right-hand side of the equation.

\begin{code}
[]         ! () -- no right-hand side
\end{code}
\end{AgdaAlign}
The other two cases are straightforward.
For index \AgdaInductiveConstructor{zero} we return the head of the vector.
For index \AgdaInductiveConstructor{suc}\AgdaSpace{}\AgdaArgument{i} we call
\AgdaFunction{\_!\_} recursively with the smaller index and the tail of the
vector.
Notice that the types for the recursive call change.
The tail of the vector \AgdaArgument{xs} and the smaller index \AgdaArgument{i}
are indexed over the predecessor of \AgdaArgument{n}.

\subsection{Propositions as Types}

An more in depth explanation and an overview over the history of the idea can be
found in Wadlers paper of the same name \cite{DBLP:journals/cacm/Wadler15}.

\begin{center}
  \begin{tabular}{ccc}
    FOL & MLTT & Agda \\\hline
    $\forall x \in A: P(x)$ & $\Pi_{x:A}P(x)$ & \mintinline{agda}{(x : A) → P x} \\
    $\exists x \in A: P(x)$ & $\Sigma_{x:A} P(x)$ & \mintinline{agda}{Σ[ x ∈ A ] P x} mit \mintinline{agda}{_,_ : (x : A) → P x → Σ A P} \\
    $P \wedge Q$ & $P \times Q$ & \mintinline{agda}{A × B} \\
    $P \vee Q$ & $P + Q$ & \mintinline{agda}{A ⊎ B} \\
    $P \Rightarrow Q$ & $P \rightarrow Q$ & \mintinline{agda}{A → B} \\
    $\mathbf t$ & $\mathbf 1$ & \mintinline{agda}{tt : ⊤} \\
    $\mathbf f$ & $\mathbf 0$ & \mintinline{agda}{⊥}
  \end{tabular}
\end{center}

\subsection{Notions of Equality and Equality Types}

In the last section we saw how we can encode propositions from propositional and
predicate logic as types.
One of the most important proposition is equality i.e. the proposition that
given two terms $a, b : A$ that $a$ and $b$ are equal.
When using Agda for theorem proving we have to express propositions like $a + b
= b + a$ and $2 = 1$, which could be true or false, to be able to prove or
disprove them.
In type theory and therefore in Agda we have to consider different notions of
equality.

When defining a program rule like
\AgdaFunction{truth}\AgdaSpace{}\AgdaSymbol{=}\AgdaSpace{}\AgdaNumber{42}
we are making an \textit{equality judgement}.
The symbol \AgdaFunction{truth} is \textit{definitional equal} to \AgdaNumber{42}.
A judgment is always true.
We define one term to be equal to another one i.e. we allow Agda to reduce the
left hand side of the equality to the right hand side.

The next notion of equality is \textit{computational equality}.
Two terms $t_1$ and $t_2$ are computational equal if they reduce to the same
term.
For example, given the above definition of $+$ the terms $0+(0+n)$ and $n$ are
computational equal, because using the first rule in the definition of plus
$0+(0+n)$ $\beta$-reduces to $n$.
On the other hand $n+0$ and $n$ are not computational equal, because for a free
variable $n$ none of the program rules for $+$ can be used to reduce the term
further.
Therefore computational equality is not the right notion of equality, because
the later equality should also hold.

To talk about the equality of two terms we have to use \textit{propositional
equality} i.e. we have to define a proposition representing the fact that two
terms of type $A$ are equal.
This proposition is usually encapsulated in an \textit{equality type} of $A$.

\begin{code}
infix 4 _≡_
data _≡_ {A : Set} (x : A) : A → Set where
  refl : x ≡ x
\end{code}
The type
\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{≡}\AgdaSpace{}\AgdaArgument{y}
represents the proposition that $x$ and $y$ are equal.
The only way to construct evidence for the proposition is using the
\AgdaInductiveConstructor{refl} constructor i.e. if $x$ and $y$ are actually the
same.

This notion of equality has the usualy expected properties like transitivity,
symmetry and congruence.
The definition of \AgdaFunction{cong} shows the typical way of working with
equality proofs.

\begin{code}
cong : ∀ {A B x y} → (f : A → B) → x ≡ y → f x ≡ f y
cong f refl = refl
\end{code}
We expect that $≡$ is a congruence relation i.e. if $x$ and $y$ are equal then
$f x$ and $f y$ should also be equal.
We cannot produce a value of type
\AgdaArgument{f}\AgdaSpace{}\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{≡}\AgdaSpace{}\AgdaArgument{f}\AgdaSpace{}\AgdaArgument{y}
because the two are not equal.
By pattern matching in the argument of type 
\AgdaArgument{x}\AgdaSpace{}\AgdaDatatype{≡}\AgdaSpace{}\AgdaArgument{y}
i.e. by inspecting the evidence that $x$ and $y$ are equal we obtain more
information about the goal.
Because \AgdaInductiveConstructor{refl} can only be constructed if the two
values are the same the two variables are unified.
We therefore have to produce a proof that $f x$ is equal to itself, which is
given by reflexivity.

By pattern matching on variables used in the equality type we can obtain more
information about the goal.
Either because the constructors them self restrict the use of the variables or
because the terms used in the equality type can be reduced further.
Consider the following example.

\begin{code}
+-identʳ : ∀ n → n + 0 ≡ n
+-identʳ 0        = refl
+-identʳ (suc m)  = cong suc (+-identʳ m)
\end{code}
By pattern matching on the variable $n$ we obtain two cases, one for each
constructor (this is analogous to a proof by exhaustion).
In both cases the term
\AgdaArgument{n}\AgdaSpace{}\AgdaFunction{}\AgdaSpace{}\AgdaNumber{0}
can now be reduced further.
In the \AgdaNumber{0} case we obtain
\AgdaNumber{0}\AgdaSpace{}\AgdaFunction{+}\AgdaSpace{}\AgdaNumber{0}
on the left hand side, which can be reduced to \AgdaNumber{0}.
The return type simplifies to 
\AgdaNumber{0}\AgdaSpace{}\AgdaDatatype{≡}\AgdaSpace{}\AgdaNumber{0}
for which we can simply construct evidence using
\AgdaInductiveConstructor{refl}.

The second case is more complex.
The left hand side still contains the free variable $m$, but reduces to
\AgdaInductiveConstructor{suc}\AgdaSpace{}$($\AgdaArgument{m}\AgdaSpace{}\AgdaFunction{+}\AgdaSpace{}\AgdaNumber{0}$)$
using the second rule for \AgdaFunction{\_+\_}.
Using a recursive call we obtain evidence for
\AgdaArgument{m}\AgdaSpace{}\AgdaFunction{+}\AgdaSpace{}\AgdaNumber{0}\AgdaSpace{}\AgdaDatatype{≡}\AgdaSpace{}\AgdaArgument{m}.
The recursive call to obtain evidence for a smaller case corresponds to the use
of the induction hypothesis in an inductive proof.
By applying \AgdaInductiveConstructor{suc} on both sides of the equality we
obtain a proof for the correct proposition.

We obtained a non obvious equality by using just definitional and computational
equality together with the analogs of proofs by exhaustion and induction.
This proof can now be used to rewrite arbitrary terms containing terms
corresponding to or containing the left- or right-hand of the equality.

\subsection{Termination Checking}
\label{sec:termination-checking}

The definition of non-terminating functions entails logical inconsistency.
Agda therefore only allows the definition terminating functions.
Due to the undecidability of the halting problem Agda uses a heuristic
termination checker.
The termination checker proofs termination by observing structural recursion.
Consider the following definitions of \AgdaDatatype{List} and
\AgdaFunction{map}.

\begin{code}
data List (A : Set) : Set where
  _∷_  : A → List A → List A
  []   : List A

map : {A B : Set} → (A → B) → (List A → List B)
map f (x ∷ xs)  = f x ∷ map f xs
map f []        = []
\end{code}
The \AgdaInductiveConstructor{[]} case does not contain a recursive call.
In the \AgdaInductiveConstructor{\_∷\_} case the recursive call to
\AgdaFunction{map} occurs on a structural smaller argument i.e.
\AgdaArgument{xs} is a subterm of the argument
\AgdaArgument{x}\;\AgdaInductiveConstructor{∷}\;\AgdaArgument{xs}.
Because elements of \AgdaDatatype{List A} are finite the function
\AgdaFunction{map} terminates for every argument.

\subsubsection{Sized Types}
In more complex recursive functions the structural recursion can be obscured.
Agda does not inline functions containing pattern matches during termination
checking and therefore cannot proof the termination.
A common example are recursive calls in lambdas, which are passed
to higher order functions like \AgdaFunction{map} and \AgdaFunction{>>=}.

Consider a monad like \AgdaDatatype{List} or \AgdaDatatype{Maybe}.
It is not obvious that the argument of the continuation of \AgdaFunction{>>=} is
a subterm of the first argument.

TODO: explain better via [SEMI-CONTINUOUS SIZED TYPES AND TERMINATION ABEL]

A possibility to still proof termination are Sized Types.
Agda has a special builtin, well-ordered type \AgdaDatatype{Size}.

\begin{code}
open import Agda.Builtin.Size public
  renaming ( SizeU to SizeUniv )  --  sort SizeUniv
  using    ( Size                 --  Size   : SizeUniv
           ; Size<_               --  Size<_ : Size → SizeUniv
           ; ↑_                   --  ↑_     : Size → Size
           ; _⊔ˢ_                 --  _⊔ˢ_   : Size → Size → Size
           ; ∞ )                  --  ∞      : Size
\end{code}
By augmenting a data type with an index of type \AgdaDatatype{Size} its
size can be represented on the type level.
If a value of type \AgdaDatatype{Size} decreases with every recursive call, the
functions has to termination, because there exist no infinitely decreasing
chains on elements of \AgdaDatatype{Size}.

A common idiom for data types is to mark all non-inductive constructors and
recursive occurrences with an arbitrary size \AgdaArgument{i} and all inductive
constructors with the next larger size
\AgdaFunction{↑}\AgdaSpace{}\AgdaArgument{i}.
The size therefore corresponds to the height of the tree described by the term
($+$ the initial height for the lowest non-inductive constructor).

A common example for sized types are rose trees.
The size index can be intuitively thought of as the height of the tree.

\begin{code}
data Rose (A : Set) : Size → Set where
  rose : ∀ {i} → A → List (Rose A i) → Rose A (↑ i)
\end{code}
When \AgdaFunction{fmap} for rose trees is defined in terms of
\AgdaFunction{map} the termination is obscured.
The argument of the functions passed to \AgdaFunction{map} is not recognized as
structurally smaller than the given rose tree.
Using size annotations we can fix this problem.

\begin{code}
map-rose : {A B : Set} {i : Size} → (A → B) → (Rose A i → Rose B i)
map-rose f (rose x xs) = rose (f x) (map (map-rose f) xs)
\end{code}
By pattern matching on the argument of type
\AgdaDatatype{Rose}\AgdaSpace{}\AgdaArgument{A} of size
\AgdaFunction{↑}\AgdaSpace{}\AgdaArgument{i} we obtain a \AgdaDatatype{List} of
trees of size \AgdaArgument{i}.
The recursive calls via \AgdaFunction{map} therefore occur on smaller trees.
Therefore the functions has to terminates.

In this case inlining the call of \AgdaFunction{map} would also solve the
termination problem.
When generalizing the definition of the tree from \AgdaDatatype{List} to an
arbitrary functor this wouldn't be possible.
In many cases inlining all helper functions is either not feasible or would lead
to large and unreadable programs.


\subsection{Strict Positivity}

In a type system with arbitrary recursive types, it is possible to to implement a
fixpoint combinator and therefore non terminating functions without explicit
recursion.
As explained in section \ref{sec:termination-checking} this entails logical
inconsistency.
Agda allows only strictly positive data types.
A data type $D$ is strictly positive if all constructors are of the form
$$
  A_1 \rightarrow A_2 \rightarrow \dots \rightarrow A_n \rightarrow D
$$
where $A_i$ is either not inductive (does not mention $D$) or are of the form
$$
A_1 \rightarrow B_2 \rightarrow \dots \rightarrow B_n \rightarrow D
$$
where $B_j$ is not inductive.
By restricting recursive occurrences of a data type in its definition to strict
positive positions strong normalization is preserved.

\subsubsection{Container}
\label{container}

Because of the strict positivity requirement it is not allowed to apply generic
type constructors to inductive occurrences of a data type in its definition.
The reason for this restriction is that a type constructor is not required to
use its argument only in strictly positive positions.
To still work generically with type constructors or more precise functors we
need a more restrictive representation, which only uses its argument in a
strictly positive position.
One representation of such functors are containers.

Containers are a generic representation of data type, which store values of an
arbitrary type.
They were introduced by Abbott, Altenkirch and Ghani
\cite{DBLP:conf/fossacs/AbbottAG03}.
A container is defined by a type of shapes $S$ and a type of positions for each
of its shapes $P : S \rightarrow \mathcal{U}$.
Usually containers are denoted $S \rhd P$.
A common example are lists.
The shape of a list is defined by its length, therefore the shape type is
$\mathbb{N}$.
A list of length $n$ has exactly $n$ places or positions containing data.
Therefore, the type of positions is $\Pi_{n : \mathbb{N}}\mathrm{Fin}\;n$ where
$\mathrm{Fin}\;n$ is the type of natural numbers smaller than $n$.
The extension of a container is a functor $\lBrack S \rhd P \rBrack $,
whose lifting of types is given by

$$
  \lBrack S \rhd P \rBrack\;X = \sum\limits_{s : S} P s \rightarrow X.
$$
A lifted type corresponds to the container storing elements of the given type
e.g. $\lBrack\, \mathbb{N} \rhd \mathrm{Fin}\;\rBrack \; A \cong
\mathrm{List}\;A$.
The second element of the dependent pair sometimes called position function.
It assigns each position a stored value.
The functors action on functions is given by

$$
  \lBrack S \rhd P \rBrack \;f\;\langle s , pf \rangle = \langle s , f \circ pf \rangle.
$$
We can translate these definition directly to Agda.
Instead of a \AgdaKeyword{data} declaration we can use \AgdaKeyword{record}
declarations.
Similar to other languages \AgdaKeyword{record}s are pure product types.
A \AgdaKeyword{record} in Agda is an $n$-ary dependent product type i.e. the
type of each field can contain all previous values.

\begin{code}
record Container : Set₁ where
  constructor _▷_
  field
    Shape : Set
    Pos : Shape → Set
open Container public
\end{code}
As expected, a container consists of a type of shapes and a dependent type of
positions.
Notice that \AgdaDatatype{Container} is an element of \AgdaDatatype{Set₁},
because it contains a type from \AgdaDatatype{Set} and therefore has to be
larger.
Next we define the lifting of types i.e. the container extension, as a function
between universes.

\begin{code}
open import Data.Product using (Σ-syntax; _,_) -- TODO: define and explain earlier
open import Function using (_∘_)
⟦_⟧ : Container → Set → Set
⟦ S ▷ P ⟧ A = Σ[ s ∈ S ] (P s → A)
\end{code}
Using this definition we can define \AgdaFunction{fmap} for containers.

\begin{code}
fmap : ∀ {A B C} → (A → B) → (⟦ C ⟧ A → ⟦ C ⟧ B)
fmap f (s , pf) = (s , f ∘ pf)
\end{code}

\section{Curry}

Curry \cite{Hanus95curry} is a functional logic programming language.
It combines paradigms from functional programming languages like Haskell
with those logical languages Prolog.
Curry is based on Haskell i.e. its syntax and semantics not involving
nondeterminism closely resemble Haskell.
Curry integrates logical features, such as nondeterminism and free variables
with a few additional concepts.

When defining a function with overlapping patterns on the left-hand side of
equations all matching right-hand sides are executed.
This introduces non determinism.
Nondeterminism is integrated as an ambient effect i.e. the effect is not
represented at type level.
The simplest example of a nondeterministic function is the choice operator
\texttt{?}.

\begin{minted}{haskell}
     (?) :: A -> A -> A
     x ? _ = x
     _ ? y = y
\end{minted}
Both equations always match, therefore both arguments are returned i.e.
\texttt{?} introduces a nondeterministic choice between its two arguments.
Using choice we can define a simple nondeterministic program.

\begin{minted}{haskell}
     coin :: Int
     coin = 0 ? 1

     twoCoins :: Int
     twoCoins = coin + coin
\end{minted}
\texttt{coin} chooses non-deterministically between $0$ and $1$.
Executing coin therefore yields these two results.
When executing \texttt{twoCoins} the two calls of \texttt{coin} are independent.
Both choose between $0$ and $1$, therefore \texttt{twoCoins} yields the results
$0$, $1$, $1$ and $2$.

\subsection{Call-Time-Choice}
\label{call-time-choice}
Next we will take a look at the interactions between nondeterminism and function
calls.

\begin{minted}{haskell}
     double :: Int -> Int
     double x = x + x
     
     doubleCoin :: Int
     doubleCoin = double coin
\end{minted}
When calling \texttt{double} with a nondeterministic value two behaviors are
conceivable.
The first possibility is that the choice is moved into the function i.e. both
\texttt{x} chose independent of each other yielding the results $0$, $1$, $1$
and $2$.
The second possibility is choosing a value before calling the function and
choosing between the results for each possible argument.
In this case both \texttt{x} have the same value, therefore the possible results
are $0$ and $2$.
This option is called Call-Time-Choice and it is the one implemented by Curry.

Similar to Haskell, Curry programs are evaluated lazily.
The evaluation of an expression is delayed until its result is needed and each
expression is evaluated at most once.
The later is important when expressions are named and reused via \texttt{let}
bindings or lambda abstraction.
The named expression is evaluated the first time it is needed.
If the result is needed again the old value is reused.
This behavior is called sharing.
Usually function application is defined using the \texttt{let} primitive.
Applying a non variable expression to a function introduces a new intermediate
result, which bound using \texttt{let}.
$$
(\lambda x.\sigma) \tau = \texttt{let}\;y = \tau\;\texttt{in}\;\sigma[x\mapsto y]
$$
We therefore expect a variable bound by a \texttt{let} to behave similar to one
bound by a function.
This naturally extends Call-Time-Choice to \texttt{let}-bindings in lazily
evaluated languages.

\begin{minted}{haskell}
     sumCoin :: Int
     sumCoin = let x = coin in x + x
\end{minted}
As expected this function yields the results $0$ and $2$.

\subsection{Permutation Sort}

Introduce Free Variables + Explain for Later Example


\chapter{Algebraic Effects}
\label{chapter:first-order}
\input{FirstOrder}


\chapter{Higher Order}
\label{chapter:higher-order}
\input{HigherOrder}


\chapter{Scoped Algebras}
\label{chapter:scoped-algebras}
\input{ScopedAlgebras}


\chapter{Conclusion}
\section{Summary}

\printbibliography

\end{document}
