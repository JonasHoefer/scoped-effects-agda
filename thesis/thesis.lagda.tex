\documentclass[10pt,a4paper,twoside]{report}

\usepackage[english]{babel}
\usepackage[a4paper,width=150mm,top=25mm,bottom=25mm]{geometry}
% \usepackage[twoside, inner=28mm, outer=37mm, top=35mm, bottom=49mm]{geometry}

\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage{wasysym}
\setmathfont{Latin Modern Math}                 % normal math font
\setmathfont[range={\lBrace,\rBrace,\llparenthesis,\rrparenthesis}]{XITSMath}
% fallback for these 4 glyphs
\setsansfont{Latin Modern Sans}
% \setmainfont{Latin Modern Roman}
% \setmonofont{Fira Code}

\usepackage{newunicodechar}
\newunicodechar{‚Ñï}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{‚à∑}{\ensuremath{\mathnormal{::}}}
\newunicodechar{‚äî}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{‚àÄ}{\ensuremath{\mathnormal{\forall}}}
\newunicodechar{‚Ñì}{\ensuremath{\mathnormal{\ell}}}
\newunicodechar{ùí∞}{\ensuremath{\mathnormal{\mathcal{U}}}}
\newunicodechar{‚ñ∑}{\ensuremath{\mathnormal{\rhd}}}
\newunicodechar{‚óÅ}{\ensuremath{\mathnormal{\lhd}}}
\newunicodechar{‚àà}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{‚¶É}{\ensuremath{\mathnormal{\lBrace}}}
\newunicodechar{‚¶Ñ}{\ensuremath{\mathnormal{\rBrace}}}
\newunicodechar{‚¶á}{\ensuremath{\mathnormal{\llparenthesis}}}
\newunicodechar{‚¶à}{\ensuremath{\mathnormal{\rrparenthesis}}}
\newunicodechar{‚ü®}{\ensuremath{\mathnormal{\langle}}}
\newunicodechar{‚ü©}{\ensuremath{\mathnormal{\rangle}}}
\newunicodechar{‚âÖ}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{‚äï}{\ensuremath{\mathnormal{\oplus}}}
\newunicodechar{‚äé}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{‚äÜ}{\ensuremath{\mathnormal{\subseteq}}}
\newunicodechar{Œ±}{\ensuremath{\mathnormal{\alpha}}}
\newunicodechar{Œ∑}{\ensuremath{\mathnormal{\eta}}}
\newunicodechar{œÉ}{\ensuremath{\mathnormal{\sigma}}}
\newunicodechar{Œ∫}{\ensuremath{\mathnormal{\kappa}}}
\newunicodechar{Œª}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{œÄ}{\ensuremath{\mathnormal{\pi}}}
\newunicodechar{œâ}{\ensuremath{\mathnormal{\omega}}}
\newunicodechar{‚äõ}{\ensuremath{\mathnormal{\circledast}}}
\newunicodechar{‚àò}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{‚â°}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{‚Åá}{\ensuremath{\mathnormal{?\!?}}}
\newunicodechar{‚àé}{\ensuremath{\mathnormal{\QED}}}
\newunicodechar{‚ãØ}{\ensuremath{\mathnormal{\dots}}}
\newunicodechar{‚Üù}{\ensuremath{\mathnormal{\leadsto{}}}}
% see https://tex.stackexchange.com/questions/511401/newunicodechar-fails-for-prime-only
\AtBeginDocument{\newunicodechar{‚Ä≤}{\makebox[\fontcharwd\font`a]{$\prime$}}}
\AtBeginDocument{\newunicodechar{‚Ä≥}{\makebox[\fontcharwd\font`a]{$\dprime$}}}
\newunicodechar{‚ä•}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{‚ä§}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{·∂ú}{\textsuperscript{c}}
\newunicodechar{À°}{\textsuperscript{l}}
\newunicodechar{‚Çô}{\textsubscript{n}}
\newunicodechar{·µñ}{\textsuperscript{p}}
\newunicodechar{ ≥}{\textsuperscript{r}}
\newunicodechar{À¢}{\textsuperscript{s}}
\newunicodechar{À£}{\textsuperscript{x}}
\newunicodechar{·¥∏}{\textsuperscript{L}}
\newunicodechar{·¥π}{\textsuperscript{M}}
\newunicodechar{·¥æ}{\textsuperscript{P}}
\newunicodechar{‚ÇÄ}{\textsubscript{0}}
\newunicodechar{‚ÇÅ}{\textsubscript{1}}
\newunicodechar{‚ÇÇ}{\textsubscript{2}}
\newunicodechar{‚ÇÉ}{\textsubscript{3}}
\newunicodechar{‚ÇÑ}{\textsubscript{4}}
\newunicodechar{‚ÇÖ}{\textsubscript{5}}

\usepackage{hyperref}
\usepackage[links]{agda}
\usepackage{mathtools}

% nicer monadic operators
\newcommand{\fmap}[0]{\ensuremath{<\hspace{.4pt}\mathclap{\raisebox{-0.85pt}{\scalebox{0.95}{$\$$}}}\hspace{.4pt}>}}
\newcommand{\fmapconst}[0]{\ensuremath{<\hspace{.4pt}\mathclap{\raisebox{-0.85pt}{\scalebox{0.95}{$\$$}}}}}
\newcommand{\ap}[0]{\ensuremath{<\hspace{.4pt}\mathclap{*}\hspace{.4pt}>}}
\newcommand{\bind}[0]{\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}
\newcommand{\kleisli}[0]{\ensuremath{\mathbin{>\!\!=\!\!\!>}}}

% replace certain character sequences with the nicer operators
\DeclareRobustCommand{\AgdaFormat}[2]{%
  \ifthenelse{\equal{#1}{>>=}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{>>=\AgdaUnderscore{}}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{>>}}
  {\ensuremath{\mathbin{>\!\!\!>}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ensuremath{\mathbin{>\!\!\!>}}\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{<\$>}}
  {\fmap}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<\$\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\fmapconst{}\;\;\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{<\$}}
  {\fmapconst\;}
  {\ifthenelse{\equal{#1}{>=>}}
  {\kleisli}
  {\ifthenelse{\equal{#1}{++}}
  {\ensuremath{+\!+}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}++\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}+\!+\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}++}}
  {\ensuremath{\AgdaUnderscore{}+\!+}}
  {\ifthenelse{\equal{#1}{++\AgdaUnderscore{}}}
  {\ensuremath{+\!+\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\$}}
  {\ensuremath{\$}}
  {\ifthenelse{\equal{#1}{<\$>\AgdaUnderscore{}}}
  {\fmap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<\$>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\fmap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<*>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<*>}}
  {\AgdaUnderscore{}\ap}
  {\ifthenelse{\equal{#1}{<*>}}
  {\ap}
  {#2}}}}}}}}}}}}}}}}}}}}}

\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric,arrows,fit,matrix,positioning}
\tikzset
{
  treenode/.style = {align=center, anchor=center}
}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}%
\fancyhead[LE,RO]{\thepage}
\fancyhead[LO]{\leftmark}
\fancyhead[RE]{\rightmark}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.0pt}

% Chapter pages
\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyhead[RO,LE]{\thepage}
  \renewcommand{\headrulewidth}{0.0pt}%
  \renewcommand{\footrulewidth}{0.0pt}%
}

\usepackage{minted}

\usepackage[maxcitenames=2,style=numeric,backend=biber]{biblatex}
\addbibresource{thesis.bib}
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}

\title{Implementing a library for scoped algebraic effects in Agda}
\author{Jonas H√∂fer}
\date{2020}

\begin{document}
\begin{titlepage}
  \begin{large}
    \begin{center}

      \includegraphics[width=10cm]{htwk_logo2.png}

      \vskip 2cm

      \textbf{Leipzig University of Applied Sciences}\\
      Faculty of Computer Science and Media\\
      Computer Science\\

      \vskip 2cm

      \textbf{Bachelor Thesis}

      \vskip 2cm

      \textbf{Implementing a library for scoped algebraic effects in Agda}\\

      \vfill

      Author: Jonas H√∂fer\\

      \vskip 2cm

      \begin{tabular}{rl}
        Examiner: & Prof. Dr. Johannes Waldmann\\
                  & M. Sc. Niels Bunkenburg\\
      \end{tabular}

      \vskip 2cm

      Leipzig, \today\\

    \end{center}
  \end{large}
\end{titlepage}

\thispagestyle{plain}
\begin{abstract}
\end{abstract}

\newpage
\setcounter{page}{1}

\tableofcontents

\chapter{Introduction}

Algebraic effects were first introduced by Plotkin and
Powers~\cite{DBLP:journals/acs/PlotkinP03} as an alternative representation for
algebraic computational effects.
Effect handlers were introduced by Plotkin and
Pretnar~\cite{DBLP:conf/esop/PlotkinP09} as a generalization of exception
handlers.
They allow modelling non-algebraic effects and are used in conjunction with
algebraic effects~\cite{DBLP:journals/corr/PlotkinP13}.
Together they form a theoretical well understood representation for a large
class of computational effects.

Algebraic effects and handlers have a wide field of applications e.g. in
programming as a less boiler plate intensive alternative to monad transformers,
as well as to simulate programming semantics in proof
assistants~\cite{DBLP:journals/programming/DylusCT19,DBLP:conf/haskell/ChristiansenDB19}.

\citeauthor{DBLP:conf/haskell/WuSH14} noticed a lack of modularity when
combining computational effects with scoping
operations~\cite{DBLP:conf/haskell/WuSH14}.
They introduce several solutions for the problem, by introducing new operations
and generalizing syntax to delimit scopes.


\section{Goals}

The goal of this thesis is the implementation of an effect library based on the
work by \textcite{DBLP:conf/haskell/WuSH14,DBLP:conf/lics/PirogSWJ18} in
the dependently typed, functional programming language
Agda~\cite{norell:thesis}.
To allow use as a proof assistant, Agda programs are subject to constraints not
present in other functional languages such as Haskell.
All Agda programs have to be total (and therefore terminate), all data types
have to be strictly positive and all universe levels have to be consistent.
These restrictions prevent a direct translation of Haskell code to Agda.

This thesis explores multiple Haskell implementations of scoped effects and
studies how well these translate to Agda.
Furthermore we presents a set of standard solutions for common problems, arising
during the implementation of the Haskell approaches in Agda.

Agda's builtin theorem proving capabilities allow direct, machine checked
correctness proofs for the implemented library.
Alongside the implementation of scoped effects, the library contains proofs for
common properties of these effects.
Furthermore, the library itself can be used to simulate semantics of other
programming languages, such as Curry's~\cite{Hanus95curry} call-time choice, and
allow verification of equivalent programs written in these languages in Agda.
To allow the latter, the library has to be able to represent deep effects i.e.
data structures with effectful components.


\section{Structure}

Chapter \ref{chapter:preliminaries} contains short introductions to Agda and
dependent types, Curry and its call-time choice semantics (which are a central
example for a scoped effect throughout the thesis) and algebraic effects.

Chapter \ref{chapter:first-order} and \ref{chapter:higher-order} explore the two
approaches based on \citetitle{DBLP:conf/haskell/WuSH14} by
~\textcite{DBLP:conf/haskell/WuSH14}.
The former of the two approaches was already partially explored by
\textcite{bunkenburg2019modeling} in Coq and can also be implemented
easily in Agda.
The latter of the two approaches tries to fix some inherent problems of the
first one, but sadly cannot fully be implemented in Agda due to some other
problems with universe consistency.

Chapter \ref{chapter:scoped-algebras} describes an implementation of a novel
representation for scoped effects by \textcite{DBLP:conf/lics/PirogSWJ18} which
also fixes the problems of the first approach, while avoiding the universe
inconsistencies of the second one.
Furthermore, the implementation explores some ideas to modularize the exemplary
Haskell implementation by \citeauthor{DBLP:conf/lics/PirogSWJ18}.

Chapter \ref{chapter:conclusion} summaries and compares the three approaches.
Furthermore, it gives an overview over related and possible future work.

\chapter{Preliminaries}
\label{chapter:preliminaries}
\input{Preliminaries}

\chapter{First Order}
\label{chapter:first-order}
\input{FirstOrder}

\chapter{Higher Order Syntax}
\label{chapter:higher-order}
\input{HigherOrder}

\chapter{Scoped Algebras}
\label{chapter:scoped-algebras}
\input{ScopedAlgebras}

\chapter{Conclusion}
\label{chapter:conclusion}

In this last chapter we recap the work done in the thesis and discuss the
results as well as possible future work.

\section{Summary}

The main goal was to implement a library for scoped algebraic effects by
porting the two haskell implementations from
\citetitle{DBLP:conf/haskell/WuSH14} to Agda.

Of particular significance was to work under Agda's constraints for consistency,
which are needed for theorem proving.
These included defining only function which Agda could prove terminate, as well
as work with a consistent universe structure.
As a running example we tried implementing effects related to simulating Curry's
call-time choice semantics namely the sharing effect by
\textcite{bunkenburg2019modeling}.
In the chapters \ref{chapter:first-order}, \ref{chapter:higher-order} and
\ref{chapter:scoped-algebras} we discussed how three different approaches
translate to Agda.


\section{Results}

In chapter \ref{chapter:first-order} we first implemented ordinary algebraic
effects in Agda.
The implementation only depends on the definition of the free monad, which
implementation using containers, a well known approach.
To prove termination we used sized types, which proved effective, because they
allowed the definition of \textcite{DBLP:conf/haskell/WuSH14} handlers for
explicit scope delimiters as well as avoided excessive inlining.
Furthermore, it was possible to implement the sharing handler by
\textcite{bunkenburg2019modeling} in Agda, making this approach a valid choice
for simulating call-time choice semantics.
A problem with this approach is that it inherently allows mismatched scope
delimiters, that is malformed syntax, which potentially complicates proofs.

In chapter \ref{chapter:higher-order} we tried implementing effects using higher
order syntax, as described by \textcite{DBLP:conf/haskell/WuSH14}.
This approach turned out to be problematic, because it relies on existential
types to capture subcomputations.
Holding onto the idea of storing types directly, we showed that it is not
possible to implement deep effects in a setting with bounded universe levels.
Furthermore, we discussed potential alternative approaches, although non of them
seem promising.
The repository for the library contains a sketch of an implementation with
variable universe levels.
Even thought this approach cannot model deep effects and therefore is not
expressive enough to model Curry's ambient nondeterminism in data structures, we
still presented the key points of a limited implementation of normal scoped
effects.

Due to the deep-seated problem of the approach from chapter
\ref{chapter:higher-order} we experimented with an novel representation by
\textcite{DBLP:conf/lics/PirogSWJ18}, which allowed us to remove the existential
type.
The naive Agda implementation of the monad \textcite{DBLP:conf/lics/PirogSWJ18}
proved to be problematic in terms of theorem proving.
We derived an alternative underlying implementation, based on the work by
\textcite{DBLP:journals/corr/abs-1806-05230}, which allowed the implementation
of complex recursive functions and proofs without the use of sized types.
The approach allows the implementation of deep effects and also can be used to
simulate sharing.
Furthermore, we experimented with a naive modularisation of scoped effects in
this setting.
Even though \textcite{DBLP:conf/lics/PirogSWJ18} noted theoretical problems with
modularity, the implementation seemed promising in our limited, practical
setting and showed parallels to the higher-order approach. % of course, the monads are essentially equivalent


\section{Related Work and future Directions}

\subsection{Future Work}

For each of the three approach, the basic infrastructure as well as some
exemplary effects were presented.
Based on them, the corresponding library could be extended with more effects.
In case of the approaches from chapter \ref{chapter:higher-order} and chapter
\ref{chapter:scoped-algebras} a simplified syntax was used.
Some operations, for example \texttt{pass} and \texttt{listen} for the
\texttt{Writer} effect, have fundamentally different shape, which at the moment
cannot be represented.
Implementing these operations requires generalizing the syntax.
For higher-order approach alternative container representations were mentioned.
For scoped algebras \textcite{DBLP:conf/lics/PirogSWJ18} also note a
generalization for more expressive syntax.

Another area which could be explored further is reasoning about programs using
effects.
All proofs in the thesis either used a fixed effect stack or just hold if the
handlers for the effect was called last.
Most real program use multiple effects, which differ between functions.
Properties of effects may not hold if a non-orthogonal handler is called first.
Exploring this issue and defining structures for proving and using propositions
related to effects could be a useful addition to the library.

The approaches in this thesis are based on the work by
\textcite{DBLP:conf/haskell/WuSH14} and \textcite{DBLP:conf/lics/PirogSWJ18}.
Norell ported the Idris effect library by \textcite{DBLP:conf/icfp/Brady13} to
Agda.
The library does not allow scoped effects, but uses a fundamentally different
structure.
Extending this approach with scoped effects could provide an alternative to the
approaches described implemented in thesis.
Vice versa, one could try extending one of the approaches presented here with
recourse dependent effects.


\printbibliography

\end{document}


% \begin{itemize}
% \item in depth exploration of 3 possible implementations for scoped effects in
%   the dependently Typed language Agda under constraints needed for theorem
%   proving (no \texttt{--type-in-type}, \texttt{--terminating}, ...)
% \item Chapter \ref{chapter:first-order}
%   \begin{itemize}
%     \item (as expected) a working implementation
%     \item library contains modular infrastructure for more effects
%     \item size annotated free monad works out nicely for complex handlers and
%       avoids excessive inlining
%     \item sharing implementation by \textcite{bunkenburg2019modeling} works in Agda
%   \end{itemize}
% \item Chapter \ref{chapter:higher-order}
%   \begin{itemize}
%     \item ultimately failed to meet set goals
%     \item working implementation in setting without deep-effects
%     \item deep effects only work very limited (implementation just in repository)
%     \item discussion about problems regarding the implementation
%     \item Potential future Approaches
%     \begin{itemize}
%       \item typing environment idea (managing the env seemed to complex)
%       \item unifying effectful data and \AgdaDatatype{Prog} data type (data
%         lives just in the higher universe, because it contains computations i.e.
%         it continues the tree; it does not contain arbitrary ``too large'' data;
%         fact currently unused)
%     \end{itemize}
%   \end{itemize}
%   \item Chapter \ref{chapter:scoped-algebras}
%   \begin{itemize}
%     \item general structure lends itself to implementation in Agda
%     \begin{itemize}
%       \item \texttt{fold} avoids use of \AgdaDatatype{Size}
%       \item inherently uses dependent types $\Rightarrow{}$ implementation
%         partly even simplifies in Agda
%     \end{itemize}
%     \item future developments regarding scoped algebras could transfer nicely to Agda
%     \item Intuitive modularisation seems promising, because it shares many
%       parallels with \ref{chapter:higher-order} approach (known bug in
%       \AgdaDatatype{Nondet} handler also occurs in HO setting)
%     \item deep-effects can be modelled without any problem 
%     \item no problem with mismatched scopes in proofs.
%     \item sharing implementation by \textcite{bunkenburg2019modeling} works in Agda
%   \end{itemize}
% \end{itemize}


% \begin{itemize}
%   \item generalize syntax in approach from chapter \ref{chapter:scoped-algebras}
%     ( operations for the \texttt{Writer} monad
%     currently not possible)
%   \item more formal treatment of modular scoped algebra approach,
%     \textcite{DBLP:conf/lics/PirogSWJ18} noted that the approach does not
%     generally compose; what did I do exactly?
%   \item explore equational reasoning in the modular setting
%   \begin{itemize}
%     \item custom \AgdaDatatype{Setoid}
%     \item all current proofs are just for fixed stacks and the head of the
%       current stack.
%     \item Modular lifting of proofs through other handlers i.e. does \texttt{p ?
%         fail = p} hold after running some other effect?
%     \item needed for efficiently proofs of properties of arbitrary programs,
%       which use the library
%   \end{itemize}
%   \item explore different implementations as basis for scoped effects (not only Wu's)
%   \item integrate scoped and resource dependent effects
%   \item Implement more effects
%   \item introduce shorter syntax for effect constraints (e.g. hide
%     \AgdaKeyword{tactic} in \AgdaKeyword{record})
% \end{itemize}