\documentclass[10pt,a4paper,twoside]{report}

\usepackage[english]{babel}
\usepackage[a4paper,width=150mm,top=25mm,bottom=25mm]{geometry}
% \usepackage[twoside, inner=28mm, outer=37mm, top=35mm, bottom=49mm]{geometry}

\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage{wasysym}
\setmathfont{Latin Modern Math}                 % normal math font
\setmathfont[range={\lBrace,\rBrace,\llparenthesis,\rrparenthesis}]{XITSMath}
% fallback for these 4 glyphs
\setsansfont{Latin Modern Sans}
% \setmainfont{Latin Modern Roman}
% \setmonofont{Fira Code}

\usepackage{newunicodechar}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{∷}{\ensuremath{\mathnormal{::}}}
\newunicodechar{⊔}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{∀}{\ensuremath{\mathnormal{\forall}}}
\newunicodechar{ℓ}{\ensuremath{\mathnormal{\ell}}}
\newunicodechar{▷}{\ensuremath{\mathnormal{\rhd}}}
\newunicodechar{◁}{\ensuremath{\mathnormal{\lhd}}}
\newunicodechar{∈}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{⦃}{\ensuremath{\mathnormal{\lBrace}}}
\newunicodechar{⦄}{\ensuremath{\mathnormal{\rBrace}}}
\newunicodechar{⦇}{\ensuremath{\mathnormal{\llparenthesis}}}
\newunicodechar{⦈}{\ensuremath{\mathnormal{\rrparenthesis}}}
\newunicodechar{⟨}{\ensuremath{\mathnormal{\langle}}}
\newunicodechar{⟩}{\ensuremath{\mathnormal{\rangle}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{⊕}{\ensuremath{\mathnormal{\oplus}}}
\newunicodechar{⊎}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{η}{\ensuremath{\mathnormal{\eta}}}
\newunicodechar{κ}{\ensuremath{\mathnormal{\kappa}}}
\newunicodechar{λ}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{π}{\ensuremath{\mathnormal{\pi}}}
\newunicodechar{⊛}{\ensuremath{\mathnormal{\circledast}}}
\newunicodechar{∘}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{≡}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{⁇}{\ensuremath{\mathnormal{?\!?}}}
\newunicodechar{∎}{\ensuremath{\mathnormal{\QED}}}
\newunicodechar{⋯}{\ensuremath{\mathnormal{\dots}}}
\newunicodechar{↝}{\ensuremath{\mathnormal{\leadsto{}}}}
% see https://tex.stackexchange.com/questions/511401/newunicodechar-fails-for-prime-only
\AtBeginDocument{\newunicodechar{′}{\makebox[\fontcharwd\font`a]{$\prime$}}}
\newunicodechar{⊥}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{⊤}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{ˡ}{\textsuperscript{l}}
\newunicodechar{ₙ}{\textsubscript{n}}
\newunicodechar{ᵖ}{\textsuperscript{p}}
\newunicodechar{ʳ}{\textsuperscript{r}}
\newunicodechar{ˢ}{\textsuperscript{s}}
\newunicodechar{ᴸ}{\textsuperscript{L}}
\newunicodechar{ᴹ}{\textsuperscript{M}}
\newunicodechar{ᴾ}{\textsuperscript{P}}
\newunicodechar{₀}{\textsubscript{0}}
\newunicodechar{₁}{\textsubscript{1}}
\newunicodechar{₂}{\textsubscript{2}}
\newunicodechar{₃}{\textsubscript{3}}
\newunicodechar{₄}{\textsubscript{4}}
\newunicodechar{₅}{\textsubscript{5}}

\usepackage{hyperref}
\usepackage[links]{agda}
\usepackage{mathtools}

% nicer monadic operators
\newcommand{\fmap}[0]{\ensuremath{<\hspace{.4pt}\mathclap{\raisebox{-0.85pt}{\scalebox{0.95}{$\$$}}}\hspace{.4pt}>}}
\newcommand{\ap}[0]{\ensuremath{<\hspace{.4pt}\mathclap{*}\hspace{.4pt}>}}
\newcommand{\bind}[0]{\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}

\DeclareRobustCommand{\AgdaFormat}[2]{%
  \ifthenelse{\equal{#1}{>>=}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{>>=\AgdaUnderscore{}}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{>>}}
  {\ensuremath{\mathbin{>\!\!\!>}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ensuremath{\mathbin{>\!\!\!>}}\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{<\$>}}
  {\fmap}
  {\ifthenelse{\equal{#1}{++}}
  {\ensuremath{+\!+}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}++\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}+\!+\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}++}}
  {\ensuremath{\AgdaUnderscore{}+\!+}}
  {\ifthenelse{\equal{#1}{++\AgdaUnderscore{}}}
  {\ensuremath{+\!+\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\$}}
  {\ensuremath{\$}}
  {\ifthenelse{\equal{#1}{<\$>\AgdaUnderscore{}}}
  {\fmap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<\$>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\fmap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<*>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{<*>}}
  {\ap}
  {#2}}}}}}}}}}}}}}}}}

\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric,arrows,fit,matrix,positioning}
\tikzset
{
  treenode/.style = {align=center, anchor=center}
}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}%
\fancyhead[LO,RE]{\thepage}
\fancyhead[RO]{\rightmark}
\fancyhead[LE]{\leftmark}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.0pt}

% Chapter pages
\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyhead[LO,RE]{\thepage}
  \renewcommand{\headrulewidth}{0.0pt}%
  \renewcommand{\footrulewidth}{0.0pt}%
}

\usepackage{minted}

\usepackage[style=alphabetic,backend=biber]{biblatex}
\addbibresource{thesis.bib}
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}

\title{
  {\huge\textbf{Implementing a library for scoped algebraic effects in Agda}}\\
  {\large HTWK Leipzig}
}
\author{
  {Jonas Höfer}\\
  {Informatik}\\
  {69555}
}
\date{2020}

\begin{document}
Notiz: Der Code für alle 3 Ansätze ist quasi fertig.
Aktuell schreibe ich also fast ausschließlich an der Arbeit an sich.
Dieses PDF ist eine unfertige Arbeitsversion.
Einige bereits geschriebene Abschnitte sind noch unfertig oder an der falschen
Position in der Arbeit.

\maketitle
\begin{abstract}
\end{abstract}

\tableofcontents

\chapter{Introduction}

Algebraic effects and their handlers, first introduced by Plotkin, Powers and
Pretnar~\cite{TODO,DBLP:conf/esop/PlotkinP09}, are a theoretical well studied
representation for certain computational effects.

Algebraic effects are generally more modular than traditional monad
transformers.
Wu et al. noticed a lack of modularity when combining multiple operations with
scopes.
They introduced several solutions for the problem, by using new syntax to
delimit scopes.


\section{Goals}

The goal of this thesis is the implementation of an effect library based on the
work by Wu et al.~\cite{DBLP:conf/haskell/WuSH14,DBLP:conf/lics/PirogSWJ18} in
the dependently typed, functional programming language
Agda~\cite{norell:thesis}.
To allow use as a proof assistant, Agda programs are subject to constraints not
present in other functional languages such as Haskell.
All Agda programs have to be total (and therefore terminate), all data types
have to be strictly positive and all universe levels have to be consistent.
These restrictions prevent a direct translation of Haskell code to Agda.

This thesis will explore multiple Haskell implementations of scoped effects and
study how well these translate to Agda.
Furthermore it will present a set of standard solutions for common problems,
arising during the implementation of the three approaches.

Agda's builtin theorem proving capabilities allow direct, machine checked
correctness proofs for the implemented library.
Alongside the implementation of scoped effects, the library should contain
proofs for common properties of these effects.
Furthermore, the library itself can be used to simulate semantics of other
programming languages, such as Curry's call-time choice, and allow verification
of equivalent programs written in these languages in Agda.
To allow the latter, these library should be able to represent deep effects i.e.
data structures with effectful components.


\section{Structure}

Chapter \ref{chapter:preliminaries} contains short introductions to Agda and
dependent types, Curry and its call-time choice semantics (which are a central
example for a scoped effect throughout the thesis) and algebraic effects.

Chapter \ref{chapter:first-order} and \ref{chapter:higher-order} explore the two
approached based on ``Effect Handlers in Scope'' by Wu et al.
The former of the two approaches was already partially explored by Bunkeburg in
Coq and can also be implemented easily in Agda.
The latter of the two approaches tries to fix some inherent problems of the
first one, but sadly cannot fully be implemented in Agda due to some inherent
problems with universe consistency.

Chapter \ref{chapter:scoped-algebras} describes an implementation of a novel
representation for scoped effects by Piróg et
al.~\cite{DBLP:conf/lics/PirogSWJ18} which also fixes the problems of the first
approach, while avoiding the universe inconsistencies of the second one.
Furthermore, the implementation explores some ideas to modularize the exemplary
Haskell implementation by Piróg et al.


\chapter{Preliminaries}
\label{chapter:preliminaries}
\input{Preliminaries}

\chapter{First Order}
\label{chapter:first-order}
\input{FirstOrder}

\chapter{Higher Order Syntax}
\label{chapter:higher-order}
\input{HigherOrder}

\chapter{Scoped Algebras}
\label{chapter:scoped-algebras}
\input{ScopedAlgebras}

\chapter{Conclusion}
\section{Summary}

\printbibliography

\end{document}
