\documentclass[10pt,a4paper,twoside]{report}

\usepackage[english]{babel}
\usepackage[a4paper,width=150mm,top=25mm,bottom=25mm]{geometry}
% \usepackage[twoside, inner=28mm, outer=37mm, top=35mm, bottom=49mm]{geometry}

\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage{wasysym}
\setmathfont{Latin Modern Math}                 % normal math font
\setmathfont[range={\lBrace,\rBrace,\llparenthesis,\rrparenthesis}]{XITSMath}
% fallback for these 4 glyphs
\setsansfont{Latin Modern Sans}
% \setmainfont{Latin Modern Roman}
% \setmonofont{Fira Code}

\usepackage{newunicodechar}
\newunicodechar{‚Ñï}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{‚à∑}{\ensuremath{\mathnormal{::}}}
\newunicodechar{‚äî}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{‚àÄ}{\ensuremath{\mathnormal{\forall}}}
\newunicodechar{‚Ñì}{\ensuremath{\mathnormal{\ell}}}
\newunicodechar{ùí∞}{\ensuremath{\mathnormal{\mathcal{U}}}}
\newunicodechar{‚ñ∑}{\ensuremath{\mathnormal{\rhd}}}
\newunicodechar{‚óÅ}{\ensuremath{\mathnormal{\lhd}}}
\newunicodechar{‚àà}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{‚¶É}{\ensuremath{\mathnormal{\lBrace}}}
\newunicodechar{‚¶Ñ}{\ensuremath{\mathnormal{\rBrace}}}
\newunicodechar{‚¶á}{\ensuremath{\mathnormal{\llparenthesis}}}
\newunicodechar{‚¶à}{\ensuremath{\mathnormal{\rrparenthesis}}}
\newunicodechar{‚ü®}{\ensuremath{\mathnormal{\langle}}}
\newunicodechar{‚ü©}{\ensuremath{\mathnormal{\rangle}}}
\newunicodechar{‚âÖ}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{‚äï}{\ensuremath{\mathnormal{\oplus}}}
\newunicodechar{‚äé}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{‚äÜ}{\ensuremath{\mathnormal{\subseteq}}}
\newunicodechar{Œ±}{\ensuremath{\mathnormal{\alpha}}}
\newunicodechar{Œ∑}{\ensuremath{\mathnormal{\eta}}}
\newunicodechar{œÉ}{\ensuremath{\mathnormal{\sigma}}}
\newunicodechar{Œ∫}{\ensuremath{\mathnormal{\kappa}}}
\newunicodechar{Œª}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{œÄ}{\ensuremath{\mathnormal{\pi}}}
\newunicodechar{œâ}{\ensuremath{\mathnormal{\omega}}}
\newunicodechar{‚äõ}{\ensuremath{\mathnormal{\circledast}}}
\newunicodechar{‚àò}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{‚â°}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{‚Åá}{\ensuremath{\mathnormal{?\!?}}}
\newunicodechar{‚àé}{\ensuremath{\mathnormal{\QED}}}
\newunicodechar{‚ãØ}{\ensuremath{\mathnormal{\dots}}}
\newunicodechar{‚Üù}{\ensuremath{\mathnormal{\leadsto{}}}}
% see https://tex.stackexchange.com/questions/511401/newunicodechar-fails-for-prime-only
\AtBeginDocument{\newunicodechar{‚Ä≤}{\makebox[\fontcharwd\font`a]{$\prime$}}}
\AtBeginDocument{\newunicodechar{‚Ä≥}{\makebox[\fontcharwd\font`a]{$\dprime$}}}
\newunicodechar{‚ä•}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{‚ä§}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{·∂ú}{\textsuperscript{c}}
\newunicodechar{À°}{\textsuperscript{l}}
\newunicodechar{‚Çô}{\textsubscript{n}}
\newunicodechar{·µñ}{\textsuperscript{p}}
\newunicodechar{ ≥}{\textsuperscript{r}}
\newunicodechar{À¢}{\textsuperscript{s}}
\newunicodechar{À£}{\textsuperscript{x}}
\newunicodechar{·¥∏}{\textsuperscript{L}}
\newunicodechar{·¥π}{\textsuperscript{M}}
\newunicodechar{·¥æ}{\textsuperscript{P}}
\newunicodechar{‚ÇÄ}{\textsubscript{0}}
\newunicodechar{‚ÇÅ}{\textsubscript{1}}
\newunicodechar{‚ÇÇ}{\textsubscript{2}}
\newunicodechar{‚ÇÉ}{\textsubscript{3}}
\newunicodechar{‚ÇÑ}{\textsubscript{4}}
\newunicodechar{‚ÇÖ}{\textsubscript{5}}

\usepackage{hyperref}
\usepackage[links]{agda}
\usepackage{mathtools}

% nicer monadic operators
\newcommand{\fmap}[0]{\ensuremath{<\hspace{.4pt}\mathclap{\raisebox{-0.85pt}{\scalebox{0.95}{$\$$}}}\hspace{.4pt}>}}
\newcommand{\fmapconst}[0]{\ensuremath{<\hspace{.4pt}\mathclap{\raisebox{-0.85pt}{\scalebox{0.95}{$\$$}}}}}
\newcommand{\ap}[0]{\ensuremath{<\hspace{.4pt}\mathclap{*}\hspace{.4pt}>}}
\newcommand{\bind}[0]{\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}
\newcommand{\kleisli}[0]{\ensuremath{\mathbin{>\!\!=\!\!\!>}}}

% replace certain character sequences with the nicer operators
\DeclareRobustCommand{\AgdaFormat}[2]{%
  \ifthenelse{\equal{#1}{>>=}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{>>=\AgdaUnderscore{}}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{>>}}
  {\ensuremath{\mathbin{>\!\!\!>}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ensuremath{\mathbin{>\!\!\!>}}\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{<\$>}}
  {\fmap}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<\$\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\fmapconst{}\;\;\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{<\$}}
  {\fmapconst\;}
  {\ifthenelse{\equal{#1}{>=>}}
  {\kleisli}
  {\ifthenelse{\equal{#1}{++}}
  {\ensuremath{+\!+}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}++\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}+\!+\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}++}}
  {\ensuremath{\AgdaUnderscore{}+\!+}}
  {\ifthenelse{\equal{#1}{++\AgdaUnderscore{}}}
  {\ensuremath{+\!+\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\$}}
  {\ensuremath{\$}}
  {\ifthenelse{\equal{#1}{<\$>\AgdaUnderscore{}}}
  {\fmap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<\$>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\fmap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<*>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<*>}}
  {\AgdaUnderscore{}\ap}
  {\ifthenelse{\equal{#1}{<*>}}
  {\ap}
  {#2}}}}}}}}}}}}}}}}}}}}}

\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric,arrows,fit,matrix,positioning}
\tikzset
{
  treenode/.style = {align=center, anchor=center}
}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}%
\fancyhead[LO,RE]{\thepage}
\fancyhead[RO]{\rightmark}
\fancyhead[LE]{\leftmark}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.0pt}

% Chapter pages
\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyhead[LO,RE]{\thepage}
  \renewcommand{\headrulewidth}{0.0pt}%
  \renewcommand{\footrulewidth}{0.0pt}%
}

\usepackage{minted}

\usepackage[maxcitenames=2,style=numeric,backend=biber]{biblatex}
\addbibresource{thesis.bib}
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}

\title{
  {\huge\textbf{Implementing a library for scoped algebraic effects in Agda}}\\
  {\large HTWK Leipzig}
}
\author{
  {Jonas H√∂fer}\\
  {Informatik}\\
  {69555}
}
\date{2020}

\begin{document}
\maketitle
\begin{abstract}
\end{abstract}

\tableofcontents

\chapter{Introduction}

Algebraic effects were first introduced by Plotkin and
Powers~\cite{DBLP:journals/acs/PlotkinP03} as an alternative representation for
algebraic computational effects.
Effect handlers were introduced by Plotkin and
Pretnar~\cite{DBLP:conf/esop/PlotkinP09} as a generalization of exception
handlers.
They allow modelling non-algebraic effects and are used in conjunction with
algebraic effects~\cite{DBLP:journals/corr/PlotkinP13}.
Together they form a theoretical well understood representation for a large
class of computational effects.

Algebraic effects and handlers have a wide field of applications e.g. in
programming as a less boiler plate intensive alternative to monad transformers,
as well as to simulate programming semantics in proof
assistants~\cite{DBLP:journals/programming/DylusCT19,DBLP:conf/haskell/ChristiansenDB19}.

\citeauthor{DBLP:conf/haskell/WuSH14} noticed a lack of modularity when
combining computational effects with scoping
operations~\cite{DBLP:conf/haskell/WuSH14}.
They introduce several solutions for the problem, by introducing new operations
and generalizing syntax to delimit scopes.


\section{Goals}

The goal of this thesis is the implementation of an effect library based on the
work by \textcite{DBLP:conf/haskell/WuSH14,DBLP:conf/lics/PirogSWJ18} in
the dependently typed, functional programming language
Agda~\cite{norell:thesis}.
To allow use as a proof assistant, Agda programs are subject to constraints not
present in other functional languages such as Haskell.
All Agda programs have to be total (and therefore terminate), all data types
have to be strictly positive and all universe levels have to be consistent.
These restrictions prevent a direct translation of Haskell code to Agda.

This thesis explores multiple Haskell implementations of scoped effects and
studies how well these translate to Agda.
Furthermore we presents a set of standard solutions for common problems, arising
during the implementation of the Haskell approaches in Agda.

Agda's builtin theorem proving capabilities allow direct, machine checked
correctness proofs for the implemented library.
Alongside the implementation of scoped effects, the library contains proofs for
common properties of these effects.
Furthermore, the library itself can be used to simulate semantics of other
programming languages, such as Curry's~\cite{Hanus95curry} call-time choice, and
allow verification of equivalent programs written in these languages in Agda.
To allow the latter, the library has to be able to represent deep effects i.e.
data structures with effectful components.


\section{Structure}

Chapter \ref{chapter:preliminaries} contains short introductions to Agda and
dependent types, Curry and its call-time choice semantics (which are a central
example for a scoped effect throughout the thesis) and algebraic effects.

Chapter \ref{chapter:first-order} and \ref{chapter:higher-order} explore the two
approaches based on \citetitle{DBLP:conf/haskell/WuSH14} by
~\textcite{DBLP:conf/haskell/WuSH14}.
The former of the two approaches was already partially explored by
\textcite{bunkenburg2019modeling} in Coq and can also be implemented
easily in Agda.
The latter of the two approaches tries to fix some inherent problems of the
first one, but sadly cannot fully be implemented in Agda due to some other
problems with universe consistency.

Chapter \ref{chapter:scoped-algebras} describes an implementation of a novel
representation for scoped effects by \textcite{DBLP:conf/lics/PirogSWJ18} which
also fixes the problems of the first approach, while avoiding the universe
inconsistencies of the second one.
Furthermore, the implementation explores some ideas to modularize the exemplary
Haskell implementation by \citeauthor{DBLP:conf/lics/PirogSWJ18}.

Chapter \ref{chapter:conclusion} summaries and compares the three approaches.
Furthermore, it gives an overview over related and possible future work.

\chapter{Preliminaries}
\label{chapter:preliminaries}
\input{Preliminaries}

\chapter{First Order}
\label{chapter:first-order}
\input{FirstOrder}

\chapter{Higher Order Syntax}
\label{chapter:higher-order}
\input{HigherOrder}

\chapter{Scoped Algebras}
\label{chapter:scoped-algebras}
\input{ScopedAlgebras}

\chapter{Conclusion}
\label{chapter:conclusion}
\section{Summary}
\section{Related Work}

\printbibliography

\end{document}
