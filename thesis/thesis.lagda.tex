\documentclass[10pt,a4paper,twoside]{report}

\usepackage[english]{babel}
\usepackage[a4paper,width=150mm,top=25mm,bottom=25mm]{geometry}

\usepackage{fontspec}
\usepackage[]{unicode-math}
\usepackage{wasysym}
\setmathfont{Latin Modern Math}
\setmathfont[range={\lBrace,\rBrace}]{XITSMath} % fallback for these two glyphe
\setsansfont{Latin Modern Sans}
% \setmainfont{Latin Modern Roman}
% \setmonofont{Fira Code}

\usepackage{newunicodechar}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{∷}{\ensuremath{\mathnormal{::}}}
\newunicodechar{⊔}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{∀}{\ensuremath{\mathnormal{\forall}}}
\newunicodechar{ℓ}{\ensuremath{\mathnormal{\ell}}}
\newunicodechar{▷}{\ensuremath{\mathnormal{\rhd}}}
\newunicodechar{∈}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{⦃}{\ensuremath{\mathnormal{\lBrace}}}
\newunicodechar{⦄}{\ensuremath{\mathnormal{\rBrace}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{⊕}{\ensuremath{\mathnormal{\oplus}}}
\newunicodechar{⊎}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{λ}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{κ}{\ensuremath{\mathnormal{\kappa}}}
\newunicodechar{⊛}{\ensuremath{\mathnormal{\circledast}}}
\newunicodechar{∘}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{≡}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{⁇}{\ensuremath{\mathnormal{?\!?}}}
% \newunicodechar{′}{\ensuremath{\mathnormal{\prime}}} -- somehow bad
\newunicodechar{⊥}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{⊤}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{ˢ}{\textsuperscript{s}}
\newunicodechar{ˡ}{\textsuperscript{l}}
\newunicodechar{ʳ}{\textsuperscript{r}}
\newunicodechar{₀}{\textsubscript{0}}
\newunicodechar{₁}{\textsubscript{1}}
\newunicodechar{₂}{\textsubscript{2}}

\usepackage{hyperref}
\usepackage[links]{agda}

\DeclareRobustCommand{\AgdaFormat}[2]{%
  \ifthenelse{\equal{#1}{>>=}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{>>=\AgdaUnderscore{}}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{>>}}
  {\ensuremath{\mathbin{>\!\!\!>}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ensuremath{\mathbin{>\!\!\!>}}\AgdaUnderscore{}}
  {#2}}}}}}}

\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}%
\fancyhead[LO,RE]{\thepage}
\fancyhead[RO]{\rightmark}
\fancyhead[LE]{\leftmark}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.0pt}

% Chapter pages
\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyhead[LO,RE]{\thepage}
  \renewcommand{\headrulewidth}{0.0pt}%
  \renewcommand{\footrulewidth}{0.0pt}%
}

\usepackage{minted}

\usepackage[style=alphabetic,backend=biber]{biblatex}
\addbibresource{thesis.bib}

\title{
  {\huge\textbf{Implementing a library for scoped algebraic effects in Agda}}\\
  {\large HTWK Leipzig}
}
\author{
  {Jonas Höfer}\\
  {Informatik}\\
  {69555}
}
\date{Juli 2020}

\begin{document}
\maketitle
\begin{abstract}
\end{abstract}

\tableofcontents

\chapter{Introduction}
\section{Goals}

\chapter{Preliminaries}
\section{Agda}

Agda is a dependently typed functional programming language.
The current version\footnote{\url{https://github.com/agda/agda}} was originally
developed by Ulf Norell under the name Agda2 \cite{norell:thesis}.
Due to its type system Agda can be used as a programming language and as a proof
assistant.

This section contains a short introduction to Agda, dependent types and the idea
of ``Propositions as types'' under which Agda can be used for theorem proving.

Agdas syntax is similar to Haskells.
Data types are declared with syntax similar to Haskells GADTs.
Functions declarations and definitions are also similar to Haskell, except that
Agda uses a single colon for the typing relation.
In the following definition of \AgdaDatatype{ℕ}, \AgdaDatatype{Set} is the type
of all (small) types.

\begin{code}
data ℕ : Set where
  zero  : ℕ
  suc   : ℕ → ℕ
\end{code}
 
Ordinary function definition are syntactically similar to Haskell.
Agda allows the definition of mixfix operators.
A mixfix operator is an nearly arbitrary list of symbols (builtin symbols like
colons are not allowed as part of operators).
Underscores in the operator name are placeholders for future parameters.
A mixfix operator can be applied partially by writing underscores for the
omitted parameters.

In the following definition of plus for natural numbers \AgdaFunction{+} is a
binary operator and therefore containers two underscores.

\begin{code}
_+_ : ℕ → ℕ → ℕ
zero   + m = m
suc n  + m = suc (n + m)
\end{code}
\begin{code}[hide]
{-# BUILTIN NATURAL ℕ #-}
\end{code}

\subsection{Dependent Types}
The following type theoretic definitions are taken from the homotopy type theory
book \cite{hottbook}.
In type theory a type of types is called a universe.
Universes are usually denoted $\mathcal{U}$.
A function whose codomain is a universe is called a type family or dependent
type.
$$
F : A \rightarrow \mathcal{U} \quad\text{where}\quad B(a) : \mathcal{U}
\quad\text{for}\quad a : A
$$
To avoid Russell's paradox, a hierarchy of universes $\mathcal{U}_1 :
\mathcal{U}_2 : \dots$ is introduced.
Usually the universes are cumulative, i.e. if $\tau : \mathcal{U}_n$ then
$\tau : \mathcal{U}_k$ for $k>n$.
by default this is not the case in Agda.
Each type is member of a unique universe, forcing us to do additional
bookkeeping.
Since Agda 2.6.1 an experimental \texttt{--cumulativity} flag exists.

\paragraph{Dependent Function Types ($\Pi$-Types)} are a generalization of
function types.
The codomain of a $\Pi$ type is not fixed, but values with the argument the
function is applied to.
The codomain is defined using a type family of the domain, which specifies the
type of the result for each given argument.

$$
\prod_{a : A} B(a) \quad \text{with}\quad B : A \rightarrow\mathcal{U}
$$
An element of the above type is a function which maps every $a : A$ to a $b :
B(a)$.
In Agda the builtin function type $\Rightarrow$ is a $\Pi$-type.
An arguments can be named by replacing the type $\tau$ with a $x : \tau$, allowing
us to use the value as part of later types.

\paragraph{Dependent Sum Types ($\Sigma$-Types)} are a generalization of product
types.
The type of the second component of the product is not fixed, but varies with
the value of the first.
$$
\sum_{a : A} B(a) \quad \text{with}\quad B : A \rightarrow\mathcal{U}
$$
An element of the above type is a pair consisting of an $a : A$ and a $b : B(a)$.
In Agda \AgdaKeyword{record}s represent $n$-ary $\Sigma$-types.
Each field can be used in the type of the following fields.

\paragraph{Programming with Dependent Types}

A common example for dependent types are fixed length vectors.
The data type depends on a type \AgdaDatatype{A} and a value of type
\AgdaDatatype{ℕ}.

\begin{code}
data Vec (A : Set) : ℕ → Set where
  _∷_  : {n : ℕ} → A → Vec A n → Vec A (suc n)
  []   : Vec A 0
\end{code}
Arguments on the left-hand side of the colon are called parameters and are the
same for all constructors.
Arguments on the right-hand side of the colon are called indices an can differ
for each constructor.
Therefore \AgdaDatatype{Vec}\AgdaSpace{}\AgdaArgument{A} is a family of types
indexed by \AgdaDatatype{ℕ}.

The \AgdaInductiveConstructor{[]} constructor allows us to create an empty
vector of any type, but forces the index to be zero.
The \AgdaInductiveConstructor{\_∷\_} constructor appends an element to the front
of a vector of the same type, increasing the index in the process.
Only these two constructors can be used to construct vectors.
Therefore the index is always equal to the amount of elements stored in the
vector.

By encoding more information about the data in its type we can add extra
constraints to functions working with it.
The following definition of \AgdaFunction{head} avoids error handling or
partiality by excluding the empty vector as a valid argument.

\begin{code}
head : ∀ {A n} → Vec A (suc n) → A
head (x ∷ _) = x
\end{code}
When pattern matching on the argument of \AgdaFunction{head} there is no case
for \AgdaInductiveConstructor{[]}.
The argument has type \AgdaDatatype{Vec A (suc n)} and
\AgdaInductiveConstructor{[]} has type \AgdaDatatype{Vec A 0}.
Those to types cannot be unified, because \AgdaInductiveConstructor{suc} and
\AgdaInductiveConstructor{zero} are different constructors of \AgdaDatatype{ℕ}.
Therefore, the \AgdaInductiveConstructor{[]} case does not apply.
By constraining the type of the function we were able to avoid the case, which
usually requires error handling or introduces partiality.

We can extend this idea to type safe indexing.
A vector of length \AgdaArgument{n} is indexed by the first \AgdaArgument{n}
natural numbers.
The type \AgdaDatatype{Fin}\AgdaSpace{}\AgdaArgument{n} represents the subset of
natural numbers smaller than $n$.

\begin{code}
data Fin : ℕ → Set where
  zero  : {n : ℕ} → Fin (suc n)
  suc   : {n : ℕ} → Fin n → Fin (suc n)
\end{code}
Because $0$ is smaller than every positive natural number,
\AgdaInductiveConstructor{zero} can only be used to construct an element of
\AgdaDatatype{Fin}\AgdaSpace{}$($\AgdaInductiveConstructor{suc}
\AgdaArgument{n}$)$ i.e. for every type except
\AgdaDatatype{Fin}\AgdaSpace{}\AgdaArgument{0}.

If any number is smaller than $n$, then its successor is smaller than $n+1$.
Therefore, if any number is an element of
\AgdaDatatype{Fin}\AgdaSpace{}\AgdaArgument{n}
then its successor is an element of
\AgdaDatatype{Fin}\AgdaSpace{}$($\AgdaInductiveConstructor{suc}\AgdaSpace{}\AgdaArgument{n}$)$.

So we can construct a $k<n$ of type
\AgdaDatatype{Fin}\AgdaSpace{}\AgdaArgument{n} by starting with
\AgdaInductiveConstructor{zero} of type
\AgdaDatatype{Fin}\AgdaSpace{}$($\AgdaArgument{n - k}$)$ and applying
\AgdaInductiveConstructor{suc} $k$ times.
Using this definition of the bounded subsets of natural numbers we can define
\AgdaFunction{\_!\_} for vectors.

\begin{AgdaAlign}
\begin{code}
_!_ : ∀ {A n} → Vec A n → Fin n → A
(x  ∷ _ )  ! zero   = x
(_  ∷ xs)  ! suc i  = xs ! i
\end{code}
Notice that similar to \AgdaFunction{head} there is no case for
\AgdaInductiveConstructor{[]}.
\AgdaArgument{n} is used as index for
\AgdaDatatype{Vec}\AgdaSpace{}\AgdaArgument{A} and \AgdaDatatype{Fin}.
The constructors for \AgdaDatatype{Fin} only use \AgdaInductiveConstructor{suc},
therefore the type \AgdaDatatype{Fin}\AgdaSpace{}\AgdaInductiveConstructor{zero}
is not inhabited and the cases for \AgdaInductiveConstructor{[]} do not apply.

By case splitting on the vector first we could have obtained the term
\AgdaInductiveConstructor{[]}\AgdaSpace{}\AgdaFunction{!}\AgdaArgument{i}.
By case splitting on \AgdaArgument{i} we notice that no constructor for
\AgdaDatatype{Fin zero} exists.
Therefore, this case cannot occur, because the type of the argument is
uninhabited.
It's impossible to call the function, because we cannot construct an argument of
the correct type.
In this example we can either omit the case or explicitly state that the
argument is impossible to construct, by replacing it with $()$, allowing us to
omit the definition of the right-hand side of the equation.

\begin{code}
[]         ! () -- no right-hand side
\end{code}
\end{AgdaAlign}
The other two cases are straightforward.
For index \AgdaInductiveConstructor{zero} we return the hard of the vector.
For index \AgdaInductiveConstructor{suc}\AgdaSpace{}\AgdaArgument{i} we call
\AgdaFunction{\_!\_} recursively with the smaller index and the tail of the
vector.
Notice that the types for the recursive call change.
The tail of the vector \AgdaArgument{xs} and the smaller index \AgdaArgument{i}
are indexed over the predecessor of \AgdaArgument{n}.

\subsection{Propositions as Types}

An more in depth explanation and an overview over the history of the idea can be
found in Wadlers paper of the same name \cite{DBLP:journals/cacm/Wadler15}.

\begin{center}
  \begin{tabular}{ccc}
    FOL & MLTT & Agda \\\hline
    $\forall x \in A: P(x)$ & $\Pi_{x:A}P(x)$ & \mintinline{agda}{(x : A) → P x} \\
    $\exists x \in A: P(x)$ & $\Sigma_{x:A} P(x)$ & \mintinline{agda}{Σ[ x ∈ A ] P x} mit \mintinline{agda}{_,_ : (x : A) → P x → Σ A P} \\
    $P \wedge Q$ & $P \times Q$ & \mintinline{agda}{A × B} \\
    $P \vee Q$ & $P + Q$ & \mintinline{agda}{A ⊎ B} \\
    $P \Rightarrow Q$ & $P \rightarrow Q$ & \mintinline{agda}{A → B} \\
    $\mathbf t$ & $\mathbf 1$ & \mintinline{agda}{tt : ⊤} \\
    $\mathbf f$ & $\mathbf 0$ & \mintinline{agda}{⊥}
  \end{tabular}
\end{center}

\subsection{Termination Checking}
\label{sec:termination-checking}

The definition of non-terminating functions entails logical inconsistency.
Agda therefore only allows the definition terminating functions.
Due to the Undecidability of the halting problem Agda uses a heuristic termination checker.
The termination checker proofs termination by observing structural recursion.
Consider the following definitions of \AgdaDatatype{List} and \AgdaFunction{map}.

\begin{code}
data List (A : Set) : Set where
  _∷_  : A → List A → List A
  []   : List A

map : {A B : Set} → (A → B) → (List A → List B)
map f (x ∷ xs)  = f x ∷ map f xs
map f []        = []
\end{code}

The \AgdaInductiveConstructor{[]} case does not contain a recursive calls.
In the \AgdaInductiveConstructor{\_∷\_} case the recursive call to
\AgdaFunction{map} occurs on a structural smaller argument i.e.
\AgdaArgument{xs} is a subterm of the argument
\AgdaArgument{x}\;\AgdaInductiveConstructor{∷}\;\AgdaArgument{xs}.
Because elements of \AgdaDatatype{List A} are finite the function
\AgdaFunction{map} terminates for every argument.

\subsubsection{Sized Types}

\begin{code}
open import Agda.Builtin.Size public
  renaming ( SizeU to SizeUniv )  --  sort SizeUniv
  using    ( Size                 --  Size   : SizeUniv
           ; Size<_               --  Size<_ : Size → SizeUniv
           ; ↑_                   --  ↑_     : Size → Size
           ; _⊔ˢ_                 --  _⊔ˢ_   : Size → Size → Size
           ; ∞ )                  --  ∞      : Size

data Rose (A : Set) : Size → Set where
  rose : ∀ {i} → A → List (Rose A i) → Rose A (↑ i)

map-rose : {A B : Set} {i : Size} → (A → B) → (Rose A i → Rose B i)
map-rose f (rose x xs) = rose (f x) (map (map-rose f) xs)
\end{code}

\subsection{Strict Positivity}

In a type system with arbitrary recursive types, it is possible to to implement a
fixpoint combinator and therefore non terminating functions without explicit
recursion.
As explained in section \ref{sec:termination-checking} this entails logical
inconsistency.
Agda allows only strictly positive data types.
A data type $D$ is strictly positive if all constructors are of the form
$$
  A_1 \rightarrow A_2 \rightarrow \dots \rightarrow A_n \rightarrow D
$$
where $A_i$ is either not inductive (does not mention $D$) or are of the form
$$
A_1 \rightarrow B_2 \rightarrow \dots \rightarrow B_n \rightarrow D
$$
where $B_j$ is not inductive.
By restricting recursive occurrences of a data type in its definition to strict
positive positions strong normalization is preserved.

\subsubsection{Container}
\label{container}

Because of the strict positivity requirement it is not allowed to apply generic
type constructors to inductive occurrences of a data type in its definition.
The reason for this restriction is that a type constructor is not required to
use its argument only in strictly positive positions.
To still work generically with type constructors or more precise functors we
need a more restrictive representation, which only uses its argument in a
strictly positive position.
One representation of such functors are containers.

Containers are a generic representation of data type, which store values of an
arbitrary type.
They were introduced by Abbott, Altenkirch and Ghani
\cite{DBLP:conf/fossacs/AbbottAG03}.
A container is defined by a type of shapes $S$ and a type of positions for each
of its shapes $P : S \rightarrow \mathcal{U}$.
Usually containers are denoted $S \rhd P$.
A common example are lists.
The shape of a list is defined by its length, therefore the shape type is
$\mathbb{N}$.
A list of length $n$ has exactly $n$ places or positions containing data.
Therefore, the type of positions is $\Pi_{n : \mathbb{N}}\mathrm{Fin}\;n$ where
$\mathrm{Fin}\;n$ is the type of natural numbers smaller than $n$.
The extension of a container is a functor $\lBrack S \rhd P \rBrack $,
whose lifting of types is given by

$$
  \lBrack S \rhd P \rBrack\;X = \sum\limits_{s : S} P s \rightarrow X.
$$
A lifted type corresponds to the container storing elements of the given type
e.g. $\lBrack\, \mathbb{N} \rhd \mathrm{Fin}\;\rBrack \; A \cong
\mathrm{List}\;A$.
The second element of the dependent pair sometimes called position function.
It assigns each position a stored value.
The functors action on functions is given by

$$
  \lBrack S \rhd P \rBrack \;f\;\langle s , pf \rangle = \langle s , f \circ pf \rangle.
$$
We can translate these definition directly to Agda.
Instead of a \AgdaKeyword{data} declaration we can use \AgdaKeyword{record}
declarations.
Similar to other languages \AgdaKeyword{record}s are pure product types.
A \AgdaKeyword{record} in Agda is an $n$-ary dependent product type i.e. the
type of each field can contain all previous values.

\begin{code}
record Container : Set₁ where
  constructor _▷_
  field
    Shape : Set
    Pos : Shape → Set
open Container public
\end{code}
As expected, a container consists of a type of shapes and a dependent type of
positions.
Notice that \AgdaDatatype{Container} is an element of \AgdaDatatype{Set₁},
because it contains a type from \AgdaDatatype{Set} and therefore has to be
larger.
Next we define the lifting of types i.e. the container extension, as a function
between universes.

\begin{code}
open import Data.Product using (Σ-syntax; _,_) -- TODO: define and explain earlier
open import Function using (_∘_)
⟦_⟧ : Container → Set → Set
⟦ S ▷ P ⟧ A = Σ[ s ∈ S ] (P s → A)
\end{code}
Using this definition we can define \AgdaFunction{fmap} for containers.

\begin{code}
fmap : ∀ {A B C} → (A → B) → (⟦ C ⟧ A → ⟦ C ⟧ B)
fmap f (s , pf) = (s , f ∘ pf)
\end{code}

\section{Curry}

Curry \cite{Hanus95curry} is a functional logic programming language.
It combines paradigms from functional programming languages like Haskell
with those logical languages Prolog.
Curry is based on Haskell i.e. its syntax and semantics not involve
nondeterminism closely resemble Haskell.
Curry integrates logical features, such as nondeterminism and free variables
with a few additional concepts.

When defining a function with overlapping patterns on the left-hand side of
equations all matching right-hand sides are executed.
This introduces non determinism.
The simplest example of such a function is the choice operator \texttt{?}.

\begin{minted}{haskell}
     (?) :: A -> A -> A
     x ? _ = x
     _ ? y = y
\end{minted}
Both equations always match, therefore both arguments are returned i.e.
\texttt{?} introduces a nondeterministic choice between its two arguments.
Using choice we can define a simple nondeterministic program.

\begin{minted}{haskell}
     coin :: Int
     coin = 0 ? 1

     twoCoins :: Int
     twoCoins = coin + coin
\end{minted}
\texttt{coin} chooses non-deterministically between $0$ and $1$.
Executing coin therefore yields these two results.
When executing \texttt{twoCoins} the two calls of \texttt{coin} are independent.
Both choose between $0$ and $1$, therefore \texttt{twoCoins} yields the results
$0$, $1$, $1$ and $2$.

\subsubsection{Call-Time-Choice}

Next we will take a look at the interactions between nondeterminism and function
calls.

\begin{minted}{haskell}
     double :: Int -> Int
     double x = x + x
     
     doubleCoin :: Int
     doubleCoin = double coin
\end{minted}
When calling \texttt{double} with a nondeterministic value two behaviors are
conceivable.
The first possibility is that the choice is moved into the function i.e. both
\texttt{x} chose independent of each other yielding the results $0$, $1$, $1$
and $2$.
The second possibility is choosing a value before calling the function and
choosing between the results for each possible argument.
In this case both \texttt{x} have the same value, therefore the possible results
are $0$ and $2$.
This option is called Call-Time-Choice and it is the one implemented by Curry.

Similar to Haskell, Curry programs are evaluated lazily.
The evaluation of an expression is delayed until its result is needed and each
expression is evaluated at most once.
The later is important when expressions are named and reused via \texttt{let}
bindings or lambda abstraction.
The named expression is evaluated the first time it is needed.
If the result is needed again the old value is reused.
This behavior is called sharing.
Usually function application is defined using the \texttt{let} primitive.
Applying a non variable expression to a function introduces a new intermediate
result, which bound using \texttt{let}.
$$
  (\lambda x.\sigma) \tau = \texttt{let}\;y = \tau\;\texttt{in}\;\sigma[x\mapsto
  y]
$$
We therefore expect a variable bound by a \texttt{let} to behave similar to one
bound by a function.
This naturally extends Call-Time-Choice to \texttt{let}-bindings in lazily
evaluated languages.

\begin{minted}{haskell}
     sumCoin :: Int
     sumCoin = let x = coin in x + x
\end{minted}
As expected this function yields the results $0$ and $1$.

\subsubsection{Permutation Sort}

Introduce Free Variables + Explain for Later Example


\chapter{Algebraic Effects}
\input{FirstOrder}

\chapter{Higher Order}

\chapter{Conclusion}
\section{Summary}

\printbibliography

\end{document}
