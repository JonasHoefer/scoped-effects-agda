\documentclass[10pt,a4paper,twoside]{report}

\usepackage[english]{babel}
\usepackage[a4paper,width=150mm,top=25mm,bottom=25mm]{geometry}

\usepackage{fontspec}
\usepackage[]{unicode-math}
\usepackage{wasysym}
\setmathfont{Latin Modern Math}
\setmathfont[range={\lBrace,\rBrace}]{XITSMath} % fallback for these two glyphe
\setsansfont{Latin Modern Sans}
% \setmainfont{Latin Modern Roman}
% \setmonofont{Fira Code}

\usepackage{newunicodechar}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{∷}{\ensuremath{\mathnormal{::}}}
\newunicodechar{⊔}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{∀}{\ensuremath{\mathnormal{\forall}}}
\newunicodechar{ℓ}{\ensuremath{\mathnormal{\ell}}}
\newunicodechar{▷}{\ensuremath{\mathnormal{\rhd}}}
\newunicodechar{∈}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{⦃}{\ensuremath{\mathnormal{\lBrace}}}
\newunicodechar{⦄}{\ensuremath{\mathnormal{\rBrace}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{⊕}{\ensuremath{\mathnormal{\oplus}}}
\newunicodechar{⊎}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{λ}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{κ}{\ensuremath{\mathnormal{\kappa}}}
\newunicodechar{⊛}{\ensuremath{\mathnormal{\circledast}}}
\newunicodechar{∘}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{≡}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{⁇}{\ensuremath{\mathnormal{?\!?}}}
\newunicodechar{⊥}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{ˢ}{\textsuperscript{s}}
\newunicodechar{ˡ}{\textsuperscript{l}}
\newunicodechar{ʳ}{\textsuperscript{r}}
\newunicodechar{₀}{\textsubscript{0}}
\newunicodechar{₁}{\textsubscript{1}}
\newunicodechar{₂}{\textsubscript{2}}

\usepackage{hyperref}
\usepackage[links]{agda}

\DeclareRobustCommand{\AgdaFormat}[2]{%
  \ifthenelse{\equal{#1}{>>=}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{>>=\AgdaUnderscore{}}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{>>}}
  {\ensuremath{\mathbin{>\!\!\!>}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ensuremath{\mathbin{>\!\!\!>}}\AgdaUnderscore{}}
  {#2}}}}}}}

\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}%
\fancyhead[LO,RE]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.0pt}

% Chapter pages
\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyhead[LO,RE]{\thepage}
  \renewcommand{\headrulewidth}{0.0pt}%
  \renewcommand{\footrulewidth}{0.0pt}%
}

\usepackage{minted}

\usepackage[style=alphabetic,backend=biber]{biblatex}
\addbibresource{thesis.bib}

\title{
  {\huge\textbf{Implementing a library for scoped algebraic effects in Agda}}\\
  {\large HTWK Leipzig}
}
\author{
  {Jonas Höfer}\\
  {Informatik}\\
  {69555}
}
\date{Juli 2020}

\begin{document}
\maketitle
\begin{abstract}
\end{abstract}

\tableofcontents

\chapter{Introduction}
\section{Goals}

\chapter{Preliminaries}
\section{Agda}

Agda is a dependently typed functional programming language.
The current version\footnote{\url{https://github.com/agda/agda}} was originally
developed by Ulf Norell under the name Agda2 \cite{norell:thesis}.
Due to its type system Agda can be used as a programming language and as a proof
assistant.

This section contains a short introduction to Agda, dependent types and the idea
of ``Propositions as types'' under which Agda can be used for theorem proofing.

Agdas syntax is similar to Haskells.
Data types are declared with syntax similar to Haskells GADTs.
Functions declarations and definitions are also similar to Haskell, except that
Agda uses a single colon for the typing relation.
In the following definition of \AgdaDatatype{ℕ}, \AgdaDatatype{Set} is the type
of all (small) types.

\begin{code}
data ℕ : Set where
  zero  : ℕ
  suc   : ℕ → ℕ
 
_+_ : ℕ → ℕ → ℕ
zero   + m = m
suc n  + m = suc (n + m)
\end{code}
\begin{code}[hide]
{-# BUILTIN NATURAL ℕ #-}
\end{code}

\subsection{Dependent Types}
The following type theoretic definitions are taken from the homotopy type theory
book \cite{hottbook}.
In type theory a type of types is called a universe.
Universes are usually denoted $\mathcal{U}$.
A function whose codomain is a universe is called a type family or dependent
type.
$$
F : A \rightarrow \mathcal{U} \quad\text{where}\quad B(a) : \mathcal{U}
\quad\text{for}\quad a : A
$$
To avoid Russell's paradox, i.e. there cannot exist a type of all types, a
hierarchy of universes is introduced.

\paragraph{Dependent Function Types ($\Pi$-Types)} are a generalization of
function types.
The codomain of a $\Pi$ type is not fixed, but values with the argument the
function is applied to.
The codomain is defined using a type family of the domain, which specifies the
type of the result for each given argument.

$$
\Pi_{a : A} B(a) \quad \text{with}\quad B : A \rightarrow\mathcal{U}
$$
An element of the above type is a function which maps every $a : A$ to a $b :
B(a)$.

\paragraph{Dependent Sum Types ($\Sigma$-Types)} are a generalization of product
types.
The type of the second component of the product is not fixed, but varies with
the value of the first.
$$
\Sigma_{a : A} B(a) \quad \text{with}\quad B : A \rightarrow\mathcal{U}
$$

\paragraph{In Agda}

Consider the following definition of a vector.
The data type depends on a type \AgdaDatatype{A} and a value of type
\AgdaDatatype{ℕ}.
Therefore, it's a family of types indexed by \AgdaDatatype{ℕ}.
Each $n : \mathbb{N}$ is mapped to the type \AgdaDatatype{Vec A n}.

\begin{code}
data Vec (A : Set) : ℕ → Set where
  _∷_  : {n : ℕ} → A → Vec A n → Vec A (suc n)
  []   : Vec A 0
\end{code}
Arguments on the left-hand side of the colon are called parameters and are the
same for all constructors.
Arguments on the right-hand side of the colon are called indices an can differ
for each constructor.

The \AgdaInductiveConstructor{[]} constructor allows us to create an empty
vector of any type, but forces the index to be zero.
The \AgdaInductiveConstructor{\_∷\_} constructor appends an element to the front
of a vector of the same type, increasing the index in the process.
Only these two constructors can be used to construct vectors.
Therefore the index is always equal to the amount of elements stored in the
vector.

By encoding more information about the data in its type we can add extra
constraints to functions working with it.
The following definition of \AgdaFunction{head} avoids error handling or
partiality by excluding the empty vector as a valid argument.

\begin{code}
head : ∀ {A n} → Vec A (suc n) → A
head (x ∷ _) = x
\end{code}
When pattern matching on the argument of \AgdaFunction{head} there is no case
for \AgdaInductiveConstructor{[]}.
The argument has type \AgdaDatatype{Vec A (suc n)} and
\AgdaInductiveConstructor{[]} has type \AgdaDatatype{Vec A 0}.
Those to types cannot be unified, because \AgdaInductiveConstructor{suc} and
\AgdaInductiveConstructor{zero} are different constructors of \AgdaDatatype{ℕ}.
Therefore, the \AgdaInductiveConstructor{[]} case does not apply.
By constraining the type of the function we were able to avoid the case, which
usually requires error handling or introduces partiality.

\subsection{Propositions as Types}

An more in depth explanation and an overview over the history of the idea can be
found in Wadlers paper of the same name \cite{DBLP:journals/cacm/Wadler15}.

\begin{center}
  \begin{tabular}{ccc}
    FOL & MLTT & Agda \\\hline
    $\forall x \in A: P(x)$ & $\Pi_{x:A}P(x)$ & \mintinline{agda}{(x : A) → P x} \\
    $\exists x \in A: P(x)$ & $\Sigma_{x:A} P(x)$ & \mintinline{agda}{Σ[ x ∈ A ] P x} mit \mintinline{agda}{_,_ : (x : A) → P x → Σ A P} \\
    $P \wedge Q$ & $P \times Q$ & \mintinline{agda}{A × B} \\
    $P \vee Q$ & $P + Q$ & \mintinline{agda}{A ⊎ B} \\
    $P \Rightarrow Q$ & $P \rightarrow Q$ & \mintinline{agda}{A → B} \\
    $\mathbf t$ & $\mathbf 1$ & \mintinline{agda}{tt : ⊤} \\
    $\mathbf f$ & $\mathbf 0$ & \mintinline{agda}{⊥}
  \end{tabular}
\end{center}

\subsection{Strict Positivity}

\subsubsection{Container}

\subsection{Termination Checking}

The definition of non-terminating functions entails logical inconsistency.
Agda therefore only allows the definition terminating functions.
Due to the Undecidability of the halting problem Agda uses a heuristic termination checker.
The termination checker proofs termination by observing structural recursion.
Consider the following definitions of \AgdaDatatype{List} and \AgdaFunction{map}.

\begin{code}
data List (A : Set) : Set where
  _∷_  : A → List A → List A
  []   : List A

map : {A B : Set} → (A → B) → (List A → List B)
map f (x ∷ xs)  = f x ∷ map f xs
map f []        = []
\end{code}

The \AgdaInductiveConstructor{[]} case does not contain a recursive calls.
In the \AgdaInductiveConstructor{\_∷\_} case the recursive call to
\AgdaFunction{map} occurs on a structural smaller argument i.e.
\AgdaArgument{xs} is a subterm of the argument
\AgdaArgument{x}\;\AgdaInductiveConstructor{∷}\;\AgdaArgument{xs}.
Because elements of \AgdaDatatype{List A} are finite the function
\AgdaFunction{map} terminates for every argument.

\subsubsection{Sized Types}

\begin{code}
open import Agda.Builtin.Size public
  renaming ( SizeU to SizeUniv )  --  sort SizeUniv
  using    ( Size                 --  Size   : SizeUniv
           ; Size<_               --  Size<_ : Size → SizeUniv
           ; ↑_                   --  ↑_     : Size → Size
           ; _⊔ˢ_                 --  _⊔ˢ_   : Size → Size → Size
           ; ∞ )                  --  ∞      : Size

data Rose (A : Set) : Size → Set where
  rose : ∀ {i} → A → List (Rose A i) → Rose A (↑ i)

map-rose : {A B : Set} {i : Size} → (A → B) → (Rose A i → Rose B i)
map-rose f (rose x xs) = rose (f x) (map (map-rose f) xs)
\end{code}

\section{Curry and Call-Time-Choice}
let x = coin in x + x

\chapter{Algebraic Effects}
\input{FirstOrder}

\chapter{Higher Order}

\chapter{Conclusion}
\section{Summary}

\printbibliography

\end{document}
