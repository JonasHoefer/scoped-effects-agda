\documentclass[10pt,a4paper,twoside]{report}

\usepackage[english]{babel}
\usepackage[a4paper,width=150mm,top=25mm,bottom=25mm]{geometry}
% \usepackage[twoside, inner=28mm, outer=37mm, top=35mm, bottom=49mm]{geometry}

\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage{wasysym}
\setmathfont{Latin Modern Math}                 % normal math font
\setmathfont[range={\lBrace,\rBrace,\llparenthesis,\rrparenthesis}]{XITSMath}
% fallback for these 4 glyphs
\setsansfont{Latin Modern Sans}
% \setmainfont{Latin Modern Roman}
% \setmonofont{Fira Code}

\usepackage{newunicodechar}
\newunicodechar{ℕ}{\ensuremath{\mathnormal{\mathbb{N}}}}
\newunicodechar{∷}{\ensuremath{\mathnormal{::}}}
\newunicodechar{⊔}{\ensuremath{\mathnormal{\sqcup}}}
\newunicodechar{∀}{\ensuremath{\mathnormal{\forall}}}
\newunicodechar{ℓ}{\ensuremath{\mathnormal{\ell}}}
\newunicodechar{▷}{\ensuremath{\mathnormal{\rhd}}}
\newunicodechar{◁}{\ensuremath{\mathnormal{\lhd}}}
\newunicodechar{∈}{\ensuremath{\mathnormal{\in}}}
\newunicodechar{⦃}{\ensuremath{\mathnormal{\lBrace}}}
\newunicodechar{⦄}{\ensuremath{\mathnormal{\rBrace}}}
\newunicodechar{⦇}{\ensuremath{\mathnormal{\llparenthesis}}}
\newunicodechar{⦈}{\ensuremath{\mathnormal{\rrparenthesis}}}
\newunicodechar{⟨}{\ensuremath{\mathnormal{\langle}}}
\newunicodechar{⟩}{\ensuremath{\mathnormal{\rangle}}}
\newunicodechar{≅}{\ensuremath{\mathnormal{\cong}}}
\newunicodechar{⊕}{\ensuremath{\mathnormal{\oplus}}}
\newunicodechar{⊎}{\ensuremath{\mathnormal{\uplus}}}
\newunicodechar{η}{\ensuremath{\mathnormal{\eta}}}
\newunicodechar{κ}{\ensuremath{\mathnormal{\kappa}}}
\newunicodechar{λ}{\ensuremath{\mathnormal{\lambda}}}
\newunicodechar{π}{\ensuremath{\mathnormal{\pi}}}
\newunicodechar{⊛}{\ensuremath{\mathnormal{\circledast}}}
\newunicodechar{∘}{\ensuremath{\mathnormal{\circ}}}
\newunicodechar{≡}{\ensuremath{\mathnormal{\equiv}}}
\newunicodechar{⁇}{\ensuremath{\mathnormal{?\!?}}}
\newunicodechar{∎}{\ensuremath{\mathnormal{\QED}}}
\newunicodechar{⋯}{\ensuremath{\mathnormal{\dots}}}
\newunicodechar{↝}{\ensuremath{\mathnormal{\leadsto{}}}}
% see https://tex.stackexchange.com/questions/511401/newunicodechar-fails-for-prime-only
\AtBeginDocument{\newunicodechar{′}{\makebox[\fontcharwd\font`a]{$\prime$}}}
\newunicodechar{⊥}{\ensuremath{\mathnormal{\bot}}}
\newunicodechar{⊤}{\ensuremath{\mathnormal{\top}}}
\newunicodechar{ˡ}{\textsuperscript{l}}
\newunicodechar{ₙ}{\textsubscript{n}}
\newunicodechar{ᵖ}{\textsuperscript{p}}
\newunicodechar{ʳ}{\textsuperscript{r}}
\newunicodechar{ˢ}{\textsuperscript{s}}
\newunicodechar{ᴸ}{\textsuperscript{L}}
\newunicodechar{ᴹ}{\textsuperscript{M}}
\newunicodechar{ᴾ}{\textsuperscript{P}}
\newunicodechar{₀}{\textsubscript{0}}
\newunicodechar{₁}{\textsubscript{1}}
\newunicodechar{₂}{\textsubscript{2}}
\newunicodechar{₃}{\textsubscript{3}}
\newunicodechar{₄}{\textsubscript{4}}
\newunicodechar{₅}{\textsubscript{5}}

\usepackage{hyperref}
\usepackage[links]{agda}
\usepackage{mathtools}

% nicer monadic operators
\newcommand{\fmap}[0]{\ensuremath{<\hspace{.4pt}\mathclap{\raisebox{-0.85pt}{\scalebox{0.95}{$\$$}}}\hspace{.4pt}>}}
\newcommand{\ap}[0]{\ensuremath{<\hspace{.4pt}\mathclap{*}\hspace{.4pt}>}}
\newcommand{\bind}[0]{\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}

\DeclareRobustCommand{\AgdaFormat}[2]{%
  \ifthenelse{\equal{#1}{>>=}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}}}
  {\ifthenelse{\equal{#1}{>>=\AgdaUnderscore{}}}
  {\ensuremath{\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>=\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}\mathbin{>\!\!\!>\mkern-6.7mu=}\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{>>}}
  {\ensuremath{\mathbin{>\!\!\!>}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}>>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ensuremath{\mathbin{>\!\!\!>}}\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{<\$>}}
  {\fmap}
  {\ifthenelse{\equal{#1}{++}}
  {\ensuremath{+\!+}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}++\AgdaUnderscore{}}}
  {\ensuremath{\AgdaUnderscore{}+\!+\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}++}}
  {\ensuremath{\AgdaUnderscore{}+\!+}}
  {\ifthenelse{\equal{#1}{++\AgdaUnderscore{}}}
  {\ensuremath{+\!+\AgdaUnderscore{}}}
  {\ifthenelse{\equal{#1}{\$}}
  {\ensuremath{\$}}
  {\ifthenelse{\equal{#1}{<\$>\AgdaUnderscore{}}}
  {\fmap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<\$>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\fmap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{\AgdaUnderscore{}<*>\AgdaUnderscore{}}}
  {\AgdaUnderscore{}\ap\AgdaUnderscore{}}
  {\ifthenelse{\equal{#1}{<*>}}
  {\ap}
  {#2}}}}}}}}}}}}}}}}}

\usepackage{graphicx}
\graphicspath{{images/}}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric,arrows,fit,matrix,positioning}
\tikzset
{
  treenode/.style = {align=center, anchor=center}
}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}%
\fancyhead[LO,RE]{\thepage}
\fancyhead[RO]{\rightmark}
\fancyhead[LE]{\leftmark}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.0pt}

% Chapter pages
\fancypagestyle{plain}{%
  \fancyhf{}%
  \fancyhead[LO,RE]{\thepage}
  \renewcommand{\headrulewidth}{0.0pt}%
  \renewcommand{\footrulewidth}{0.0pt}%
}

\usepackage{minted}

\usepackage[style=alphabetic,backend=biber]{biblatex}
\addbibresource{thesis.bib}
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}

\title{
  {\huge\textbf{Implementing a library for scoped algebraic effects in Agda}}\\
  {\large HTWK Leipzig}
}
\author{
  {Jonas Höfer}\\
  {Informatik}\\
  {69555}
}
\date{2020}

\begin{document}
\maketitle
\begin{abstract}
\end{abstract}

\tableofcontents

\chapter{Introduction}

Algebraic effects where first introduced by Plotkin and
Powers~\cite{DBLP:journals/acs/PlotkinP03} as an alternative, educational
representation for algebraic computational effects.
Effect handlers were introduced by Plotkin and
Pretnar~\cite{DBLP:conf/esop/PlotkinP09} as a generalization of exception
handlers.
They allow modelling non-algebraic effects and are used in conjunction with
algebraic effects~\cite{DBLP:journals/corr/PlotkinP13}.
Together they form a theoretical well understood representation for a large
class of computational effects.

Algebraic effects and handlers have a wide field of applications e.g. in
programming as a less boiler plate intensive alternative to monad transformers,
as well as to simulate programming semantics in proof
assistants~\cite{DBLP:journals/programming/DylusCT19,DBLP:conf/haskell/ChristiansenDB19}.

Wu et al. noticed a lack of modularity when combining computational effects with
scoping operations~\cite{DBLP:conf/haskell/WuSH14}.
They introduced several solutions for the problem, by introducing new operations
and generalizing syntax to delimit scopes.


\section{Goals}

The goal of this thesis is the implementation of an effect library based on the
work by Wu et al.~\cite{DBLP:conf/haskell/WuSH14,DBLP:conf/lics/PirogSWJ18} in
the dependently typed, functional programming language
Agda~\cite{norell:thesis}.
To allow use as a proof assistant, Agda programs are subject to constraints not
present in other functional languages such as Haskell.
All Agda programs have to be total (and therefore terminate), all data types
have to be strictly positive and all universe levels have to be consistent.
These restrictions prevent a direct translation of Haskell code to Agda.

This thesis will explore multiple Haskell implementations of scoped effects and
study how well these translate to Agda.
Furthermore it will present a set of standard solutions for common problems,
arising during the implementation of the three approaches.

Agda's builtin theorem proving capabilities allow direct, machine checked
correctness proofs for the implemented library.
Alongside the implementation of scoped effects, the library should contain
proofs for common properties of these effects.
Furthermore, the library itself can be used to simulate semantics of other
programming languages, such as Curry's call-time choice, and allow verification
of equivalent programs written in these languages in Agda.
To allow the latter, these library should be able to represent deep effects i.e.
data structures with effectful components.


\section{Structure}

Chapter \ref{chapter:preliminaries} contains short introductions to Agda and
dependent types, Curry and its call-time choice semantics (which are a central
example for a scoped effect throughout the thesis) and algebraic effects.

Chapter \ref{chapter:first-order} and \ref{chapter:higher-order} explore the two
approached based on ``Effect Handlers in Scope'' by Wu et
al.~\cite{DBLP:conf/haskell/WuSH14}.
The former of the two approaches was already partially explored by
Bunkeburg~\cite{bunkenburg2019modeling} in Coq and can also be implemented
easily in Agda.
The latter of the two approaches tries to fix some inherent problems of the
first one, but sadly cannot fully be implemented in Agda due to some inherent
problems with universe consistency.

Chapter \ref{chapter:scoped-algebras} describes an implementation of a novel
representation for scoped effects by Piróg
et~al.~\cite{DBLP:conf/lics/PirogSWJ18} which also fixes the problems of the
first approach, while avoiding the universe inconsistencies of the second one.
Furthermore, the implementation explores some ideas to modularize the exemplary
Haskell implementation by Piróg et al.


\chapter{Preliminaries}
\label{chapter:preliminaries}
\input{Preliminaries}

\chapter{First Order}
\label{chapter:first-order}
\input{FirstOrder}

\chapter{Higher Order Syntax}
\label{chapter:higher-order}
\input{HigherOrder}

\chapter{Scoped Algebras}
\label{chapter:scoped-algebras}
\input{ScopedAlgebras}

\chapter{Conclusion}
\section{Summary}
\section{Related Work}

\printbibliography

\end{document}
