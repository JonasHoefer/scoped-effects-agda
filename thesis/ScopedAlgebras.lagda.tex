\begin{code}[hide]
module ScopedAlgebras where

open import Function using (id; _∘_; _$_; const)
open import Level using (Level)

open import Category.Monad using (RawMonad)
open        RawMonad ⦃...⦄ renaming (_⊛_ to _<*>_)

open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Product using (Σ-syntax; _,_) renaming (proj₁ to π₁; proj₂ to π₂)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.Nat using (ℕ; suc; _+_)
open import Data.Product using (_×_; _,_)
open import Data.Sum using (_⊎_; inj₁; inj₂; [_,_])
open import Data.Empty using (⊥)
open import Data.List using (List; _∷_; []; _++_; foldr) renaming (map to mapᴸ)
open import Data.List.Relation.Unary.Any using (Any; here; there) renaming (map to map∈)
open import Data.Unit using (⊤; tt)

import Relation.Binary.PropositionalEquality as Eq
open   Eq using (_≡_; refl; cong; sym; trans)
open   Eq.≡-Reasoning using (_≡⟨⟩_; begin_; _∎; step-≡)

postulate
  extensionality : ∀ {ℓ ℓ′ : Level} {A : Set ℓ} {B : A → Set ℓ′} {f g : (x : A) → B x}
      → (∀ (x : A) → f x ≡ g x) → f ≡ g
\end{code}

\section{The Monad $E$}

Piróg et al. describe a monad, which is suited for modelling operations with
scopes~\cite{DBLP:conf/lics/PirogSWJ18}.
The monad is the result of rewriting a slightly modified version of the monad
from ``Effect Handlers in Scope'' i.e. the monad used in chapter
\ref{chapter:higher-order}.
They separate the signature into one describing effects with scopes $\Gamma$ and
one describing the algebraic effects $\Sigma$.
The monad $E$ can be described as the fixpoint of the following equation, where
the coend (the integral sign) denotes an existential types.

\[
  EA \cong A + \Sigma{}(EA) + \int^{X\in\mathscr{C}} \Gamma{}(EX) \times (EA)^X
\]
This representation looks appropriate considering our earlier definition.
An element of the monad is either a value of $A$, an operation without scopes,
i.e. a functor applied to \texttt{Free F A} or an operation with scopes.
Operations with scopes (e.g. \texttt{catch}) always quantified over some type to
store subprograms over the same signature but with different local result type.
Furthermore they provided a continuation, which transformed values of the
internal result type to the result type of the whole program.
[GAMMA]
The following Agda data type represents the above monad.

\begin{code}[hide]
record Container : Set₁ where
  constructor _▷_
  field
    Shape : Set
    Pos : Shape → Set
open Container public

⟦_⟧ : ∀ {ℓ} → Container → Set ℓ → Set ℓ
⟦ S ▷ P ⟧ A = Σ[ s ∈ S ] (P s → A)

-- TODO: EXPLAIN!
map : {A B : Set} {C : Container} → (A → B) → ⟦ C ⟧ A → ⟦ C ⟧ B
map f c = π₁ c , f ∘ π₂ c
{-# INLINE map #-}

_⊕_ : Container → Container → Container
(S₁ ▷ P₁) ⊕ (S₂ ▷ P₂) = (S₁ ⊎ S₂) ▷ [ P₁ , P₂ ]

Void : Container
Void = ⊥ ▷ λ()

sum : List Container → Container
sum = foldr _⊕_ Void

\end{code}
\begin{code}
data ProgE (Σ Γ : Container) (A : Set) : Set₁ where
  var  : A → ProgE Σ Γ A
  op   : ⟦ Σ ⟧ (ProgE Σ Γ A) → ProgE Σ Γ A
  scp  : {X : Set} → ⟦ Γ ⟧ (ProgE Σ Γ X) → (X → ProgE Σ Γ A) → ProgE Σ Γ A
\end{code}
Notice again that this definition requires $X$ to be a smaller type than
\AgdaDatatype{E} i.e. it's not sufficient to model deep effects as explained in
chapter \ref{chapter:higher-order}.
Piróg et al. also not size issues with this definition.

Piróg et al. rewrite this definition using a left Kan extension and derive the
following equivalent monad without the existential type.

\[
  EA \cong A + \Sigma{}(EA) + \Gamma{}(E(EA))
\]
An equivalent monad without the existential type is a promising candidate for
modelling deep effects in Agda, because it avoids the size issues.

\section{The \texttt{Prog} Monad}

In this section we will define the central monad for this approach.
Because signatures are split into effects with and without scopes we will define
effects as pairs of functors and therefore \AgdaDatatype{Container}s.

\begin{code}
record Effect : Set₁ where
  field
    Ops Scps : Container
open Effect public
\end{code}
The functions \AgdaFunction{ops} and \AgdaFunction{scps} combine the
corresponding signatures of a \AgdaDatatype{List} of \AgdaDatatype{Effect}s.

\begin{code}
ops scps : List Effect → Container
ops   = sum ∘ mapᴸ Ops
scps  = sum ∘ mapᴸ Scps
\end{code}
Using these helper functions we can define a modular version of the monad by
Piróg et al~\cite{DBLP:conf/lics/PirogSWJ18}.
It's equivalent to the fixpoint and the Haskell definition from the paper
(assuming that signatures are given by strictly positive functors).

% TODO: Piróg et al. define algrabs in terms of antoher moand and proof
% equvialence, but we cannot follow their defintion due to termination problems
% => Alternative folds
\begin{code}
data Prog (effs : List Effect) (A : Set) : Set where
  var  :  A                                         → Prog effs A
  op   :  ⟦ ops  effs  ⟧ (Prog effs A)              → Prog effs A
  scp  :  ⟦ scps effs  ⟧ (Prog effs (Prog effs A))  → Prog effs A
\end{code}
Piróg et al. also derive algebras for the above monad, which correctly model
scoped effects.
To implement their recursion scheme we have to define \AgdaFunction{>>=} for 
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.
Notice that \AgdaDatatype{Prog} is a truly nested or non-regular data
type~\cite{DBLP:conf/mpc/BirdM98}.

Defining recursive functions for these data types is more complicated.
The ``direct'' implementations of \AgdaFunction{fmap} and \AgdaFunction{>>=}
do not obviously terminate.
Augmenting \AgdaDatatype{Prog} with size annotations leads to problems when
proving the monad laws\footnote{As in chapter \ref{chapter:higher-order} the
  monad laws only hold for size $\infty$, but working with size $\infty$ in
  proofs leads to termination problems.
  The \AgdaInductiveConstructor{scp} constructor can produce an arbitrary number
  of \AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layers.
  This forces us to use our induction hypothesis on not obviously smaller terms,
  but the size annotation is assumed to be $\infty$.}.
Instead we will define a generic \texttt{fold}, which we can reuse for all
functions traversing elements of
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.


\subsection{Folds for Nested Data Types}

Defining recursion schemes for complex recursive data types is a common problem.
Fu and Selinger demonstrate a general construction of a \texttt{fold}s for
nested data types in Agda~\cite{DBLP:journals/corr/abs-1806-05230}.
Following their construction and adapting it to arbitrary branching trees leads
to a sufficiently strong \texttt{fold} to define all important functions for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.

\paragraph{Index Type} The first part of the construction by Fu and Selinger is
to define the correct index type for the data structure.
The index type describes the recursive structure of the data type i.e. how the
type variables at each level are instantiated.
For complex mutual recursive data types the index type takes the form of a
branching tree.
For \AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}
the one type variable is either instantiated with the value type $A$
(\AgdaInductiveConstructor{pure}) or some number of
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layers applied to
the current type variable (\AgdaInductiveConstructor{op},
\AgdaInductiveConstructor{scp}).
Our index type therefore just counts the number of
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layers.
Natural numbers are sufficient.

Next Fu and Selinger define a type level function, which translates a value of
the index type to its corresponding type.
For
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}
this function just applies \AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}
$n$ times to \AgdaArgument{A}.
The operator \AgdaFunction{\_\textasciicircum\_} applies a function $n$-times to
a given argument \AgdaArgument{x} i.e. it represents $n$-fold function
application, usually denoted $f^n(x)$.

\begin{code}[hide]
infixl 10 _^_
variable
  A B E S : Set
  effs : List Effect
\end{code}
\begin{code}
_^_ : ∀ {ℓ} {C : Set ℓ} → (C → C) → ℕ → C → C
(f ^ 0)      x = x
(f ^ suc n)  x = f ((f ^ n) x)
\end{code}

\paragraph{Recursion Scheme} Next we will define \AgdaFunction{fold} for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.
The fold produces an arbitrary $\mathbb{N}$ indexed value.
The type family $P$ determines the result type at each index.
The \AgdaFunction{fold} produces a value of type $P\;n$ for a given value of
type
$($\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaFunction{\textasciicircum}\AgdaSpace{}\AgdaArgument{n}$)$\AgdaSpace{}\AgdaArgument{A}.
Furthermore the \texttt{fold} takes functions for processing substructures.
As usual, the arguments of these function correspond to those of the
constructors they processes with recursive occurrences of the type itself already
processed.
The cases are obtained by pattern matching on the index type and the value of
type
$($\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaFunction{\textasciicircum}\AgdaSpace{}\AgdaArgument{n}$)$\AgdaSpace{}\AgdaArgument{A}
i.e. the value of the type depending on the index.

\begin{code}
fold : (P : ℕ → Set) → ∀ n →
  (A                                           → P 0        )  →
  (∀ {n} → P n                                 → P (suc n)  )  →
  (∀ {n} → ⟦ ops   effs  ⟧  (P (suc n))        → P (suc n)  )  →
  (∀ {n} → ⟦ scps  effs  ⟧  (P (suc (suc n)))  → P (suc n)  )  →
  (Prog effs ^ n) A → P n
fold P 0        a v o s x         = a  x
fold P (suc n)  a v o s (var  x)  = v  (       fold P n              a v o s   x)
fold P (suc n)  a v o s (op   x)  = o  (map (  fold P (suc n)        a v o s)  x)
fold P (suc n)  a v o s (scp  x)  = s  (map (  fold P (suc (suc n))  a v o s)  x)
\end{code}
Notices that for the \AgdaInductiveConstructor{op} and
\AgdaInductiveConstructor{spc} constructors the recursive occurrences and
potential additional values are determined by the \AgdaDatatype{Container}.
The functions therefore processor arbitrary \AgdaDatatype{Container} extensions,
which contain solutions for the corresponding index.
When implementing those two cases we cannot apply \AgdaFunction{fold} directly
to recursive occurrences, because those depend on the choice of
\AgdaDatatype{Container}.
\AgdaFunction{map} for \AgdaDatatype{Container}s exactly captures the correct
behavior.

\paragraph{Example}
Using \AgdaFunction{fold} we can implement \AgdaFunction{>>=} for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.
The continuations \AgdaArgument{k} passed to \AgdaFunction{>>=} should just
effect the inner most layer.
Intuitively, when using bind an a value constructed with
\AgdaInductiveConstructor{scp} we traverse the outer layer and call bind on the
inner one recursively.
To implement \AgdaFunction{>>=} we fold over the first argument.
We could fix the arbitrary $n$ to be $1$, but defining a version generic in $n$
is useful for later proofs.
The \AgdaDatatype{ℕ} indexed type \AgdaDatatype{bind-P} defines the type for the
intermediate result at every layer.

\begin{code}
bind-P : ∀ A B effs → ℕ → Set
bind-P A B effs 0       = A
bind-P A B effs (suc n) = Prog effs ^ (suc n) $ B
\end{code}
\bind{} corresponds to variable substitution i.e. it replaces the values stored
in \AgdaInductiveConstructor{var} leafs with subtrees generated from these
values.
Calling $k$ on a program with zero layers (a value of type \AgdaArgument{A})
would produce a program with one layer.
Therefore, \bind{} can only be called on programs with at least one layer.
The lowest layer is extended with the result of \AgdaArgument{k}.
For all numbers greater than zero we produce a program with the same structure
but a different value type.
For layer zero (i.e. values) we could either produce a value of type 
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{B}
or leave the value of type \AgdaArgument{A} unchanged.
In both cases we have to handle the lowest \AgdaInductiveConstructor{var}
constructors differently.

\begin{code}
bind : ∀ n → (Prog effs ^ suc n) A → (A → Prog effs B) →
  (Prog effs ^ suc n) B
bind {effs} {A} {B} n ma k = fold (bind-P A B effs) (suc n) id (λ where
    {0}      x → k x
    {suc n}  x → var x
  ) op scp ma
\end{code}
We left the values unchanged, therefore the \AgdaInductiveConstructor{var}
constructor at layer zero has to produce value of type 
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{B}
by calling \AgdaArgument{k}.
In all other cases we replace each constructor with itself to leave these parts
unchanged.

Using \bind{} for a program with one layer and \AgdaInductiveConstructor{var} as
\AgdaFunction{return} we can define a monad instance for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}.
In contrast to Haskell this automatically defines a functor and an applicative
instances, because these can be defined in terms of \bind{} and
\AgdaFunction{return}\footnote{We automatically obtain the functions
  \AgdaFunction{<\$>}, \AgdaFunction{<*>}, \AgdaFunction{pure} and
  \AgdaFunction{>>}. }.
\begin{code}
instance
  Prog-RawMonad : RawMonad (Prog effs)
  Prog-RawMonad = record { return = var ; _>>=_ = bind 0 }
\end{code}
The record (which is used as a type class) is part of the Agda standard library.
It is named \AgdaDatatype{RawMonad}, because it does not enforce the monad laws.
We will prove the laws in section \ref{subsec:scoped-algebra:monad-laws} using
a technique from section \ref{subsec:scoped-algebra:ind}.


\subsection{Induction Schemes for Nested Data Types}
\label{subsec:scoped-algebra:ind}

\begin{code}
ind : (P : (n : ℕ) → (Prog effs ^ n) A → Set) → ∀ n →
  (∀ {x}        → A                                                    → P 0 x                     )  →
  (∀ {n x}      → P n x                                                → P (suc n) (var x)         )  →
  (∀ {n} s {κ}  → ((p : Pos (ops   effs) s) → P (suc n)        (κ p))  → P (suc n) (op   (s , κ))  )  →
  (∀ {n} s {κ}  → ((p : Pos (scps  effs) s) → P (suc (suc n))  (κ p))  → P (suc n) (scp  (s , κ))  )  →
  (x : (Prog effs ^ n) A) → P n x
ind P 0       a v o s x               = a x
ind P (suc n) a v o s (var x)         = v    (ind P n              a v o s x)
ind P (suc n) a v o s (op   (c , κ))  = o c  (ind P (suc n)        a v o s ∘ κ)
ind P (suc n) a v o s (scp  (c , κ))  = s c  (ind P (suc (suc n))  a v o s ∘ κ)
\end{code}


\subsection{Proving the Monad Laws}
\label{subsec:scoped-algebra:monad-laws}

\paragraph{Left Identity}
First we will prove the left identitiy law.
Because the value passed \AgdaFunction{>>=} constructed using
\AgdaFunction{return} i.e. \AgdaInductiveConstructor{var} both sides of the
equality can be directly evaluated to
\AgdaArgument{k}\AgdaSpace{}\AgdaArgument{a}.

\begin{code}
bind-identˡ : ∀ {A B : Set} {a} {k : A → Prog effs B} →
  (return a >>= k) ≡ k a
bind-identˡ = refl
\end{code}

\paragraph{Right Identity}
When proving the right identity the value passed to \AgdaFunction{>>=} can be an
arbitrarily complex program. Therefore the proposition is not ``obvious'' as it
was the case with \AgdaFunction{bind-identˡ}.

\begin{AgdaAlign}
\begin{code}
bind-identʳ : {A : Set} (ma : Prog effs A) →
  (ma >>= return) ≡ ma
\end{code}
\AgdaFunction{>>=} is recursive in its first argument, therefore we will prove
the proposition by induction on \AgdaArgument{ma}.
To use the induction scheme we have to define a proposition for every layer.
Since \AgdaFunction{>>=} does not change values we simply produce a value of
type \AgdaDatatype{⊤} at layer zero.
For all other we proof the proposition for the appropriate
\AgdaFunction{bind} i.e. the one called by \AgdaFunction{fold} to handle a value
for the given \AgdaArgument{n}.

\begin{code}
bind-identʳ {effs} {A} = ind (λ{ 0 _ → ⊤ ; (suc n) p → bind n p var ≡ p })
\end{code}
We call the induction scheme with the given value with one layer, therefore the
initial \AgdaArgument{n} is \AgdaNumber{1}.
The ``proof'' for values can be inferred, because for each value it's just a
value of the unit type.

\begin{code}
  1 _
\end{code}
To proof that the proposition holds for values constructed using
\AgdaInductiveConstructor{var} we have to case split on the number of layers
\AgdaArgument{n}.
For \AgdaNumber{0} we have to proof that
\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x} is equal to itself,
because \AgdaFunction{>>=} leaves values unchanged.
This proof forms the basis for our induction.

For the second case we are given a program \AgdaArgument{x} with
\AgdaInductiveConstructor{suc}\AgdaSpace{}\AgdaArgument{n} layers and an
induction hypothesis \AgdaArgument{IH} that the proposition holds for a call to
\AgdaFunction{bind}\AgdaSpace{}\AgdaArgument{n}.
We have to prove that the proposition holds for
\AgdaFunction{bind}\AgdaSpace{}$($\AgdaInductiveConstructor{suc}\AgdaSpace\AgdaArgument{n}$)$
and the new program \AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x}.
By applying the \AgdaFunction{>>=} rule for \AgdaInductiveConstructor{var} (for
\AgdaArgument{n} greater than zero) we can move \AgdaInductiveConstructor{var}
to the outside.
The new proposition is
\AgdaInductiveConstructor{var}\AgdaSpace{}$($\AgdaFunction{bind}\AgdaSpace{}\AgdaArgument{n}$)$\AgdaSpace{}\AgdaDatatype{≡}\AgdaSpace{}\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x}.
This proposition is equal to the induction hypothesis with
\AgdaInductiveConstructor{var} applied to both sides.
Therefore we can proof it using congruence.

\begin{code}
  (λ{ {0} (tt) → refl ; {suc n} IH → cong var IH })
\end{code}
The proofs for the \AgdaInductiveConstructor{op} and
\AgdaInductiveConstructor{scp} are identical and similar to the
\AgdaInductiveConstructor{var} case. For each shape \AgdaArgument{s} we are
given a proof for each position of the given shape.
We have to proof that the proposition holds for a new program constructed using
either \AgdaInductiveConstructor{op} or \AgdaInductiveConstructor{scp}.
For both constrcutors \AgdaFunction{bind}\AgdaSpace{}\AgdaArgument{n} calls
itself recusrivly on the all contained values i.e. the results of the position
function.
Using congruence we can simplify the equality to the equality of the position
functions.
By invoking the axiom of extensionality we can prove the equality for each
position.
This equality is exactly the one given by the induction hypothesis.

\begin{code}
  (λ s IH → cong (op   ∘ (s ,_)) (extensionality IH))
  (λ s IH → cong (scp  ∘ (s ,_)) (extensionality IH))
\end{code}
\end{AgdaAlign}

\paragraph{Associativity}
The proof for associativity follows the same pattern as the one for the right
identity.
\AgdaFunction{>>=} is defined by recursion on its first argument.
We therefore proof the proposition by induction on \AgdaArgument{ma}.
In all cases the left-hand side reduces to the induction hypothesis in the same
manner as before.
Therefore these cases look identical.

\begin{code}
bind-assoc : ∀ {A B C}
  (f : A → Prog effs B) (g : B → Prog effs C) (ma : Prog effs A) →
  (ma >>= f >>= g) ≡ (ma >>= λ a → f a >>= g)
bind-assoc f g = ind
  (λ where
    0 p        → ⊤
    (suc n) p  → bind n (bind n p f) g ≡ bind n p λ a → bind 0 (f a) g
  ) 1 _
  (λ{ {0} _ → refl ; {suc n} IH → cong var IH})
  (λ s IH → cong (op   ∘ (s ,_)) (extensionality IH))
  (λ s IH → cong (scp  ∘ (s ,_)) (extensionality IH))
\end{code}

\paragraph{Functor and Applicative Laws}
The monad laws imply the functor and applicative laws.
We can proof them without using explicit induction by rewriting equations
involving \AgdaFunction{>>=} using the above law.
These proofs are simpler than the ones explicitly involving the definition of
\AgdaFunction{>>=} using \AgdaFunction{fold}.
We can write them using the chain reasoning operators as described by
Norell~\cite{norell:thesis}.

\begin{code}
fmap-id : ∀ {effs} {A B : Set} → (ma : Prog effs A) → (id <$> ma) ≡ ma
fmap-id ma = begin
  (id <$> ma)                ≡⟨⟩ -- definition of <$>
  (ma >>= λ a → var (id a))  ≡⟨⟩ -- definition of id and η-conversion
  (ma >>= var)               ≡⟨ bind-identʳ ma ⟩
  ma                         ∎
\end{code}


\section{Combining Effects}

\begin{code}
variable
  C  : Container
  Cs : List Container
  e : Effect

infix 3 _∈_
_∈_ : ∀ {a} {A : Set a} → A → List A → Set a
x ∈ xs = Any (_≡_ x) xs

instance
  ∈-head : ∀ {a} {A : Set a} {x : A} {xs} → x ∈ x ∷ xs
  ∈-head = here refl

  ∈-tail : ∀ {a} {A : Set a} {x y : A} {xs} → ⦃ x ∈ xs ⦄ → x ∈ y ∷ xs
  ∈-tail ⦃ p ⦄ = there p

inj : C ∈ Cs → ⟦ C ⟧ A → ⟦ sum Cs ⟧ A
inj (here refl) (s , κ) = inj₁ s , κ
inj (there p)   q       with inj p q
... | s , κ = inj₂ s , κ

prj : C ∈ Cs → ⟦ sum Cs ⟧ A → Maybe (⟦ C ⟧ A)
prj (here refl) (inj₁ s , κ) = just (s , κ)
prj (here refl) (inj₂ s , κ) = nothing
prj (there p)   (inj₁ s , κ) = nothing
prj (there p)   (inj₂ s , κ) = prj p (s , κ)

opsInj : (e ∈ effs) → Ops e ∈ mapᴸ Ops effs
opsInj (here refl) = here refl
opsInj (there p)   = there (opsInj p)

scpsInj : (e ∈ effs) → Scps e ∈ mapᴸ Scps effs
scpsInj (here refl) = here refl
scpsInj (there p)   = there (scpsInj p)

Op : ⦃ e ∈ effs ⦄ → ⟦ Ops e ⟧ (Prog effs A) → Prog effs A
Op ⦃ p ⦄ = op ∘ inj (opsInj p)

Scp : ⦃ e ∈ effs ⦄ → ⟦ Scps e ⟧ (Prog effs (Prog effs A)) → Prog effs A
Scp ⦃ p ⦄ = scp ∘ inj (scpsInj p)
\end{code}


\section{Nondet}

\begin{code}
data Choiceˢ  : Set where ⁇ˢ failˢ  : Choiceˢ
data Onceˢ    : Set where onceˢ     : Onceˢ

Nondet : Effect
Ops   Nondet = Choiceˢ  ▷ λ{ ⁇ˢ → Bool ; failˢ → ⊥ }
Scps  Nondet = Onceˢ    ▷ const ⊤
\end{code}

\subsection{As Scoped Algebra}

\begin{code}
record ScopedAlgebra (E : Effect) (C : ℕ → Set) : Set where
  constructor ⟨_,_,_⟩
  field
    p : ∀ {n} → C n                      → C (1 + n)
    d : ∀ {n} → ⟦ Scps  E ⟧ (C (2 + n))  → C (1 + n)
    a : ∀ {n} → ⟦ Ops   E ⟧ (C (1 + n))  → C (1 + n)
open ScopedAlgebra

foldᴾ : ∀ {C : Set → ℕ → Set} → ScopedAlgebra e (C A) → Prog (e ∷ []) (C A 0) → C A 1
foldᴾ {C = C} ⟨ p , d , a ⟩ = fold (C _) 1 id p
  (λ{ (inj₁ s , κ) → a (s , κ) }) λ{ (inj₁ s , κ) → d (s , κ) }

NondetAlg : ScopedAlgebra Nondet (λ i → List ^ i $ A)
p NondetAlg              = _∷ []
a NondetAlg (⁇ˢ    , κ)  = κ true ++ κ false
a NondetAlg (failˢ , κ)  = []
d NondetAlg (onceˢ , κ)  with κ tt
... | []     = []
... | x ∷ _  = x

runNondetᴾ : Prog (Nondet ∷ []) A → List A
runNondetᴾ = foldᴾ {C = λ A i → List ^ i $ A} NondetAlg
\end{code}


\subsection{As Modular Handler}

\begin{code}
pattern Other s κ  = (inj₂ s , κ)
pattern Choice κ   = (inj₁ ⁇ˢ , κ)
pattern Fail       = (inj₁ failˢ , _)
pattern Once κ     = (inj₁ onceˢ , κ)

runNondet : Prog (Nondet ∷ effs) A → Prog effs (List A)
runNondet {effs} {A} = fold (λ i → (Prog effs ∘ List) ^ i $ A) 1 id
  (pure ∘ (_∷ []))
  (λ where
    (Choice κ)   → ⦇ κ true ++ κ false ⦈
    Fail         → pure []
    (Other s κ)  → op (s , κ)
  ) λ where
    (Once κ)    → κ tt >>= λ where
      []       → var []
      (x ∷ _)  → x
    (Other s κ) → scp (s , λ p → hdl <$> κ p)
  where
    hdl : ∀ {A} → List (Prog effs (List A)) → Prog effs (List A)
    hdl []          = pure []
    hdl (mx ∷ mxs)  = ⦇ mx ++ hdl mxs ⦈
\end{code}

\section{Exceptions}

\begin{code}
data Throwˢ (E : Set)  : Set where throwˢ : (e : E) → Throwˢ E
data Catchˢ            : Set where catchˢ : Catchˢ
data Catchᵖ (E : Set)  : Set where
  mainᵖ    : Catchᵖ E
  handleᵖ  : (e : E) → Catchᵖ E

Exc : Set → Effect
Ops   (Exc E) = Throwˢ E  ▷ const ⊥
Scps  (Exc E) = Catchˢ    ▷ const (Catchᵖ E)

pattern Throw  e = (inj₁ (throwˢ e) , _)
pattern Catch  κ = (inj₁ catchˢ , κ)

runExc : Prog (Exc E ∷ effs) A → Prog effs (E ⊎ A)
runExc {E} {effs} {A} = fold (λ i → (Prog effs ∘ (E ⊎_)) ^ i $ A) 1 id
  (pure ∘ inj₂)
  ( λ where
    (Throw e)    → pure (inj₁ e)
    (Other s κ)  → op (s , κ)
  ) λ where
    (Catch κ) → κ mainᵖ >>= λ where
      (inj₂ x)  → x
      (inj₁ e)  → κ (handleᵖ e) >>= λ where
        (inj₁ e)  → pure (inj₁ e)
        (inj₂ x)  → x
    (Other s κ) → scp (s , λ p → [ pure ∘ inj₁ , id ] <$> κ p)

throw : ⦃ Exc E ∈ effs ⦄ → E → Prog effs A
throw e = Op (throwˢ e , λ())

_catch_ : ⦃ Exc E ∈ effs ⦄ → Prog effs A → (E → Prog effs A) → Prog effs A
p catch h = Scp $ catchˢ , λ where
  mainᵖ        → pure <$> p
  (handleᵖ e)  → pure <$> h e
\end{code}


\section{State}

\begin{code}
data Stateˢ (S : Set) : Set where
  putˢ : (s : S) → Stateˢ S
  getˢ : Stateˢ S

State : Set → Effect
Ops   (State S) = (Stateˢ S) ▷ λ{ (putˢ s) → ⊤ ; getˢ → S }
Scps  (State S) = Void

pattern Get κ     = (inj₁ getˢ , κ)
pattern Put s₁ κ  = (inj₁ (putˢ s₁) , κ)

eval : A × (A → B) → B
eval (a , f) = f a

runState : Prog (State S ∷ effs) A → S → Prog effs (S × A)
runState {S} {effs} {A} = fold (λ i → (λ X → S → Prog effs (S × X)) ^ i $ A) 1 id
  (λ x s₀ → pure (s₀ , x))
  (λ where
    (Put s₁ κ) _    → κ tt s₁
    (Get κ) s₀      → κ s₀ s₀
    (Other s κ) s₀  → op (s , λ p → κ p s₀)
  ) λ where
    (Other s κ) s₀ → scp (s , λ p → eval <$> κ p s₀)

get : ⦃ State S ∈ effs ⦄ → Prog effs S
get = Op (getˢ , pure)

put : ⦃ State S ∈ effs ⦄ → S → Prog effs ⊤
put s = Op (putˢ s , pure)
\end{code}


\section{Share}

