\begin{code}[hide]
{-# OPTIONS --overlapping-instances #-}

module ScopedAlgebras where

open import Size using (Size; ↑_)
open import Function using (id; _∘_; _$_; const; case_of_)
open import Level using (Level)

open import Category.Monad using (RawMonad)
open        RawMonad ⦃...⦄ renaming (_⊛_ to _<*>_)

open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Product using (Σ-syntax; _,_) renaming (proj₁ to π₁; proj₂ to π₂)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.Nat using (ℕ; suc; _+_)
open import Data.Nat.Properties using (<-strictTotalOrder)
open import Data.Product using (_×_; _,_)
open import Data.Product.Relation.Binary.Lex.Strict using (×-strictTotalOrder)
open import Data.Sum using (_⊎_; inj₁; inj₂; [_,_])
open import Data.Empty using (⊥)
open import Data.List using (List; _∷_; []; _++_; foldr) renaming (map to mapᴸ)
open import Data.List.Relation.Unary.Any using (Any; here; there) renaming (map to map∈)
open import Data.Unit using (⊤; tt)

order = ×-strictTotalOrder (×-strictTotalOrder <-strictTotalOrder <-strictTotalOrder) <-strictTotalOrder
open import Data.Tree.AVL.Map order using (Map; empty; insert; lookup)

import Relation.Binary.PropositionalEquality as Eq
open   Eq using (_≡_; refl; cong; sym; trans)
open   Eq.≡-Reasoning using (_≡⟨⟩_; begin_; _∎; step-≡)

postulate
  extensionality : ∀ {ℓ ℓ′ : Level} {A : Set ℓ} {B : A → Set ℓ′} {f g : (x : A) → B x}
      → (∀ (x : A) → f x ≡ g x) → f ≡ g
\end{code}

Due to the deep-rooted problem with the higher order approach from chapter
\ref{chapter:higher-order} it seemed reasonable to search for another
formulation of scoped effects, which does not rely on existential types.
Piróg et al.~\cite{DBLP:conf/lics/PirogSWJ18} presented a novel formulation for
scoped operations and their algebras, which fulfils this requirement.
Their approach does not describe the combination of multiple effects, but due to
the different structure the approach seemed worth exploring nonetheless.

This chapter transfers the basic implementation from Piróg et al. to Agda,
derives a different implementation of \AgdaFunction{fold}, based on the work by
Fu and Selinger~\cite{DBLP:journals/corr/abs-1806-05230}, for their monad to
aid termination checking and presents an idea for modularisation of their
algebras.


\section{The Monad $E$}

Piróg et al. describe a monad, which is suited for modelling operations with
scopes~\cite{DBLP:conf/lics/PirogSWJ18}.
The monad is the result of rewriting a slightly modified version of the monad
from ``Effect Handlers in Scope'' i.e. the monad used in chapter
\ref{chapter:higher-order}.
They separate the signature into one describing effects with scopes $\Gamma$ and
one describing the algebraic effects $\Sigma$.
The monad $E$ can be described as the fixpoint of the following equation, where
the coend (the integral sign) denotes an existential types.

\[
  EA \cong A + \Sigma{}(EA) + \int^{X\in\mathscr{C}} \Gamma{}(EX) \times (EA)^X
\]
This representation looks appropriate considering our earlier definition.
An element of the monad is either a value of $A$, an operation without scopes,
i.e. a functor applied to \texttt{Free F A} or an operation with scopes.
Operations with scopes (e.g. \texttt{catch}) always quantified over some type to
store subprograms over the same signature but with different local result type.
Furthermore they provided a continuation, which transformed values of the
internal result type to the result type of the whole program.
[GAMMA]
The following Agda data type represents the above monad.

\begin{code}[hide]
record Container : Set₁ where
  constructor _▷_
  field
    Shape : Set
    Pos : Shape → Set
open Container public

_↝_ : Set → Set → Container
S ↝ P = S ▷ const P

⟦_⟧ : ∀ {ℓ} → Container → Set ℓ → Set ℓ
⟦ S ▷ P ⟧ A = Σ[ s ∈ S ] (P s → A)

-- TODO: EXPLAIN!
map : {A B : Set} {C : Container} → (A → B) → ⟦ C ⟧ A → ⟦ C ⟧ B
map f c = π₁ c , f ∘ π₂ c
{-# INLINE map #-}

_⊕_ : Container → Container → Container
(S₁ ▷ P₁) ⊕ (S₂ ▷ P₂) = (S₁ ⊎ S₂) ▷ [ P₁ , P₂ ]

Void : Container
Void = ⊥ ▷ λ()

sum : List Container → Container
sum = foldr _⊕_ Void

\end{code}
\begin{code}
data ProgE (Σ Γ : Container) (A : Set) : Set₁ where
  var  : A → ProgE Σ Γ A
  op   : ⟦ Σ ⟧ (ProgE Σ Γ A) → ProgE Σ Γ A
  scp  : {X : Set} → ⟦ Γ ⟧ (ProgE Σ Γ X) → (X → ProgE Σ Γ A) → ProgE Σ Γ A
\end{code}
Notice again that this definition requires $X$ to be a smaller type than
\AgdaDatatype{E} i.e. it's not sufficient to model deep effects as explained in
chapter \ref{chapter:higher-order}.
Piróg et al. also not size issues with this definition.

Piróg et al. rewrite this definition using a left Kan extension and derive the
following equivalent monad without the existential type.

\[
  EA \cong A + \Sigma{}(EA) + \Gamma{}(E(EA))
\]
An equivalent monad without the existential type is a promising candidate for
modelling deep effects in Agda, because it avoids the size issues.

The monad models scopes using the double $E$ layer.
The outer layer corresponds to the part of program in scope.
By evaluating it (i.e. the part of the program in scope) one obtains a value of
type $EA$, the rest of the program producing a result of type $A$.
This resulting program corresponds to the continuation in the higher order
approach, which was a function mapping from the the result of the scoped program
to the rest of the whole program.

\section{The \texttt{Prog} Monad}

In this section we will define the central monad for this approach.
Because signatures are split into effects with and without scopes we will define
effects as pairs of functors and therefore \AgdaDatatype{Container}s.

\begin{code}
record Effect : Set₁ where
  field
    Ops Scps : Container
open Effect public
\end{code}
The functions \AgdaFunction{ops} and \AgdaFunction{scps} combine the
corresponding signatures of a \AgdaDatatype{List} of \AgdaDatatype{Effect}s.

\begin{code}
ops scps : List Effect → Container
ops   = sum ∘ mapᴸ Ops
scps  = sum ∘ mapᴸ Scps
\end{code}
Using these helper functions we can define a modular version of the monad by
Piróg et al~\cite{DBLP:conf/lics/PirogSWJ18}.
It's equivalent to the fixpoint and the Haskell definition from the paper
(assuming that signatures are given by strictly positive functors).

% TODO: Piróg et al. define algrabs in terms of antoher moand and proof
% equvialence, but we cannot follow their defintion due to termination problems
% => Alternative folds
\begin{code}
data Prog (effs : List Effect) (A : Set) : Set where
  var  :  A                                         → Prog effs A
  op   :  ⟦ ops  effs  ⟧ (Prog effs A)              → Prog effs A
  scp  :  ⟦ scps effs  ⟧ (Prog effs (Prog effs A))  → Prog effs A
\end{code}
Piróg et al. also derive algebras for the above monad, which correctly model
scoped effects.
To implement their recursion scheme we have to define \AgdaFunction{>>=} for 
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.
Notice that \AgdaDatatype{Prog} is a truly nested or non-regular data
type~\cite{DBLP:conf/mpc/BirdM98}.

Defining recursive functions for these data types is more complicated.
The ``direct'' implementations of \AgdaFunction{fmap} and \AgdaFunction{>>=}
do not obviously terminate.
Augmenting \AgdaDatatype{Prog} with size annotations leads to problems when
proving the monad laws\footnote{As in chapter \ref{chapter:higher-order} the
  monad laws only hold for size $\infty$, but working with size $\infty$ in
  proofs leads to termination problems.
  The \AgdaInductiveConstructor{scp} constructor can produce an arbitrary number
  of \AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layers.
  This forces us to use our induction hypothesis on not obviously smaller terms,
  but the size annotation is assumed to be $\infty$.}.
Instead we will define a generic \AgdaFunction{fold}, which we can reuse for all
functions traversing elements of
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.


\subsection{Folds for Nested Data Types}
\label{scoped-algebra:fold}

Defining recursion schemes for complex recursive data types is a common problem.
Fu and Selinger demonstrate a general construction for \texttt{fold}s for nested
data types in Agda~\cite{DBLP:journals/corr/abs-1806-05230}.
Following their construction and adapting it to arbitrary branching trees leads
to a sufficiently strong \texttt{fold} to define all important functions for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.

\paragraph{Index Type} The first part of the construction by Fu and Selinger is
to define the correct index type for the data structure.
The index type describes the recursive structure of the data type i.e. how the
type variables at each level are instantiated.
For complex mutual recursive data types the index type takes the form of a
branching tree.
For \AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}
the one type variable is either instantiated with the value type $A$
(\AgdaInductiveConstructor{pure}) or some number of
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layers applied to
the current type variable (\AgdaInductiveConstructor{op},
\AgdaInductiveConstructor{scp}).
Our index type therefore just counts the number of
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layers.
Natural numbers are sufficient.

Next Fu and Selinger define a type level function, which translates a value of
the index type to its corresponding type.
For
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}
this function just applies \AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}
$n$ times to \AgdaArgument{A}.
The operator \AgdaFunction{\_\textasciicircum\_} applies a function $n$-times to
a given argument \AgdaArgument{x} i.e. it represents $n$-fold function
application, usually denoted $f^n(x)$.

\begin{code}[hide]
infixl 10 _^_
variable
  A B E S : Set
  effs : List Effect
\end{code}
\begin{code}
_^_ : ∀ {ℓ} {C : Set ℓ} → (C → C) → ℕ → C → C
(f ^ 0)      x = x
(f ^ suc n)  x = f ((f ^ n) x)
\end{code}

\paragraph{Recursion Scheme} Next we will define \AgdaFunction{fold} for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.
The fold produces an arbitrary $\mathbb{N}$ indexed value.
The type family $P$ determines the result type at each index.
The \AgdaFunction{fold} produces a value of type $P\;n$ for a given value of
type
$($\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaFunction{\textasciicircum}\AgdaSpace{}\AgdaArgument{n}$)$\AgdaSpace{}\AgdaArgument{A}.
Furthermore the \texttt{fold} takes functions for processing substructures.
As usual, the arguments of these function correspond to those of the
constructors they processes with recursive occurrences of the type itself already
processed.
The cases are obtained by pattern matching on the index type and the value of
type
$($\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaFunction{\textasciicircum}\AgdaSpace{}\AgdaArgument{n}$)$\AgdaSpace{}\AgdaArgument{A}
i.e. the value of the type depending on the index.

\begin{code}
fold : (P : ℕ → Set) → ∀ n →
  (A                                           → P 0        )  →
  (∀ {n} → P n                                 → P (suc n)  )  →
  (∀ {n} → ⟦ ops   effs  ⟧  (P (suc n))        → P (suc n)  )  →
  (∀ {n} → ⟦ scps  effs  ⟧  (P (suc (suc n)))  → P (suc n)  )  →
  (Prog effs ^ n) A → P n
fold P 0        a v o s x         = a  x
fold P (suc n)  a v o s (var  x)  = v  (       fold P n              a v o s   x)
fold P (suc n)  a v o s (op   x)  = o  (map (  fold P (suc n)        a v o s)  x)
fold P (suc n)  a v o s (scp  x)  = s  (map (  fold P (suc (suc n))  a v o s)  x)
\end{code}
Notices that for the \AgdaInductiveConstructor{op} and
\AgdaInductiveConstructor{spc} constructors the recursive occurrences and
potential additional values are determined by the \AgdaDatatype{Container}.
The functions therefore processor arbitrary \AgdaDatatype{Container} extensions,
which contain solutions for the corresponding index.
When implementing those two cases we cannot apply \AgdaFunction{fold} directly
to recursive occurrences, because those depend on the choice of
\AgdaDatatype{Container}.
\AgdaFunction{map} for \AgdaDatatype{Container}s exactly captures the correct
behavior.

The \AgdaFunction{fold} function, based on the approach by Fu and Selinger, is
similar to the one by Piróg et al.
Piróg et al. derived their \AgdaFunction{fold} by deriving algebras for a
second monad.
In ``Syntax and Semantics for Operations with
Scopes''~\cite{DBLP:conf/lics/PirogSWJ18} they show that the two monads are
equivalent and therefore transfer the \AgdaFunction{fold} from the
second monad to the one used in their Haskell implementation.
Following Fu and Selinger we derived essential the same \AgdaFunction{fold}
and implemented it directly i.e. without the use of \AgdaFunction{>>=}.

\paragraph{Example}
Using \AgdaFunction{fold} we can implement \AgdaFunction{>>=} for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.
The continuations \AgdaArgument{k} passed to \AgdaFunction{>>=} should just
effect the inner most layer.
Intuitively, when using bind an a value constructed with
\AgdaInductiveConstructor{scp} we traverse the outer layer and call bind on the
inner one recursively.
To implement \AgdaFunction{>>=} we fold over the first argument.
We could fix the arbitrary $n$ to be $1$, but defining a version generic in $n$
is useful for later proofs.
The \AgdaDatatype{ℕ} indexed type \AgdaDatatype{bind-P} defines the type for the
intermediate result at every layer.

\begin{code}
bind-P : ∀ A B effs → ℕ → Set
bind-P A B effs 0       = A
bind-P A B effs (suc n) = Prog effs ^ (suc n) $ B
\end{code}
\bind{} corresponds to variable substitution i.e. it replaces the values stored
in \AgdaInductiveConstructor{var} leafs with subtrees generated from these
values.
Calling $k$ on a program with zero layers (a value of type \AgdaArgument{A})
would produce a program with one layer.
Therefore, \bind{} can only be called on programs with at least one layer.
The lowest layer is extended with the result of \AgdaArgument{k}.
For all numbers greater than zero we produce a program with the same structure
but a different value type.
For layer zero (i.e. values) we could either produce a value of type 
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{B}
or leave the value of type \AgdaArgument{A} unchanged.
In both cases we have to handle the lowest \AgdaInductiveConstructor{var}
constructors differently.

\begin{code}
bind : ∀ n → (Prog effs ^ suc n) A → (A → Prog effs B) →
  (Prog effs ^ suc n) B
bind {effs} {A} {B} n ma k = fold (bind-P A B effs) (suc n) id (λ where
    {0}      x → k x
    {suc n}  x → var x
  ) op scp ma
\end{code}
We left the values unchanged, therefore the \AgdaInductiveConstructor{var}
constructor at layer zero has to produce value of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{B}
by calling \AgdaArgument{k}.
In all other cases we replace each constructor with itself to leave these parts
unchanged.

Using \bind{} for a program with one layer and \AgdaInductiveConstructor{var} as
\AgdaFunction{return} we can define a monad instance for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}.
In contrast to Haskell this automatically defines a functor and an applicative
instances, because these can be defined in terms of \bind{} and
\AgdaFunction{return}\footnote{We automatically obtain the functions
  \AgdaFunction{<\$>}, \AgdaFunction{<*>}, \AgdaFunction{pure} and
  \AgdaFunction{>>}. }.
\begin{code}
instance
  Prog-RawMonad : RawMonad (Prog effs)
  Prog-RawMonad = record { return = var ; _>>=_ = bind 0 }
\end{code}
The record (which is used as a type class) is part of the Agda standard library.
It is named \AgdaDatatype{RawMonad}, because it does not enforce the monad laws.
We will prove the laws in section \ref{scoped-algebra:monad-laws} using
a technique from section \ref{scoped-algebra:ind}.


\subsection{Induction Schemes for Nested Data Types}
\label{scoped-algebra:ind}

Following the examples by Fu and
Selinger~\cite{DBLP:journals/corr/abs-1806-05230} we can generalize the
\AgdaFunction{fold} from section \ref{scoped-algebra:fold} to a dependently type
version, an induction principle.
In the induction principle the result type/proposition \AgdaDatatype{P} is
generalized to a dependent type.
Therefore the induction principle allows for proofs of predicates by induction
without explicit recursion.

The types for the four functions, corresponding to the three constructors and
the base case, also have to be generalized.

\begin{code}
ind : (P : (n : ℕ) → (Prog effs ^ n) A → Set) → ∀ n →
\end{code}
In the base case the given value of type \AgdaArgument{A} is the handled value.
Therefore the value is bound and passed to the proposition.
\begin{code}
  (               (x : A)                                              → P 0 x                     )  →
\end{code}
The \AgdaInductiveConstructor{var} can be handled similar to the examples by Fu
and Selinger.
An additional hidden parameter \AgdaArgument{x} for the smaller, recursively
handled value is introduced.
Because \AgdaArgument{x} represents the recursively handled type its part of the
smaller results type.
Furthermore, the parameter is used to describe the currently handled value
\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x}.
\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x} is therefore part of
the functions result type.

Under the Curry Howard corresponds this function (ignoring the index type) can
be read as the proposition
$\forall x. P(x) \Rightarrow P(\AgdaInductiveConstructor{var}\;x)$
i.e. the induction step for the constructor \AgdaInductiveConstructor{var}.
\begin{AgdaAlign}
\begin{code}
  (∀ {n x}      → P n x                                                → P (suc n) (var x)         )  →
\end{code}
Similar to \AgdaFunction{fold} dealing with \AgdaInductiveConstructor{op} and
\AgdaInductiveConstructor{scp} is more complicated, because they represent
arbitrarily branching nodes.
Remember that a containers position function maps from a type of positions,
which depends on the values shape, to the contained values.
Hence, assuming the containers values corresponds to assuming a position
function.
Analogues to the \AgdaFunction{fold} the result for the recursively handled value
is function, mapping from positions, for the assumed shape, to proofs for the
proposition for the there contained values.
The value for the position is obtained using the assumed position function
\AgdaArgument{κ}.
The currently handled value is constructed using \AgdaArgument{s} and  
\AgdaArgument{κ}.
Notice that the each of the four parameters depends on all its predecessors.
\begin{code}
  (∀ {n} s {κ}  → ((p : Pos (ops   effs) s) → P (1 + n)  (κ p))  → P (suc n) (op   (s , κ))  )  →
  (∀ {n} s {κ}  → ((p : Pos (scps  effs) s) → P (2 + n)  (κ p))  → P (suc n) (scp  (s , κ))  )  →
  (x : (Prog effs ^ n) A) → P n x
\end{code}
The actual implementation of the induction principle is straight forward and
similar to the one for \AgdaFunction{fold}.
The composition with the position function corresponds to the call to
\AgdaFunction{map}.
\begin{code}
ind P 0       a v o s x               = a x
ind P (suc n) a v o s (var x)         = v    (ind P n              a v o s x)
ind P (suc n) a v o s (op   (c , κ))  = o c  (ind P (suc n)        a v o s ∘ κ)
ind P (suc n) a v o s (scp  (c , κ))  = s c  (ind P (suc (suc n))  a v o s ∘ κ)
\end{code}
\end{AgdaAlign}


\subsection{Proving the Monad Laws}
\label{scoped-algebra:monad-laws}

\paragraph{Left Identity}
First we will prove the left identitiy law.
Because the value passed \AgdaFunction{>>=} constructed using
\AgdaFunction{return} i.e. \AgdaInductiveConstructor{var} both sides of the
equality can be directly evaluated to
\AgdaArgument{k}\AgdaSpace{}\AgdaArgument{a}.

\begin{code}
bind-identˡ : ∀ {A B : Set} {a} {k : A → Prog effs B} →
  (return a >>= k) ≡ k a
bind-identˡ = refl
\end{code}

\paragraph{Right Identity}
When proving the right identity the value passed to \AgdaFunction{>>=} can be an
arbitrarily complex program. Therefore the proposition is not ``obvious'' as it
was the case with \AgdaFunction{bind-identˡ}.

\begin{AgdaAlign}
\begin{code}
bind-identʳ : {A : Set} (ma : Prog effs A) → (ma >>= return) ≡ ma
\end{code}
\AgdaFunction{>>=} is recursive in its first argument, therefore we will prove
the proposition by induction on \AgdaArgument{ma}.
To use the induction scheme we have to define a proposition for every layer.
Since \AgdaFunction{>>=} does not change values we simply produce a value of
type \AgdaDatatype{⊤} at layer zero.
For all other we proof the proposition for the appropriate
\AgdaFunction{bind} i.e. the one called by \AgdaFunction{fold} to handle a value
for the given \AgdaArgument{n}.

\begin{code}
bind-identʳ {effs} {A} = ind (λ{ 0 _ → ⊤ ; (suc n) p → bind n p var ≡ p })
\end{code}
We call the induction scheme with the given value with one layer, therefore the
initial \AgdaArgument{n} is \AgdaNumber{1}.
The ``proof'' for values can be inferred, because for each value it's just a
value of the unit type.

\begin{code}
  1 _
\end{code}
To proof that the proposition holds for values constructed using
\AgdaInductiveConstructor{var} we have to case split on the number of layers
\AgdaArgument{n}.
For \AgdaNumber{0} we have to proof that
\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x} is equal to itself,
because \AgdaFunction{>>=} leaves values unchanged.
This proof forms the basis for our induction.

For the second case we are given a program \AgdaArgument{x} with
\AgdaInductiveConstructor{suc}\AgdaSpace{}\AgdaArgument{n} layers and an
induction hypothesis \AgdaArgument{IH} that the proposition holds for a call to
\AgdaFunction{bind}\AgdaSpace{}\AgdaArgument{n}.
We have to prove that the proposition holds for
\AgdaFunction{bind}\AgdaSpace{}$($\AgdaInductiveConstructor{suc}\AgdaSpace\AgdaArgument{n}$)$
and the new program \AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x}.
By applying the \AgdaFunction{>>=} rule for \AgdaInductiveConstructor{var} (for
\AgdaArgument{n} greater than zero) we can move \AgdaInductiveConstructor{var}
to the outside.
The new proposition is
\AgdaInductiveConstructor{var}\AgdaSpace{}$($\AgdaFunction{bind}\AgdaSpace{}\AgdaArgument{n}$)$\AgdaSpace{}\AgdaDatatype{≡}\AgdaSpace{}\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x}.
This proposition is equal to the induction hypothesis with
\AgdaInductiveConstructor{var} applied to both sides.
Therefore we can proof it using congruence.

\begin{code}
  (λ{ {0} (tt) → refl ; {suc n} IH → cong var IH })
\end{code}
The proofs for the \AgdaInductiveConstructor{op} and
\AgdaInductiveConstructor{scp} are identical and similar to the
\AgdaInductiveConstructor{var} case. For each shape \AgdaArgument{s} we are
given a proof for each position of the given shape.
We have to proof that the proposition holds for a new program constructed using
either \AgdaInductiveConstructor{op} or \AgdaInductiveConstructor{scp}.
For both constrcutors \AgdaFunction{bind}\AgdaSpace{}\AgdaArgument{n} calls
itself recusrivly on the all contained values i.e. the results of the position
function.
Using congruence we can simplify the equality to the equality of the position
functions.
By invoking the axiom of extensionality we can prove the equality for each
position.
This equality is exactly the one given by the induction hypothesis.

\begin{code}
  (λ s IH → cong (op   ∘ (s ,_)) (extensionality IH))
  (λ s IH → cong (scp  ∘ (s ,_)) (extensionality IH))
\end{code}
\end{AgdaAlign}

\paragraph{Associativity}
The proof for associativity follows the same pattern as the one for the right
identity.
\AgdaFunction{>>=} is defined by recursion on its first argument.
We therefore proof the proposition by induction on \AgdaArgument{ma}.
In all cases the left-hand side reduces to the induction hypothesis in the same
manner as before.
Therefore these cases look identical.

\begin{code}
bind-assoc : ∀ {A B C}
  (f : A → Prog effs B) (g : B → Prog effs C) (ma : Prog effs A) →
  (ma >>= f >>= g) ≡ (ma >>= λ a → f a >>= g)
bind-assoc f g = ind
  (λ where
    0 p        → ⊤
    (suc n) p  → bind n (bind n p f) g ≡ bind n p λ a → bind 0 (f a) g
  ) 1 _
  (λ{ {0} _ → refl ; {suc n} IH → cong var IH})
  (λ s IH → cong (op   ∘ (s ,_)) (extensionality IH))
  (λ s IH → cong (scp  ∘ (s ,_)) (extensionality IH))
\end{code}

\paragraph{Functor and Applicative Laws}
The monad laws imply the functor and applicative laws.
We can proof them without using explicit induction by rewriting equations
involving \AgdaFunction{>>=} using the above law.
These proofs are simpler than the ones explicitly involving the definition of
\AgdaFunction{>>=} using \AgdaFunction{fold}.
We can write them using the chain reasoning operators as described by
Norell~\cite{norell:thesis}.

\begin{code}
fmap-id : ∀ {effs} {A B : Set} → (ma : Prog effs A) → (id <$> ma) ≡ ma
fmap-id ma = begin
  (id <$> ma)                ≡⟨⟩ -- definition of <$>
  (ma >>= λ a → var (id a))  ≡⟨⟩ -- definition of id and η-conversion
  (ma >>= var)               ≡⟨ bind-identʳ ma ⟩
  ma                         ∎
\end{code}


\section{Combining Effects}

Similar to chapter \ref{chapter:higher-order} we reuse parts of the
infrastructure from chapter \ref{chapter:first-order}.
Each \AgdaDatatype{Effect} consists of a pair of \AgdaDatatype{Container}s, on
representing scoped and one representing unscoped effects.
Therefore, an \AgdaDatatype{Effect} stack now stores pairs of containers, not
containers directly.
The type \AgdaDatatype{\_∈\_} together with \AgdaFunction{inj} and
\AgdaFunction{prj} can be reused to model effect constraints.

\begin{code}[hide]
variable
  C  : Container
  Cs : List Container
  e : Effect
\end{code}

\begin{code}[hide] % TODO: non stdlib version
infix 3 _∈_
_∈_ : ∀ {a} {A : Set a} → A → List A → Set a
x ∈ xs = Any (_≡_ x) xs

instance
  ∈-head : ∀ {a} {A : Set a} {x : A} {xs} → x ∈ x ∷ xs
  ∈-head = here refl

  ∈-tail : ∀ {a} {A : Set a} {x y : A} {xs} → ⦃ x ∈ xs ⦄ → x ∈ y ∷ xs
  ∈-tail ⦃ p ⦄ = there p

inj : C ∈ Cs → ⟦ C ⟧ A → ⟦ sum Cs ⟧ A
inj (here refl) (s , κ) = inj₁ s , κ
inj (there p)   q       with inj p q
... | s , κ = inj₂ s , κ

prj : C ∈ Cs → ⟦ sum Cs ⟧ A → Maybe (⟦ C ⟧ A)
prj (here refl) (inj₁ s , κ) = just (s , κ)
prj (here refl) (inj₂ s , κ) = nothing
prj (there p)   (inj₁ s , κ) = nothing
prj (there p)   (inj₂ s , κ) = prj p (s , κ)
\end{code}
Due to the component wise combination of \AgdaDatatype{Effect}s, a proof that an
\AgdaDatatype{Effect} is an element of an effect stack implies that an
operations from one of the two signatures is part of the corresponding
signature of the combined effect.

\begin{code}
opsInj : e ∈ effs → Ops e ∈ mapᴸ Ops effs
opsInj (here refl) = here refl
opsInj (there p)   = there (opsInj p)

scpsInj : e ∈ effs → Scps e ∈ mapᴸ Scps effs
scpsInj (here refl) = here refl
scpsInj (there p)   = there (scpsInj p)
\end{code}
Using the above proofs we can implement smart constructors/inject functions for
scoped and unscoped operations without requiring other evidence.

\begin{code}
Op : ⦃ e ∈ effs ⦄ → ⟦ Ops e ⟧ (Prog effs A) → Prog effs A
Op ⦃ p ⦄ = op ∘ inj (opsInj p)

Scp : ⦃ e ∈ effs ⦄ → ⟦ Scps e ⟧ (Prog effs (Prog effs A)) → Prog effs A
Scp ⦃ p ⦄ = scp ∘ inj (scpsInj p)
\end{code}

To escpe the monad after interpreting all effects we again add the
\AgdaFunction{run} handler.

\begin{code}
run : Prog [] A → A
run (var x) = x
\end{code}

\section{Nondet}

As first example we will implement the nondeterminism effect.
In section \ref{scoped-algebra:nondet:scoped-algebra} we will implement the
example by Piróg et al. to demonstrate that the \AgdaFunction{fold} definition
from section \ref{scoped-algebra:fold} is sufficient.
Section \ref{scoped-algebra:nondet:modular} will present an idea for modular
effects and handlers.

\subsection{As Scoped Algebra}
\label{scoped-algebra:nondet:scoped-algebra}
The signature for the two algebraic operations is the same as before.
Furthermore we define a signature for the scoped operations \AgdaFunction{once}.

\begin{code}[hide]
SID CID : Set
SID = ℕ × ℕ
CID = SID × ℕ
\end{code}
\begin{code}
data Choiceˢ  : Set where ⁇ˢ : (Maybe CID) → Choiceˢ ; failˢ : Choiceˢ
data Onceˢ    : Set where onceˢ : Onceˢ
\end{code}
\AgdaDatatype{Nondetᵖ} corresponds to the data type from the example by Piróg et
al.~\cite[sec.~6]{DBLP:conf/lics/PirogSWJ18}.
The effect has the unary, scoped operation \AgdaFunction{once} and the nullary
and binary, algebraic operations \AgdaFunction{⁇} and \AgdaFunction{fail}.

\begin{code}
Nondetᵖ : Effect
Ops   Nondetᵖ = Choiceˢ  ▷ λ{ (⁇ˢ _) → Bool ; failˢ → ⊥ }
Scps  Nondetᵖ = Onceˢ    ↝ ⊤
\end{code}
A scoped algebra for an \AgdaDatatype{ℕ} indexed carrier type \AgdaArgument{C}
consists of three operations.
\AgdaField{a} the \textit{algebra} for the unscoped operations.
\AgdaField{p} for \textit{promoting} the carrier type when entering a scope.
\AgdaField{d} for \textit{demoting} the carrier type when leaving a scope and
interpreting the syntax.
Figure \ref{scoped-algebra:fig:reduction} demonstrates how the handler
interprets \AgdaDatatype{Nondet} syntax using the scoped algebra.
It corresponds to an image for the other monad from ``Syntax and Semantics for
Operations with Scopes'', but represents programs using the
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} monad.

\begin{figure}
  \begin{tikzpicture}[level distance=.7cm,sibling distance=1.3cm]
  \node[treenode] at (0,0) {\textbf{scp once}}
    child { 
      node[treenode] {\textbf{?}}
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {\textbf{?}}
          child {
            node[treenode] {\textbf{var}}
            child { node[treenode] {$1$} }
          }
          child {
            node[treenode] {\textbf{var}}
            child { node[treenode] {$2$} }
          }
        }
      }
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {\textbf{?}}
          child {
            node[treenode] {\textbf{var}}
            child { node[treenode] {$3$} }
          }
          child {
            node[treenode] {\textbf{var}}
            child { node[treenode] {$4$} }
          }
        }
      }
    }
  ;
  \node[treenode] at (1.5,0) {$\stackrel{p}{\leadsto{}}$};
  \node[treenode] at (3,0) {\textbf{scp once}}
    child { 
      node[treenode] {\textbf{?}}
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {\textbf{?}}
          child { node[treenode] {$[1]$} }
          child { node[treenode] {$[2]$} }
        }
      }
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {\textbf{?}}
          child { node[treenode] {$[3]$} }
          child { node[treenode] {$[4]$} }
        }
      }
    }
  ;
  \node[treenode] at (4.5,0) {$\stackrel{a}{\leadsto{}}$};
  \node[treenode] at (6,0) {\textbf{scp once}}
    child { 
      node[treenode] {\textbf{?}}
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {$[1,2]$}
        }
      }
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {$[3,4]$}
        }
      }
    }
  ;
  \node[treenode] at (7.25,0) {$\stackrel{p}{\leadsto{}}$};
  \node[treenode] at (8.5,0) {\textbf{scp once}}
    child { 
      node[treenode] {\textbf{?}}
      child {
        node[treenode] {$[[1,2]]$}
      }
      child {
        node[treenode] {$[[3,4]]$}
      }
    }
  ;
  \node[treenode] at (9.75,0) {$\stackrel{a}{\leadsto{}}$};
  \node[treenode] at (11,0) {\textbf{scp once}}
    child { 
      node[treenode] {$[[1,2],[3,4]]$}
    }
  ;
  \node[treenode] at (12.25,0) {$\stackrel{d}{\leadsto{}}$};
  \node[treenode] at (13,0) {$[1,2]$};
  \end{tikzpicture}
  \label{scoped-algebra:fig:reduction}
  \caption{Interpretation of
    $\textbf{once}\;(\textbf{var}\;1\;?\;\textbf{var}\;3)\bind \lambda
    x.\textbf{var}\;x\;?\;\textbf{var}\;(x+1)$}
\end{figure}

The indices for \AgdaField{d} and \AgdaField{a} are offset by one compared to
the definition by Piróg et al.
We won't define our carrier data type in two stages as Piróg et al. but as an
$n$-fold version of a simpler type.
This change allows a simpler implementation using the \AgdaFunction{fold} from
section \ref{scoped-algebra:fold}, but should be insignificantly enough to
present the similarities between the to recursion schemes.

\begin{code}
record ScopedAlgebra (E : Effect) (C : ℕ → Set) : Set where
  constructor ⟨_,_,_⟩
  field
    p : ∀ {n} → C n                      → C (1 + n)
    d : ∀ {n} → ⟦ Scps  E ⟧ (C (2 + n))  → C (1 + n)
    a : ∀ {n} → ⟦ Ops   E ⟧ (C (1 + n))  → C (1 + n)
open ScopedAlgebra
\end{code}
Given a \AgdaDatatype{ScopedAlgebra} for an \AgdaDatatype{Effect} we can
interpret its syntax.
\AgdaDatatype{foldᴾ} corresponds to slightly modified version of the fold by
Piróg et al.
Their function works for an arbitrary \AgdaArgument{n} to allow recursion.
Since, this recursion is abstracted in \AgdaFunction{fold} this is not needed.
Furthermore they have to inject values explicitly into the carrier type.
This happens implicitly due to the handling of the $0$-th layer.
Notice that the functions from the \AgdaDatatype{ScopedAlgebra} correspond
exactly to the ones expected by the \AgdaFunction{fold} from section
\ref{scoped-algebra:fold}.
The values them self aren't preprocessed and will just get promoted, hence
\AgdaFunction{id} as passed as the first of the four functions.

\begin{code}
foldᴾ : ∀ {C : Set → ℕ → Set} → ScopedAlgebra e (C A) → 
  Prog (e ∷ []) (C A 0) → C A 1
foldᴾ {C = C} ⟨ p , d , a ⟩ = fold (C _) 1 id p
  (λ{ (inj₁ s , κ) → a (s , κ) }) λ{ (inj₁ s , κ) → d (s , κ) }
\end{code}
Just porting the algebra for \AgdaDatatype{Nondet} by Piróg et al. yields a
correct handler for the effect in isolation.
The carrier type are iterated \AgdaDatatype{List}s.

The implementation of the scoped algebra is straight forward.
The algebraic operations are handled as before and the promotion operation
corresponds to the earlier handling of values.
The demotion operation i.e. the handler for \AgdaFunction{once} has
to produce an $n$-fold list, given an $n+1$-fold list.
% :/
Before applying the handler, the programs in the \AgdaInductiveConstructor{var}
nodes are the results for all possible continuations for the program in scope.
The elements of the given list are the results of these programs.
By acting just on the given list of lists the handler can separate between the
results of the different branches in the scoped program.

\begin{code}
NondetAlg : ScopedAlgebra Nondetᵖ (λ i → List ^ i $ A)
p NondetAlg              = _∷ []
a NondetAlg (⁇ˢ _  , κ)  = κ true ++ κ false
a NondetAlg (failˢ , κ)  = []
d NondetAlg (onceˢ , κ)  with κ tt
... | []     = []
... | x ∷ _  = x

runNondetᴾ : Prog (Nondetᵖ ∷ []) A → List A
runNondetᴾ = foldᴾ {C = λ A i → List ^ i $ A} NondetAlg
\end{code}
The carrier type can be thought of as the context for the computation.
By having contexts of contexts it's possible to differentiate between the state
of the computation in scope and the whole computation.

Lastly we will define a smartconstructor for the \AgdaFunction{once} operation.
To capture the program \AgdaArgument{p} in scope, \AgdaFunction{pure} is mapped
over it.
The orignial program is now the outher
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layer i.e. the first and
second layers of the first term in figure \ref{scoped-algebra:fig:reduction}.
The original \AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x} nodes
are now
\AgdaInductiveConstructor{var}$($\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x}$)$
nodes.
Since \AgdaFunction{>>=} just effects the lowest layer it won't change the
captured program and just act on it's results.

\begin{code}
onceᵖ : ⦃ Nondetᵖ ∈ effs ⦄ → Prog effs A → Prog effs A
onceᵖ p = Scp (onceˢ , λ _ → pure <$> p)
\end{code}

\subsection{As Modular Handler}
\label{scoped-algebra:nondet:modular}

Piróg et al. just present handlers for single effects.
This section presents an idea for adapting the handlers from the paper to
modular ones.

As in the earlier chapters, when working with modular effects, the general
approach is to execute the handlers for each effect one after
another~\cite{DBLP:conf/haskell/SchrijversPWJ19}.
Each handler interprets the syntax for its effect and leaves the rest in place
(or in case of non-orthogonal effects manipulates syntax of certain other
effects).
The carrier type for these handlers consists of the usual carrier type for these
handlers, which is post composed with the type of the program without the
interpreted syntax.
For example, a handler for exceptions would produce values of type
\AgdaArgument{E}\AgdaSpace{}\AgdaDatatype{⊎}\AgdaSpace{}\AgdaArgument{A},
therefore the modular handler produces value of type 
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}$($\AgdaArgument{E}\AgdaSpace{}\AgdaDatatype{⊎}\AgdaSpace{}\AgdaArgument{A}$)$.

In the context of scoped algebras, the \AgdaDatatype{ℕ} indexed carrier type is
usually the $n$-fold of some simpler type $C$.
It seems reasonable to choose an $n$-fold of
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}$\circ\; C$ as
carrier type, because the structure of $n$ layers of $C$s has to be preserved to
reuse the non modular handler.
Simply lifting the $n$-fold carrier type in the monad is not sufficient.
The interleaved monad layers are needed to preserve non-interpreted syntax.

Consider the following implementation of modular handler for nondeterminism.
This version of the nondeterminism effect does not support the
\AgdaFunction{once} operation, because the semantics of the above definition is
not the expected one when interacting with other effects.
Similar to earlier chapter we introduce \AgdaKeyword{pattern}s to simplify
the handler.

\begin{code}[hide]
data Tree (A : Set) : Set where
  branch : Maybe CID → (l r : Tree A) → Tree A
  leaf   : A → Tree A
  failed : Tree A

dfs : {A : Set} → Map Bool → Tree A → List A
dfs mem failed                   = []
dfs mem (leaf x)                 = x ∷ []
dfs mem (branch nothing    l r)  = dfs mem l ++ dfs mem r
dfs mem (branch (just id)  l r) with lookup id mem
... | nothing  = dfs (insert id true mem) l ++ dfs (insert id false mem) r
... | just d   = if d then dfs mem l else dfs mem r
\end{code}
\begin{code}
Nondet : Effect
Ops   Nondet = Choiceˢ ▷ λ{ (⁇ˢ _) → Bool ; failˢ → ⊥ }
Scps  Nondet = Void

pattern Other s κ     = (inj₂ s , κ)
pattern Choice cid κ  = (inj₁ (⁇ˢ cid) , κ)
pattern Fail          = (inj₁ failˢ , _)
\end{code}
The new handler has the expected signature, which follows from the above
described carrier type.

\begin{AgdaAlign}
\begin{code}
runNondet′ : Prog (Nondet ∷ effs) A → Prog effs (Tree A)
runNondet′ {effs} {A} = fold (λ i → (Prog effs ∘ Tree) ^ i $ A) 1 id
\end{code}
Values are now not only injected into the context, but also into the monad.

\begin{code}
  (pure ∘ leaf)
\end{code}
The algebraic operations are interpreted as before, except that all results are
lifted into the monad.
When an operation from a foreign effect is encountered the syntax is just
reconstructed.
The outer container coproduct is removed by interpreting the
\AgdaDatatype{Nondet} syntax, therefore \AgdaArgument{s} already has the correct
type (note that \AgdaInductiveConstructor{Other} hides the
\AgdaInductiveConstructor{inj₂}).
\AgdaArgument{κ} produces result for the positions of the given shape, because
the recursion is handled by \AgdaFunction{fold}.
Therefore the implementation is the same as in chapter \ref{chapter:first-order}
except that the recursion is hidden.

\begin{code}
  (λ where
    (Choice id κ)  → branch id <$> κ true <*> κ false
    Fail           → pure failed
    (Other s κ)    → op (s , κ)
\end{code}
The interesting case is the one for scoped operations of foreign effects.
Similar to the algebraic operations we have to reconstruct the scoped operation,
but the position function has the wrong type.
It produces values of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaFunction{∘}\AgdaSpace{}\AgdaDatatype{Tree}\AgdaSpace{}\AgdaFunction{\textasciicircum}\AgdaSpace{}\AgdaInductiveConstructor{suc}\AgdaSpace{}\AgdaArgument{n}\AgdaSpace{}\AgdaFunction{\$}\AgdaSpace{}\AgdaArgument{A}
but expected are values of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaFunction{\$}
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaFunction{∘}\AgdaSpace{}\AgdaDatatype{Tree}\AgdaSpace{}\AgdaFunction{\textasciicircum}\AgdaSpace{}\AgdaArgument{n}\AgdaSpace{}\AgdaFunction{\$}\AgdaSpace{}\AgdaArgument{A}.

To remove the intermediate \AgdaDatatype{Tree} layer we map the function
\AgdaFunction{hdl} over the result of the continuation.
\AgdaFunction{hdl} traverses the outer tree and recombines the inner trees under
the monad i.e. by interleaiving binds it orders the results.
On a term level, we are given a list of possible continuations, which we execute
on after another, appending their reults.

\begin{code}
  ) λ where
    (Other s κ)  → scp (s , λ p → hdl <$> κ p)
  where
    hdl : ∀ {A} → Tree (Prog effs (Tree A)) → Prog effs (Tree A)
    hdl (branch cid l r)  = branch cid <$> hdl l <*> hdl r
    hdl (leaf v)          = v -- no recursive call due to fold
    hdl failed            = var failed
\end{code}
\end{AgdaAlign}
In terms of Haskell typeclass the above implementation generalizes if $C$ is a
traversable monad, because \AgdaFunction{hdl} corresponds to
\mintinline{haskell}{fmap join . sequence}.
This is quite a strong condition, but it does not seems necessary, because we
will see another example in section \ref{scoped-algebra:state}, which does not
follow this pattern.
Furthermore, the carrier types of effects are often simple data structures like
products, coproducts, lists or trees, which are usually traversable and often
monads.
Its also unclear if a monad or just a notion of flattening is needed.

Notice that the \AgdaFunction{hdl} is similar to the handler function from
chapter \ref{chapter:higher-order}.
Because the \AgdaFunction{fold} already interpreted parts of the program we do
not call the handler recursively, but just join the results.

\begin{code}
runNondet : Prog (Nondet ∷ effs) A → Prog effs (List A)
runNondet p = dfs empty <$> runNondet′ p

fail : ⦃ Nondet ∈ effs ⦄ → Prog effs A
fail = Op (failˢ , λ())

_⁇_ : ⦃ Nondet ∈ effs ⦄ → Prog effs A → Prog effs A → Prog effs A
p ⁇ q = Op (⁇ˢ nothing , (if_then p else q))
\end{code}

\section{Exceptions}

As our second example for a scoped effect in the modular setting we will take a
look at exceptions.
The syntax for \AgdaFunction{throw} is the same as before.
Similar to chapter \ref{chapter:higher-order} \AgdaFunction{catch} has two
sub-computations, the program in scope and the handler.
The boilerplate code for the syntax is given below.

\begin{code}
data Throwˢ (E : Set)  : Set where throwˢ : (e : E) → Throwˢ E
data Catchˢ            : Set where catchˢ : Catchˢ
data Catchᵖ (E : Set)  : Set where
  mainᵖ    : Catchᵖ E
  handleᵖ  : (e : E) → Catchᵖ E

Exc : Set → Effect
Ops   (Exc E) = Throwˢ E  ↝ ⊥
Scps  (Exc E) = Catchˢ    ↝ Catchᵖ E

pattern Throw  e = (inj₁ (throwˢ e) , _)
pattern Catch  κ = (inj₁ catchˢ , κ)
\end{code}
The first part of the handler is the same as in the higher order setting.
To interpret the scoped operation \AgdaFunction{catch} we first execute scoped
program in the \AgdaInductiveConstructor{mainᵖ} position.
It produces either an exception or the result for the rest of the program.
In the later case we just return the result.
Notice that the recursive call was taken care of by the \AgdaFunction{fold}.
In the other case we obtain an exception \AgdaArgument{e} with which we can
obtain the result of the continuation in the \AgdaInductiveConstructor{handleᵖ}
position i.e. handle the exception.
The result of the exception handler is again wrapped in \AgdaDatatype{\_⊎\_}.
We pass the result along by either unwrapping the program or re-injecting the
exception in the program using \AgdaFunction{pure}.
The same function is used to traverse foreign scopes.
Again the function corresponds to the handler from chapter
\ref{chapter:higher-order}, but without the recursive call.

\begin{code}
runExc : Prog (Exc E ∷ effs) A → Prog effs (E ⊎ A)
runExc {E} {effs} {A} = fold (λ i → (Prog effs ∘ (E ⊎_)) ^ i $ A) 1 id
  (pure ∘ inj₂)
  ( λ where
    (Throw e)    → pure (inj₁ e)
    (Other s κ)  → op (s , κ)
  ) λ where
    (Catch κ) → κ mainᵖ >>= λ where
      (inj₁ e)  → κ (handleᵖ e) >>= [ pure ∘ inj₁ , id ]
      (inj₂ x)  → x
    (Other s κ) → scp (s , λ p → [ pure ∘ inj₁ , id ] <$> κ p)
\end{code}
The smart constructors for the operations follow the known pattern.

\begin{code}
throw : ⦃ Exc E ∈ effs ⦄ → E → Prog effs A
throw e = Op (throwˢ e , λ())

_catch_ : ⦃ Exc E ∈ effs ⦄ → Prog effs A → (E → Prog effs A) → Prog effs A
p catch h = Scp $ catchˢ , λ where
  mainᵖ        → pure <$> p
  (handleᵖ e)  → pure <$> h e
\end{code}


\section{State}
\label{scoped-algebra:state}

To implement the sharing effect as described by Bunkenburg we also need to
implement the \AgdaDatatype{State} effect.
The syntax is the same as before.

\begin{code}
data Stateˢ (S : Set) : Set where
  putˢ : (s : S) → Stateˢ S
  getˢ : Stateˢ S

State : Set → Effect
Ops   (State S) = Stateˢ S ▷ λ{ (putˢ s) → ⊤ ; getˢ → S }
Scps  (State S) = Void

pattern Get κ     = (inj₁ getˢ , κ)
pattern Put s₁ κ  = (inj₁ (putˢ s₁) , κ)
\end{code}
When traversing a foreign scope we have to eliminate the intermediate context.
\AgdaArgument{κ} produces a value of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}$($%
\AgdaArgument{S}\AgdaSpace{}\AgdaSymbol{×}\AgdaSpace{}$($%
\AgdaArgument{S}\AgdaSpace{}\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaSymbol{⋯}$)$$)$.
The lifted pair consists of the final state of the program in scope and the
function mapping an initial state to the result of the corresponding result of
the continuation.
To remove the inner context we simply pass the state along, by applying the
function to the given state using \AgdaFunction{eval}.

\begin{code}
runState : Prog (State S ∷ effs) A → S → Prog effs (S × A)
runState {S} {effs} {A} = fold (λ i → (λ X → S → Prog effs (S × X)) ^ i $ A) 1 id
  (λ x s₀ → pure (s₀ , x))
  (λ where
    (Put s₁ κ)   _   → κ tt s₁
    (Get κ)      s₀  → κ s₀ s₀
    (Other s κ)  s₀  → op (s , λ p → κ p s₀)
  ) λ where
    (Other s κ)  s₀  → scp (s , λ p → eval <$> κ p s₀)
  where
    eval : ∀ {A B} → A × (A → B) → B
    eval (a , f) = f a

evalState : Prog (State S ∷ effs) A → S → Prog effs A
evalState s₀ p = π₂ <$> runState s₀ p
\end{code}
The operations are just the usual generic operations for the effect.

\begin{code}
get : ⦃ State S ∈ effs ⦄ → Prog effs S
get = Op (getˢ , pure)

put : ⦃ State S ∈ effs ⦄ → S → Prog effs ⊤
put s = Op (putˢ s , pure)
\end{code}


\section{Share}

Lastly we will implement the sharing effect.
The signature contains just the single, unary, scoped operation, \AgdaFunction{share}
which creates new sharing scope.

\begin{code}
data Shareˢ : Set where shareˢ : SID → Shareˢ

Share : Effect
Ops   Share = Void
Scps  Share = Shareˢ ↝ ⊤

pattern ShareScp sid κ = (inj₁ (shareˢ sid) , κ)
\end{code}
In the handler the passed along choice id is handled similar to the initial state
in the \AgdaDatatype{State} effect.
It's part of the iterated carrier type, which allows it to be changed between
layers\footnote{This is a general pattern with this approach. Handler arguments
are turned into function arguments for the carrier type, because the recursion
is done via \AgdaFunction{fold}. The same can be observed in a setting without
algebraic effects and folding handlers~\cite{DBLP:conf/haskell/SchrijversPWJ19}.
}.
When handling a sharing scope the captured program is handled with the id of the
stored in the shape of the scoping operation.
The continuation is accessed via \AgdaFunction{>>=} and continuous with the
outside i.e. the initial id.
Scopes of foreign effects don't effect sharing.
In contrast to \AgdaDatatype{State}, the captured program does not influence the
continuation, therefore both use the same, initial id.

\begin{code}
runShare′ : ⦃ Nondet ∈ effs ⦄ → Prog (Share ∷ effs) A → SID → ℕ → Prog effs A
runShare′ {effs} {A} ⦃ p ⦄ = fold (λ i → ((λ X → SID → ℕ → Prog effs X) ^ i) A) 1 id
  (λ z _ _ → var z)
  (λ{ (Other s pf) → case prj (opsInj p) (s , pf) of λ where
    nothing              sid n → op (s , λ p → pf p sid n)
    (just (failˢ  , κ))  sid n → fail
    (just (⁇ˢ _   , κ))  sid n → Op (⁇ˢ (just (sid , n)) , λ p → κ p sid (suc n))
  }) λ where
    (ShareScp sid′ κ) sid n → κ tt sid′ 0 >>= λ r → r sid n
    (Other    s    κ) sid n → scp (s , λ p → (λ k → k sid n) <$> κ p sid n)

runShare : ⦃ Nondet ∈ effs ⦄ → Prog (Share ∷ effs) A → Prog effs A
runShare p = runShare′ p (0 , 0) 0
\end{code}
For simplicity the handler is initial invoked with choice id $(0,0,0)$.
This should not be a problem if the numbering of scopes starts with a higher ID,
because after calling the \AgdaDatatype{Share} handler no scopes are duplcaited.
If such a situation should arrise the ID passed around by the handler can simply
be made optional via \AgdaDatatype{Maybe}, allowing no IDs for the outside
choices.

\begin{code}[hide]
record Shareable (effs : List Effect) (A : Set) : Set where
  field
    shareArgs : A → Prog effs A
open Shareable ⦃...⦄ public

instance
  ℕ-Shareable : Shareable effs ℕ
  Shareable.shareArgs ℕ-Shareable = var

  Bool-Shareable : Shareable effs Bool
  Shareable.shareArgs Bool-Shareable = var

record Normalform (effs : List Effect) (A B : Set) : Set where
  field
    nf : A → Prog effs B

  infix 10 !_
  !_ : Prog effs A → Prog effs B
  !_ = _>>= nf
open Normalform ⦃...⦄ public

instance
  ℕ-Normalform : Normalform effs ℕ ℕ
  Normalform.nf ℕ-Normalform = var

  Bool-Normalform : Normalform effs Bool Bool
  Normalform.nf Bool-Normalform = var

  ⊤-Normalform : Normalform effs ⊤ ⊤
  Normalform.nf ⊤-Normalform = var
\end{code}
The \AgdaDatatype{Shareable} and \AgdaDatatype{Normalform} infrastructure from
chapter \ref{chapter:first-order} can be reused to define the
\AgdaFunction{Ágda} operator.

The program in the scope is again captured by mapping \AgdaFunction{pure} over it.
The constrcution of scope ids follow again the implementation by Bunkenburg.

\begin{code}
share⟨_⟩ : ⦃ Share ∈ effs ⦄ → SID → Prog effs A → Prog effs A
share⟨_⟩ {Scps} {Ops} sid p = Scp (shareˢ sid , λ _ → pure <$> p)

share : ⦃ State SID ∈ effs ⦄ → ⦃ Share ∈ effs ⦄ → ⦃ Shareable effs A ⦄ →
  Prog effs A → Prog effs (Prog effs A)
share {Ops} {Scps} p = do
    (i , j) ← get
    put (i + 1 , j)
    let p′ = do
          put (i , j + 1)
          x  ← p
          x′ ← shareArgs x
          put (i + 1 , j)
          pure x′
    pure $ share⟨ i , j ⟩ p′
\end{code}
Using \AgdaFunction{Nondet}, \AgdaFunction{State} and \AgdaFunction{Share} we
can again simulate call-time choice semantics.
As expected, doubling a shared coin yields the results $0$ and $2$.

\begin{code}
runCTC : ⦃ Normalform (State SID ∷ Share ∷ Nondet ∷ []) A B ⦄ →
  Prog (State SID ∷ Share ∷ Nondet ∷ []) A → List B
runCTC p = run $ runNondet $ runShare $ evalState (! p) (1 , 1)

coin : ⦃ Nondet ∈ effs ⦄ → Prog effs ℕ
coin = pure 0 ⁇ pure 1

doubleCoin : ⦃ Nondet ∈ effs ⦄ → ⦃ Share ∈ effs ⦄ → ⦃ State SID ∈ effs ⦄ →
  Prog effs ℕ
doubleCoin = do c ← share coin
                ⦇ c + c ⦈

runDoubleCoin : runCTC doubleCoin ≡ 0 ∷ 2 ∷ []
runDoubleCoin = refl
\end{code}
In contrast to chapter \ref{chapter:higher-order} this approach can also model
deep effects without involving universe levels.
The definition of an effectful list as well as its typeclass instances from
chapter \ref{chapter:first-order} can be reused.

\begin{code}[hide]
data Listᴹ (effs : List Effect) (A : Set) : {Size} → Set where
  nilᴹ  : ∀ {i} → Listᴹ effs A {i}
  consᴹ : ∀ {i} → Prog effs A → Prog effs (Listᴹ effs A {i}) → Listᴹ effs A {↑ i}

pattern []ᴹ         = var nilᴹ
pattern _∷ᴹ_ mx mxs = var (consᴹ mx mxs)

headᴹ : ⦃ Nondet ∈ effs ⦄ → Prog effs (Listᴹ effs A) → Prog effs A
headᴹ = _>>= λ where
  nilᴹ         → fail
  (consᴹ mx _) → mx

instance
  Listᴹ-Normalform : ∀ {i} → ⦃ Normalform effs A B ⦄ → Normalform effs (Listᴹ effs A {i}) (List B)
  Normalform.nf Listᴹ-Normalform nilᴹ           = var []
  Normalform.nf Listᴹ-Normalform (consᴹ mx mxs) = ⦇ ! mx ∷ ! mxs ⦈

  Listᴹ-Shareable : ∀ {i} → ⦃ Shareable effs A ⦄ → ⦃ State SID ∈ effs ⦄ → ⦃ Share ∈ effs ⦄ → Shareable effs (Listᴹ effs A {i})
  Shareable.shareArgs Listᴹ-Shareable nilᴹ           = []ᴹ
  Shareable.shareArgs Listᴹ-Shareable (consᴹ mx mxs) = ⦇ consᴹ (share mx) (share mxs) ⦈
\end{code}
\begin{code}
doubleHead : ⦃ Nondet ∈ effs ⦄ → ⦃ Share ∈ effs ⦄ → ⦃ State SID ∈ effs ⦄ →
  Prog effs ℕ
doubleHead = do mxs ← share (coin ∷ᴹ []ᴹ)
                ⦇ headᴹ mxs + headᴹ mxs ⦈

runDoubleHead : runCTC doubleHead ≡ 0 ∷ 2 ∷ []
runDoubleHead = refl
\end{code}
