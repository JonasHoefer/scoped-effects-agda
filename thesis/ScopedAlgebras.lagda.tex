\begin{code}[hide]
module ScopedAlgebras where

open import Function using (id; _∘_; _$_; const)
open import Level using (Level)

open import Category.Monad using (RawMonad)
open        RawMonad ⦃...⦄ renaming (_⊛_ to _<*>_)

open import Data.Bool using (Bool; true; false; if_then_else_)
open import Data.Product using (Σ-syntax; _,_) renaming (proj₁ to π₁; proj₂ to π₂)
open import Data.Maybe using (Maybe; just; nothing)
open import Data.Nat using (ℕ; suc; _+_)
open import Data.Product using (_×_; _,_)
open import Data.Sum using (_⊎_; inj₁; inj₂; [_,_])
open import Data.Empty using (⊥)
open import Data.List using (List; _∷_; []; _++_; foldr) renaming (map to mapᴸ)
open import Data.List.Relation.Unary.Any using (Any; here; there) renaming (map to map∈)
open import Data.Unit using (⊤; tt)

import Relation.Binary.PropositionalEquality as Eq
open   Eq using (_≡_; refl; cong; sym; trans)
open   Eq.≡-Reasoning using (_≡⟨⟩_; begin_; _∎; step-≡)

postulate
  extensionality : ∀ {ℓ ℓ′ : Level} {A : Set ℓ} {B : A → Set ℓ′} {f g : (x : A) → B x}
      → (∀ (x : A) → f x ≡ g x) → f ≡ g
\end{code}

Due to the deep-rooted problem with the higher order approach from chapter
\ref{chapter:higher-order} it seemed reasonable to search for another
formulation of scoped effects, which does not rely on existential types.
Piróg et al.~\cite{DBLP:conf/lics/PirogSWJ18} presented a novel formulation for
scoped operations and their algebras, which fulfils this requirement.
Their approach does not describe the combination of multiple effects, but due to
the different structure the approach seemed worth exploring nonetheless.

This chapter transfers the basic implementation from Piróg et al. to Agda,
derives a different implementation of \AgdaFunction{fold}, based on the work by
Fu and Selinger~\cite{DBLP:journals/corr/abs-1806-05230}, for their monad to
aid termination checking and presents an idea for modularisation of their
algebras.


\section{The Monad $E$}

Piróg et al. describe a monad, which is suited for modelling operations with
scopes~\cite{DBLP:conf/lics/PirogSWJ18}.
The monad is the result of rewriting a slightly modified version of the monad
from ``Effect Handlers in Scope'' i.e. the monad used in chapter
\ref{chapter:higher-order}.
They separate the signature into one describing effects with scopes $\Gamma$ and
one describing the algebraic effects $\Sigma$.
The monad $E$ can be described as the fixpoint of the following equation, where
the coend (the integral sign) denotes an existential types.

\[
  EA \cong A + \Sigma{}(EA) + \int^{X\in\mathscr{C}} \Gamma{}(EX) \times (EA)^X
\]
This representation looks appropriate considering our earlier definition.
An element of the monad is either a value of $A$, an operation without scopes,
i.e. a functor applied to \texttt{Free F A} or an operation with scopes.
Operations with scopes (e.g. \texttt{catch}) always quantified over some type to
store subprograms over the same signature but with different local result type.
Furthermore they provided a continuation, which transformed values of the
internal result type to the result type of the whole program.
[GAMMA]
The following Agda data type represents the above monad.

\begin{code}[hide]
record Container : Set₁ where
  constructor _▷_
  field
    Shape : Set
    Pos : Shape → Set
open Container public

_↝_ : Set → Set → Container
S ↝ P = S ▷ const P

⟦_⟧ : ∀ {ℓ} → Container → Set ℓ → Set ℓ
⟦ S ▷ P ⟧ A = Σ[ s ∈ S ] (P s → A)

-- TODO: EXPLAIN!
map : {A B : Set} {C : Container} → (A → B) → ⟦ C ⟧ A → ⟦ C ⟧ B
map f c = π₁ c , f ∘ π₂ c
{-# INLINE map #-}

_⊕_ : Container → Container → Container
(S₁ ▷ P₁) ⊕ (S₂ ▷ P₂) = (S₁ ⊎ S₂) ▷ [ P₁ , P₂ ]

Void : Container
Void = ⊥ ▷ λ()

sum : List Container → Container
sum = foldr _⊕_ Void

\end{code}
\begin{code}
data ProgE (Σ Γ : Container) (A : Set) : Set₁ where
  var  : A → ProgE Σ Γ A
  op   : ⟦ Σ ⟧ (ProgE Σ Γ A) → ProgE Σ Γ A
  scp  : {X : Set} → ⟦ Γ ⟧ (ProgE Σ Γ X) → (X → ProgE Σ Γ A) → ProgE Σ Γ A
\end{code}
Notice again that this definition requires $X$ to be a smaller type than
\AgdaDatatype{E} i.e. it's not sufficient to model deep effects as explained in
chapter \ref{chapter:higher-order}.
Piróg et al. also not size issues with this definition.

Piróg et al. rewrite this definition using a left Kan extension and derive the
following equivalent monad without the existential type.

\[
  EA \cong A + \Sigma{}(EA) + \Gamma{}(E(EA))
\]
An equivalent monad without the existential type is a promising candidate for
modelling deep effects in Agda, because it avoids the size issues.

The monad models scopes using the double $E$ layer.
The outer layer corresponds to the part of program in scope.
By evaluating it (i.e. the part of the program in scope) one obtains a value of
type $EA$, the rest of the program producing a result of type $A$.
This resulting program corresponds to the continuation in the higher order
approach, which was a function mapping from the the result of the scoped program
to the rest of the whole program.

\section{The \texttt{Prog} Monad}

In this section we will define the central monad for this approach.
Because signatures are split into effects with and without scopes we will define
effects as pairs of functors and therefore \AgdaDatatype{Container}s.

\begin{code}
record Effect : Set₁ where
  field
    Ops Scps : Container
open Effect public
\end{code}
The functions \AgdaFunction{ops} and \AgdaFunction{scps} combine the
corresponding signatures of a \AgdaDatatype{List} of \AgdaDatatype{Effect}s.

\begin{code}
ops scps : List Effect → Container
ops   = sum ∘ mapᴸ Ops
scps  = sum ∘ mapᴸ Scps
\end{code}
Using these helper functions we can define a modular version of the monad by
Piróg et al~\cite{DBLP:conf/lics/PirogSWJ18}.
It's equivalent to the fixpoint and the Haskell definition from the paper
(assuming that signatures are given by strictly positive functors).

% TODO: Piróg et al. define algrabs in terms of antoher moand and proof
% equvialence, but we cannot follow their defintion due to termination problems
% => Alternative folds
\begin{code}
data Prog (effs : List Effect) (A : Set) : Set where
  var  :  A                                         → Prog effs A
  op   :  ⟦ ops  effs  ⟧ (Prog effs A)              → Prog effs A
  scp  :  ⟦ scps effs  ⟧ (Prog effs (Prog effs A))  → Prog effs A
\end{code}
Piróg et al. also derive algebras for the above monad, which correctly model
scoped effects.
To implement their recursion scheme we have to define \AgdaFunction{>>=} for 
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.
Notice that \AgdaDatatype{Prog} is a truly nested or non-regular data
type~\cite{DBLP:conf/mpc/BirdM98}.

Defining recursive functions for these data types is more complicated.
The ``direct'' implementations of \AgdaFunction{fmap} and \AgdaFunction{>>=}
do not obviously terminate.
Augmenting \AgdaDatatype{Prog} with size annotations leads to problems when
proving the monad laws\footnote{As in chapter \ref{chapter:higher-order} the
  monad laws only hold for size $\infty$, but working with size $\infty$ in
  proofs leads to termination problems.
  The \AgdaInductiveConstructor{scp} constructor can produce an arbitrary number
  of \AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layers.
  This forces us to use our induction hypothesis on not obviously smaller terms,
  but the size annotation is assumed to be $\infty$.}.
Instead we will define a generic \AgdaFunction{fold}, which we can reuse for all
functions traversing elements of
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.


\subsection{Folds for Nested Data Types}
\label{scoped-algebra:fold}

Defining recursion schemes for complex recursive data types is a common problem.
Fu and Selinger demonstrate a general construction for \texttt{fold}s for nested
data types in Agda~\cite{DBLP:journals/corr/abs-1806-05230}.
Following their construction and adapting it to arbitrary branching trees leads
to a sufficiently strong \texttt{fold} to define all important functions for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.

\paragraph{Index Type} The first part of the construction by Fu and Selinger is
to define the correct index type for the data structure.
The index type describes the recursive structure of the data type i.e. how the
type variables at each level are instantiated.
For complex mutual recursive data types the index type takes the form of a
branching tree.
For \AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}
the one type variable is either instantiated with the value type $A$
(\AgdaInductiveConstructor{pure}) or some number of
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layers applied to
the current type variable (\AgdaInductiveConstructor{op},
\AgdaInductiveConstructor{scp}).
Our index type therefore just counts the number of
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} layers.
Natural numbers are sufficient.

Next Fu and Selinger define a type level function, which translates a value of
the index type to its corresponding type.
For
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}
this function just applies \AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}
$n$ times to \AgdaArgument{A}.
The operator \AgdaFunction{\_\textasciicircum\_} applies a function $n$-times to
a given argument \AgdaArgument{x} i.e. it represents $n$-fold function
application, usually denoted $f^n(x)$.

\begin{code}[hide]
infixl 10 _^_
variable
  A B E S : Set
  effs : List Effect
\end{code}
\begin{code}
_^_ : ∀ {ℓ} {C : Set ℓ} → (C → C) → ℕ → C → C
(f ^ 0)      x = x
(f ^ suc n)  x = f ((f ^ n) x)
\end{code}

\paragraph{Recursion Scheme} Next we will define \AgdaFunction{fold} for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.
The fold produces an arbitrary $\mathbb{N}$ indexed value.
The type family $P$ determines the result type at each index.
The \AgdaFunction{fold} produces a value of type $P\;n$ for a given value of
type
$($\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaFunction{\textasciicircum}\AgdaSpace{}\AgdaArgument{n}$)$\AgdaSpace{}\AgdaArgument{A}.
Furthermore the \texttt{fold} takes functions for processing substructures.
As usual, the arguments of these function correspond to those of the
constructors they processes with recursive occurrences of the type itself already
processed.
The cases are obtained by pattern matching on the index type and the value of
type
$($\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaFunction{\textasciicircum}\AgdaSpace{}\AgdaArgument{n}$)$\AgdaSpace{}\AgdaArgument{A}
i.e. the value of the type depending on the index.

\begin{code}
fold : (P : ℕ → Set) → ∀ n →
  (A                                           → P 0        )  →
  (∀ {n} → P n                                 → P (suc n)  )  →
  (∀ {n} → ⟦ ops   effs  ⟧  (P (suc n))        → P (suc n)  )  →
  (∀ {n} → ⟦ scps  effs  ⟧  (P (suc (suc n)))  → P (suc n)  )  →
  (Prog effs ^ n) A → P n
fold P 0        a v o s x         = a  x
fold P (suc n)  a v o s (var  x)  = v  (       fold P n              a v o s   x)
fold P (suc n)  a v o s (op   x)  = o  (map (  fold P (suc n)        a v o s)  x)
fold P (suc n)  a v o s (scp  x)  = s  (map (  fold P (suc (suc n))  a v o s)  x)
\end{code}
Notices that for the \AgdaInductiveConstructor{op} and
\AgdaInductiveConstructor{spc} constructors the recursive occurrences and
potential additional values are determined by the \AgdaDatatype{Container}.
The functions therefore processor arbitrary \AgdaDatatype{Container} extensions,
which contain solutions for the corresponding index.
When implementing those two cases we cannot apply \AgdaFunction{fold} directly
to recursive occurrences, because those depend on the choice of
\AgdaDatatype{Container}.
\AgdaFunction{map} for \AgdaDatatype{Container}s exactly captures the correct
behavior.

The \AgdaFunction{fold} function, based on the approach by Fu and Selinger, is
similar to the one by Piróg et al.
Piróg et al. derived their \AgdaFunction{fold} by deriving algebras for a
second monad.
In ``Syntax and Semantics for Operations with
Scopes''~\cite{DBLP:conf/lics/PirogSWJ18} they show that the two monads are
equivalent and therefore transfer the \AgdaFunction{fold} from the
second monad to the one used in their Haskell implementation.
Following Fu and Selinger we derived essential the same \AgdaFunction{fold}
and implemented it directly i.e. without the use of \AgdaFunction{>>=}.

\paragraph{Example}
Using \AgdaFunction{fold} we can implement \AgdaFunction{>>=} for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{A}.
The continuations \AgdaArgument{k} passed to \AgdaFunction{>>=} should just
effect the inner most layer.
Intuitively, when using bind an a value constructed with
\AgdaInductiveConstructor{scp} we traverse the outer layer and call bind on the
inner one recursively.
To implement \AgdaFunction{>>=} we fold over the first argument.
We could fix the arbitrary $n$ to be $1$, but defining a version generic in $n$
is useful for later proofs.
The \AgdaDatatype{ℕ} indexed type \AgdaDatatype{bind-P} defines the type for the
intermediate result at every layer.

\begin{code}
bind-P : ∀ A B effs → ℕ → Set
bind-P A B effs 0       = A
bind-P A B effs (suc n) = Prog effs ^ (suc n) $ B
\end{code}
\bind{} corresponds to variable substitution i.e. it replaces the values stored
in \AgdaInductiveConstructor{var} leafs with subtrees generated from these
values.
Calling $k$ on a program with zero layers (a value of type \AgdaArgument{A})
would produce a program with one layer.
Therefore, \bind{} can only be called on programs with at least one layer.
The lowest layer is extended with the result of \AgdaArgument{k}.
For all numbers greater than zero we produce a program with the same structure
but a different value type.
For layer zero (i.e. values) we could either produce a value of type 
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{B}
or leave the value of type \AgdaArgument{A} unchanged.
In both cases we have to handle the lowest \AgdaInductiveConstructor{var}
constructors differently.

\begin{code}
bind : ∀ n → (Prog effs ^ suc n) A → (A → Prog effs B) →
  (Prog effs ^ suc n) B
bind {effs} {A} {B} n ma k = fold (bind-P A B effs) (suc n) id (λ where
    {0}      x → k x
    {suc n}  x → var x
  ) op scp ma
\end{code}
We left the values unchanged, therefore the \AgdaInductiveConstructor{var}
constructor at layer zero has to produce value of type
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}\AgdaSpace{}\AgdaArgument{B}
by calling \AgdaArgument{k}.
In all other cases we replace each constructor with itself to leave these parts
unchanged.

Using \bind{} for a program with one layer and \AgdaInductiveConstructor{var} as
\AgdaFunction{return} we can define a monad instance for
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs}.
In contrast to Haskell this automatically defines a functor and an applicative
instances, because these can be defined in terms of \bind{} and
\AgdaFunction{return}\footnote{We automatically obtain the functions
  \AgdaFunction{<\$>}, \AgdaFunction{<*>}, \AgdaFunction{pure} and
  \AgdaFunction{>>}. }.
\begin{code}
instance
  Prog-RawMonad : RawMonad (Prog effs)
  Prog-RawMonad = record { return = var ; _>>=_ = bind 0 }
\end{code}
The record (which is used as a type class) is part of the Agda standard library.
It is named \AgdaDatatype{RawMonad}, because it does not enforce the monad laws.
We will prove the laws in section \ref{scoped-algebra:monad-laws} using
a technique from section \ref{scoped-algebra:ind}.


\subsection{Induction Schemes for Nested Data Types}
\label{scoped-algebra:ind}

Following the examples by Fu and
Selinger~\cite{DBLP:journals/corr/abs-1806-05230} we can generalize the
\AgdaFunction{fold} from section \ref{scoped-algebra:fold} to a dependently type
version, an induction principle.
In the induction principle the result type/proposition \AgdaDatatype{P} is
generalized to a dependent type.
Therefore the induction principle allows for proofs of predicates by induction
without explicit recursion.

The types for the four functions, corresponding to the three constructors and
the base case, also have to be generalized.

\begin{code}
ind : (P : (n : ℕ) → (Prog effs ^ n) A → Set) → ∀ n →
\end{code}
In the base case the given value of type \AgdaArgument{A} is the handled value.
Therefore the value is bound and passed to the proposition.
\begin{code}
  (               (x : A)                                              → P 0 x                     )  →
\end{code}
The \AgdaInductiveConstructor{var} can be handled similar to the examples by Fu
and Selinger.
An additional hidden parameter \AgdaArgument{x} for the smaller, recursively
handled value is introduced.
Because \AgdaArgument{x} represents the recursively handled type its part of the
smaller results type.
Furthermore, the parameter is used to describe the currently handled value
\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x}.
\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x} is therefore part of
the functions result type.

Under the Curry Howard corresponds this function (ignoring the index type) can
be read as the proposition
$\forall x. P(x) \Rightarrow P(\AgdaInductiveConstructor{var}\;x)$
i.e. the induction step for the constructor \AgdaInductiveConstructor{var}.
\begin{AgdaAlign}
\begin{code}
  (∀ {n x}      → P n x                                                → P (suc n) (var x)         )  →
\end{code}
Similar to \AgdaFunction{fold} dealing with \AgdaInductiveConstructor{op} and
\AgdaInductiveConstructor{scp} is more complicated, because they represent
arbitrarily branching nodes.
Remember that a containers position function maps from a type of positions,
which depends on the values shape, to the contained values.
Hence, assuming the containers values corresponds to assuming a position
function.
Analogues to the \AgdaFunction{fold} the result for the recursively handled value
is function, mapping from positions, for the assumed shape, to proofs for the
proposition for the there contained values.
The value for the position is obtained using the assumed position function
\AgdaArgument{κ}.
The currently handled value is constructed using \AgdaArgument{s} and  
\AgdaArgument{κ}.
Notice that the each of the four parameters depends on all its predecessors.
\begin{code}
  (∀ {n} s {κ}  → ((p : Pos (ops   effs) s) → P (1 + n)  (κ p))  → P (suc n) (op   (s , κ))  )  →
  (∀ {n} s {κ}  → ((p : Pos (scps  effs) s) → P (2 + n)  (κ p))  → P (suc n) (scp  (s , κ))  )  →
  (x : (Prog effs ^ n) A) → P n x
\end{code}
The actual implementation of the induction principle is straight forward and
similar to the one for \AgdaFunction{fold}.
The composition with the position function corresponds to the call to
\AgdaFunction{map}.
\begin{code}
ind P 0       a v o s x               = a x
ind P (suc n) a v o s (var x)         = v    (ind P n              a v o s x)
ind P (suc n) a v o s (op   (c , κ))  = o c  (ind P (suc n)        a v o s ∘ κ)
ind P (suc n) a v o s (scp  (c , κ))  = s c  (ind P (suc (suc n))  a v o s ∘ κ)
\end{code}
\end{AgdaAlign}


\subsection{Proving the Monad Laws}
\label{scoped-algebra:monad-laws}

\paragraph{Left Identity}
First we will prove the left identitiy law.
Because the value passed \AgdaFunction{>>=} constructed using
\AgdaFunction{return} i.e. \AgdaInductiveConstructor{var} both sides of the
equality can be directly evaluated to
\AgdaArgument{k}\AgdaSpace{}\AgdaArgument{a}.

\begin{code}
bind-identˡ : ∀ {A B : Set} {a} {k : A → Prog effs B} →
  (return a >>= k) ≡ k a
bind-identˡ = refl
\end{code}

\paragraph{Right Identity}
When proving the right identity the value passed to \AgdaFunction{>>=} can be an
arbitrarily complex program. Therefore the proposition is not ``obvious'' as it
was the case with \AgdaFunction{bind-identˡ}.

\begin{AgdaAlign}
\begin{code}
bind-identʳ : {A : Set} (ma : Prog effs A) → (ma >>= return) ≡ ma
\end{code}
\AgdaFunction{>>=} is recursive in its first argument, therefore we will prove
the proposition by induction on \AgdaArgument{ma}.
To use the induction scheme we have to define a proposition for every layer.
Since \AgdaFunction{>>=} does not change values we simply produce a value of
type \AgdaDatatype{⊤} at layer zero.
For all other we proof the proposition for the appropriate
\AgdaFunction{bind} i.e. the one called by \AgdaFunction{fold} to handle a value
for the given \AgdaArgument{n}.

\begin{code}
bind-identʳ {effs} {A} = ind (λ{ 0 _ → ⊤ ; (suc n) p → bind n p var ≡ p })
\end{code}
We call the induction scheme with the given value with one layer, therefore the
initial \AgdaArgument{n} is \AgdaNumber{1}.
The ``proof'' for values can be inferred, because for each value it's just a
value of the unit type.

\begin{code}
  1 _
\end{code}
To proof that the proposition holds for values constructed using
\AgdaInductiveConstructor{var} we have to case split on the number of layers
\AgdaArgument{n}.
For \AgdaNumber{0} we have to proof that
\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x} is equal to itself,
because \AgdaFunction{>>=} leaves values unchanged.
This proof forms the basis for our induction.

For the second case we are given a program \AgdaArgument{x} with
\AgdaInductiveConstructor{suc}\AgdaSpace{}\AgdaArgument{n} layers and an
induction hypothesis \AgdaArgument{IH} that the proposition holds for a call to
\AgdaFunction{bind}\AgdaSpace{}\AgdaArgument{n}.
We have to prove that the proposition holds for
\AgdaFunction{bind}\AgdaSpace{}$($\AgdaInductiveConstructor{suc}\AgdaSpace\AgdaArgument{n}$)$
and the new program \AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x}.
By applying the \AgdaFunction{>>=} rule for \AgdaInductiveConstructor{var} (for
\AgdaArgument{n} greater than zero) we can move \AgdaInductiveConstructor{var}
to the outside.
The new proposition is
\AgdaInductiveConstructor{var}\AgdaSpace{}$($\AgdaFunction{bind}\AgdaSpace{}\AgdaArgument{n}$)$\AgdaSpace{}\AgdaDatatype{≡}\AgdaSpace{}\AgdaInductiveConstructor{var}\AgdaSpace{}\AgdaArgument{x}.
This proposition is equal to the induction hypothesis with
\AgdaInductiveConstructor{var} applied to both sides.
Therefore we can proof it using congruence.

\begin{code}
  (λ{ {0} (tt) → refl ; {suc n} IH → cong var IH })
\end{code}
The proofs for the \AgdaInductiveConstructor{op} and
\AgdaInductiveConstructor{scp} are identical and similar to the
\AgdaInductiveConstructor{var} case. For each shape \AgdaArgument{s} we are
given a proof for each position of the given shape.
We have to proof that the proposition holds for a new program constructed using
either \AgdaInductiveConstructor{op} or \AgdaInductiveConstructor{scp}.
For both constrcutors \AgdaFunction{bind}\AgdaSpace{}\AgdaArgument{n} calls
itself recusrivly on the all contained values i.e. the results of the position
function.
Using congruence we can simplify the equality to the equality of the position
functions.
By invoking the axiom of extensionality we can prove the equality for each
position.
This equality is exactly the one given by the induction hypothesis.

\begin{code}
  (λ s IH → cong (op   ∘ (s ,_)) (extensionality IH))
  (λ s IH → cong (scp  ∘ (s ,_)) (extensionality IH))
\end{code}
\end{AgdaAlign}

\paragraph{Associativity}
The proof for associativity follows the same pattern as the one for the right
identity.
\AgdaFunction{>>=} is defined by recursion on its first argument.
We therefore proof the proposition by induction on \AgdaArgument{ma}.
In all cases the left-hand side reduces to the induction hypothesis in the same
manner as before.
Therefore these cases look identical.

\begin{code}
bind-assoc : ∀ {A B C}
  (f : A → Prog effs B) (g : B → Prog effs C) (ma : Prog effs A) →
  (ma >>= f >>= g) ≡ (ma >>= λ a → f a >>= g)
bind-assoc f g = ind
  (λ where
    0 p        → ⊤
    (suc n) p  → bind n (bind n p f) g ≡ bind n p λ a → bind 0 (f a) g
  ) 1 _
  (λ{ {0} _ → refl ; {suc n} IH → cong var IH})
  (λ s IH → cong (op   ∘ (s ,_)) (extensionality IH))
  (λ s IH → cong (scp  ∘ (s ,_)) (extensionality IH))
\end{code}

\paragraph{Functor and Applicative Laws}
The monad laws imply the functor and applicative laws.
We can proof them without using explicit induction by rewriting equations
involving \AgdaFunction{>>=} using the above law.
These proofs are simpler than the ones explicitly involving the definition of
\AgdaFunction{>>=} using \AgdaFunction{fold}.
We can write them using the chain reasoning operators as described by
Norell~\cite{norell:thesis}.

\begin{code}
fmap-id : ∀ {effs} {A B : Set} → (ma : Prog effs A) → (id <$> ma) ≡ ma
fmap-id ma = begin
  (id <$> ma)                ≡⟨⟩ -- definition of <$>
  (ma >>= λ a → var (id a))  ≡⟨⟩ -- definition of id and η-conversion
  (ma >>= var)               ≡⟨ bind-identʳ ma ⟩
  ma                         ∎
\end{code}


\section{Combining Effects}

Similar to chapter \ref{chapter:higher-order} we reuse parts of the
infrastructure from chapter \ref{chapter:first-order}.
Each \AgdaDatatype{Effect} consists of a pair of \AgdaDatatype{Container}s, on
representing scoped and one representing unscoped effects.
Therefore, an \AgdaDatatype{Effect} stack now stores pairs of containers, not
containers directly.
The type \AgdaDatatype{\_∈\_} together with \AgdaFunction{inj} and
\AgdaFunction{prj} can be reused to model effect constraints.

\begin{code}[hide]
variable
  C  : Container
  Cs : List Container
  e : Effect
\end{code}

\begin{code}[hide] % TODO: non stdlib version
infix 3 _∈_
_∈_ : ∀ {a} {A : Set a} → A → List A → Set a
x ∈ xs = Any (_≡_ x) xs

instance
  ∈-head : ∀ {a} {A : Set a} {x : A} {xs} → x ∈ x ∷ xs
  ∈-head = here refl

  ∈-tail : ∀ {a} {A : Set a} {x y : A} {xs} → ⦃ x ∈ xs ⦄ → x ∈ y ∷ xs
  ∈-tail ⦃ p ⦄ = there p

inj : C ∈ Cs → ⟦ C ⟧ A → ⟦ sum Cs ⟧ A
inj (here refl) (s , κ) = inj₁ s , κ
inj (there p)   q       with inj p q
... | s , κ = inj₂ s , κ

prj : C ∈ Cs → ⟦ sum Cs ⟧ A → Maybe (⟦ C ⟧ A)
prj (here refl) (inj₁ s , κ) = just (s , κ)
prj (here refl) (inj₂ s , κ) = nothing
prj (there p)   (inj₁ s , κ) = nothing
prj (there p)   (inj₂ s , κ) = prj p (s , κ)
\end{code}
Due to the component wise combination of \AgdaDatatype{Effect}s, a proof that an
\AgdaDatatype{Effect} is an element of an effect stack implies that an
operations from one of the two signatures is part of the corresponding
signature of the combined effect.

\begin{code}
opsInj : e ∈ effs → Ops e ∈ mapᴸ Ops effs
opsInj (here refl) = here refl
opsInj (there p)   = there (opsInj p)

scpsInj : e ∈ effs → Scps e ∈ mapᴸ Scps effs
scpsInj (here refl) = here refl
scpsInj (there p)   = there (scpsInj p)
\end{code}
Using the above proofs we can implement smart constructors/inject functions for
scoped and unscoped operations without requiring other evidence.

\begin{code}
Op : ⦃ e ∈ effs ⦄ → ⟦ Ops e ⟧ (Prog effs A) → Prog effs A
Op ⦃ p ⦄ = op ∘ inj (opsInj p)

Scp : ⦃ e ∈ effs ⦄ → ⟦ Scps e ⟧ (Prog effs (Prog effs A)) → Prog effs A
Scp ⦃ p ⦄ = scp ∘ inj (scpsInj p)
\end{code}


\section{Nondet}

As first example we will implement the nondeterminism effect.
In section \ref{scoped-algebra:nondet:scoped-algebra} we will implement the
example by Piróg et al. to demonstrate that the \AgdaFunction{fold} definition
from section \ref{scoped-algebra:fold} is sufficient.
Section \ref{scoped-algebra:nondet:modular} will present an idea for modular
effects and handlers.

\subsection{As Scoped Algebra}
\label{scoped-algebra:nondet:scoped-algebra}
The signature for the two algebraic operations is the same as before.
Furthermore we define a signature for the scoped operations \AgdaFunction{once}.

\begin{code}[hide]
CID : Set
CID = (ℕ × ℕ) × ℕ
\end{code}
\begin{code}
data Choiceˢ  : Set where ⁇ˢ : (Maybe CID) → Choiceˢ ; failˢ : Choiceˢ
data Onceˢ    : Set where onceˢ : Onceˢ
\end{code}
\AgdaDatatype{Nondetᵖ} corresponds to the data type from the example by Piróg et
al.~\cite[sec.~6]{DBLP:conf/lics/PirogSWJ18}.
The effect has the unary, scoped operation \AgdaFunction{once} and the nullary
and binary, algebraic operations \AgdaFunction{⁇} and \AgdaFunction{fail}.

\begin{code}
Nondetᵖ : Effect
Ops   Nondetᵖ = Choiceˢ  ▷ λ{ (⁇ˢ _) → Bool ; failˢ → ⊥ }
Scps  Nondetᵖ = Onceˢ    ↝ ⊤
\end{code}
A scoped algebra for an \AgdaDatatype{ℕ} indexed carrier type \AgdaArgument{C}
consists of three operations.
\AgdaField{a} the \textit{algebra} for the unscoped operations.
\AgdaField{p} for \textit{promoting} the carrier type when entering a scope.
\AgdaField{d} for \textit{demoting} the carrier type when leaving a scope and
interpreting the syntax.
Figure \ref{scoped-algebra:fig:reduction} demonstrates how the handler
interprets \AgdaDatatype{Nondet} syntax using the scoped algebra.
It corresponds to an image for the other monad from ``Syntax and Semantics for
Operations with Scopes'', but represents programs using the
\AgdaDatatype{Prog}\AgdaSpace{}\AgdaArgument{effs} monad.

\begin{figure}
  \begin{tikzpicture}[level distance=.7cm,sibling distance=1.3cm]
  \node[treenode] at (0,0) {\textbf{scp once}}
    child { 
      node[treenode] {\textbf{?}}
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {\textbf{?}}
          child {
            node[treenode] {\textbf{var}}
            child { node[treenode] {$1$} }
          }
          child {
            node[treenode] {\textbf{var}}
            child { node[treenode] {$2$} }
          }
        }
      }
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {\textbf{?}}
          child {
            node[treenode] {\textbf{var}}
            child { node[treenode] {$3$} }
          }
          child {
            node[treenode] {\textbf{var}}
            child { node[treenode] {$4$} }
          }
        }
      }
    }
  ;
  \node[treenode] at (1.5,0) {$\stackrel{p}{\leadsto{}}$};
  \node[treenode] at (3,0) {\textbf{scp once}}
    child { 
      node[treenode] {\textbf{?}}
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {\textbf{?}}
          child { node[treenode] {$[1]$} }
          child { node[treenode] {$[2]$} }
        }
      }
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {\textbf{?}}
          child { node[treenode] {$[3]$} }
          child { node[treenode] {$[4]$} }
        }
      }
    }
  ;
  \node[treenode] at (4.5,0) {$\stackrel{a}{\leadsto{}}$};
  \node[treenode] at (6,0) {\textbf{scp once}}
    child { 
      node[treenode] {\textbf{?}}
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {$[1,2]$}
        }
      }
      child {
        node[treenode] {\textbf{var}}
        child[sibling distance=.6cm] {
          node[treenode] {$[3,4]$}
        }
      }
    }
  ;
  \node[treenode] at (7.25,0) {$\stackrel{p}{\leadsto{}}$};
  \node[treenode] at (8.5,0) {\textbf{scp once}}
    child { 
      node[treenode] {\textbf{?}}
      child {
        node[treenode] {$[[1,2]]$}
      }
      child {
        node[treenode] {$[[3,4]]$}
      }
    }
  ;
  \node[treenode] at (9.75,0) {$\stackrel{a}{\leadsto{}}$};
  \node[treenode] at (11,0) {\textbf{scp once}}
    child { 
      node[treenode] {$[[1,2],[3,4]]$}
    }
  ;
  \node[treenode] at (12.25,0) {$\stackrel{d}{\leadsto{}}$};
  \node[treenode] at (13,0) {$[1,2]$};
  \end{tikzpicture}
  \label{scoped-algebra:fig:reduction}
  \caption{Interpretation of
    $\textbf{once}\;(\textbf{var}\;1\;?\;\textbf{var}\;3)\bind \lambda
    x.\textbf{var}\;x\;?\;\textbf{var}\;(x+1)$}
\end{figure}

The indices for \AgdaField{d} and \AgdaField{a} are offset by one compared to
the definition by Piróg et al.
We won't define our carrier data type in two stages as Piróg et al. but as an
$n$-fold version of a simpler type.
This change allows a simpler implementation using the \AgdaFunction{fold} from
section \ref{scoped-algebra:fold}, but should be insignificantly enough to
present the similarities between the to recursion schemes.

\begin{code}
record ScopedAlgebra (E : Effect) (C : ℕ → Set) : Set where
  constructor ⟨_,_,_⟩
  field
    p : ∀ {n} → C n                      → C (1 + n)
    d : ∀ {n} → ⟦ Scps  E ⟧ (C (2 + n))  → C (1 + n)
    a : ∀ {n} → ⟦ Ops   E ⟧ (C (1 + n))  → C (1 + n)
open ScopedAlgebra
\end{code}
Given a \AgdaDatatype{ScopedAlgebra} for an \AgdaDatatype{Effect} we can
interpret its syntax.
\AgdaDatatype{foldᴾ} corresponds to slightly modified version of the fold by
Piróg et al.
Their function works for an arbitrary \AgdaArgument{n} to allow recursion.
Since, this recursion is abstracted in \AgdaFunction{fold} this is not needed.
Furthermore they have to inject values explicitly into the carrier type.
This happens implicitly due to the handling of the $0$-th layer.
Notice that the functions from the \AgdaDatatype{ScopedAlgebra} correspond
exactly to the ones expected by the \AgdaFunction{fold} from section
\ref{scoped-algebra:fold}.
The values them self aren't preprocessed and will just get promoted, hence
\AgdaFunction{id} as passed as the first of the four functions.

\begin{code}
foldᴾ : ∀ {C : Set → ℕ → Set} → ScopedAlgebra e (C A) → 
  Prog (e ∷ []) (C A 0) → C A 1
foldᴾ {C = C} ⟨ p , d , a ⟩ = fold (C _) 1 id p
  (λ{ (inj₁ s , κ) → a (s , κ) }) λ{ (inj₁ s , κ) → d (s , κ) }
\end{code}
Just porting the algebra for \AgdaDatatype{Nondet} by Piróg et al. yields a
correct handler for the effect in isolation.
The carrier type are iterated \AgdaDatatype{List}s.

The implementation of the scoped algebra is straight forward.
The algebraic operations are handled as before and the promotion operation
corresponds to the earlier handling of values.
The demotion operation i.e. the handler for \AgdaFunction{once} has
to produce an $n$-fold list, given an $n+1$-fold list.
% :/
Before applying the handler, the programs in the \AgdaInductiveConstructor{var}
nodes are the results for all possible continuations for the program in scope.
The elements of the given list are the results of these programs.
By acting just on the given list of lists the handler can separate between the
results of the different branches in the scoped program.

\begin{code}
NondetAlg : ScopedAlgebra Nondetᵖ (λ i → List ^ i $ A)
p NondetAlg              = _∷ []
a NondetAlg (⁇ˢ _  , κ)  = κ true ++ κ false
a NondetAlg (failˢ , κ)  = []
d NondetAlg (onceˢ , κ)  with κ tt
... | []     = []
... | x ∷ _  = x

runNondetᴾ : Prog (Nondetᵖ ∷ []) A → List A
runNondetᴾ = foldᴾ {C = λ A i → List ^ i $ A} NondetAlg
\end{code}
The carrier type can be thought of as the context for the computation.
By having contexts of contexts it's possible to differentiate between the state
of the computation in scope and the whole computation.


\subsection{As Modular Handler}
\label{scoped-algebra:nondet:modular}

\begin{code}
Nondet : Effect
Ops   Nondet = Choiceˢ ▷ λ{ (⁇ˢ _) → Bool ; failˢ → ⊥ }
Scps  Nondet = Void

pattern Other s κ     = (inj₂ s , κ)
pattern Choice cid κ  = (inj₁ (⁇ˢ cid) , κ)
pattern Fail          = (inj₁ failˢ , _)

runNondet : Prog (Nondet ∷ effs) A → Prog effs (List A)
runNondet {effs} {A} = fold (λ i → (Prog effs ∘ List) ^ i $ A) 1 id
  (pure ∘ (_∷ []))
  (λ where
    (Choice _ κ) → ⦇ κ true ++ κ false ⦈
    Fail         → pure []
    (Other s κ)  → op (s , κ)
  ) λ where
    (Other s κ)  → scp (s , λ p → hdl <$> κ p)
  where
    hdl : ∀ {A} → List (Prog effs (List A)) → Prog effs (List A)
    hdl []          = pure []
    hdl (mx ∷ mxs)  = ⦇ mx ++ hdl mxs ⦈
\end{code}

\section{Exceptions}

\begin{code}
data Throwˢ (E : Set)  : Set where throwˢ : (e : E) → Throwˢ E
data Catchˢ            : Set where catchˢ : Catchˢ
data Catchᵖ (E : Set)  : Set where
  mainᵖ    : Catchᵖ E
  handleᵖ  : (e : E) → Catchᵖ E

Exc : Set → Effect
Ops   (Exc E) = Throwˢ E  ▷ const ⊥
Scps  (Exc E) = Catchˢ    ▷ const (Catchᵖ E)

pattern Throw  e = (inj₁ (throwˢ e) , _)
pattern Catch  κ = (inj₁ catchˢ , κ)

runExc : Prog (Exc E ∷ effs) A → Prog effs (E ⊎ A)
runExc {E} {effs} {A} = fold (λ i → (Prog effs ∘ (E ⊎_)) ^ i $ A) 1 id
  (pure ∘ inj₂)
  ( λ where
    (Throw e)    → pure (inj₁ e)
    (Other s κ)  → op (s , κ)
  ) λ where
    (Catch κ) → κ mainᵖ >>= λ where
      (inj₂ x)  → x
      (inj₁ e)  → κ (handleᵖ e) >>= λ where
        (inj₁ e)  → pure (inj₁ e)
        (inj₂ x)  → x
    (Other s κ) → scp (s , λ p → [ pure ∘ inj₁ , id ] <$> κ p)

throw : ⦃ Exc E ∈ effs ⦄ → E → Prog effs A
throw e = Op (throwˢ e , λ())

_catch_ : ⦃ Exc E ∈ effs ⦄ → Prog effs A → (E → Prog effs A) → Prog effs A
p catch h = Scp $ catchˢ , λ where
  mainᵖ        → pure <$> p
  (handleᵖ e)  → pure <$> h e
\end{code}


\section{State}

\begin{code}
data Stateˢ (S : Set) : Set where
  putˢ : (s : S) → Stateˢ S
  getˢ : Stateˢ S

State : Set → Effect
Ops   (State S) = (Stateˢ S) ▷ λ{ (putˢ s) → ⊤ ; getˢ → S }
Scps  (State S) = Void

pattern Get κ     = (inj₁ getˢ , κ)
pattern Put s₁ κ  = (inj₁ (putˢ s₁) , κ)

eval : A × (A → B) → B
eval (a , f) = f a

runState : Prog (State S ∷ effs) A → S → Prog effs (S × A)
runState {S} {effs} {A} = fold (λ i → (λ X → S → Prog effs (S × X)) ^ i $ A) 1 id
  (λ x s₀ → pure (s₀ , x))
  (λ where
    (Put s₁ κ) _    → κ tt s₁
    (Get κ) s₀      → κ s₀ s₀
    (Other s κ) s₀  → op (s , λ p → κ p s₀)
  ) λ where
    (Other s κ) s₀ → scp (s , λ p → eval <$> κ p s₀)

get : ⦃ State S ∈ effs ⦄ → Prog effs S
get = Op (getˢ , pure)

put : ⦃ State S ∈ effs ⦄ → S → Prog effs ⊤
put s = Op (putˢ s , pure)
\end{code}


\section{Share}

